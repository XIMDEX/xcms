/*! jQuery v1.8.3 jquery.com | jquery.org/license */
(function(e,t){function _(e){var t=M[e]={};return v.each(e.split(y),function(e,n){t[n]=!0}),t}function H(e,n,r){if(r===t&&e.nodeType===1){var i="data-"+n.replace(P,"-$1").toLowerCase();r=e.getAttribute(i);if(typeof r=="string"){try{r=r==="true"?!0:r==="false"?!1:r==="null"?null:+r+""===r?+r:D.test(r)?v.parseJSON(r):r}catch(s){}v.data(e,n,r)}else r=t}return r}function B(e){var t;for(t in e){if(t==="data"&&v.isEmptyObject(e[t]))continue;if(t!=="toJSON")return!1}return!0}function et(){return!1}function tt(){return!0}function ut(e){return!e||!e.parentNode||e.parentNode.nodeType===11}function at(e,t){do e=e[t];while(e&&e.nodeType!==1);return e}function ft(e,t,n){t=t||0;if(v.isFunction(t))return v.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return v.grep(e,function(e,r){return e===t===n});if(typeof t=="string"){var r=v.grep(e,function(e){return e.nodeType===1});if(it.test(t))return v.filter(t,r,!n);t=v.filter(t,r)}return v.grep(e,function(e,r){return v.inArray(e,t)>=0===n})}function lt(e){var t=ct.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function At(e,t){if(t.nodeType!==1||!v.hasData(e))return;var n,r,i,s=v._data(e),o=v._data(t,s),u=s.events;if(u){delete o.handle,o.events={};for(n in u)for(r=0,i=u[n].length;r<i;r++)v.event.add(t,n,u[n][r])}o.data&&(o.data=v.extend({},o.data))}function Ot(e,t){var n;if(t.nodeType!==1)return;t.clearAttributes&&t.clearAttributes(),t.mergeAttributes&&t.mergeAttributes(e),n=t.nodeName.toLowerCase(),n==="object"?(t.parentNode&&(t.outerHTML=e.outerHTML),v.support.html5Clone&&e.innerHTML&&!v.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):n==="input"&&Et.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):n==="option"?t.selected=e.defaultSelected:n==="input"||n==="textarea"?t.defaultValue=e.defaultValue:n==="script"&&t.text!==e.text&&(t.text=e.text),t.removeAttribute(v.expando)}function Mt(e){return typeof e.getElementsByTagName!="undefined"?e.getElementsByTagName("*"):typeof e.querySelectorAll!="undefined"?e.querySelectorAll("*"):[]}function _t(e){Et.test(e.type)&&(e.defaultChecked=e.checked)}function Qt(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=Jt.length;while(i--){t=Jt[i]+n;if(t in e)return t}return r}function Gt(e,t){return e=t||e,v.css(e,"display")==="none"||!v.contains(e.ownerDocument,e)}function Yt(e,t){var n,r,i=[],s=0,o=e.length;for(;s<o;s++){n=e[s];if(!n.style)continue;i[s]=v._data(n,"olddisplay"),t?(!i[s]&&n.style.display==="none"&&(n.style.display=""),n.style.display===""&&Gt(n)&&(i[s]=v._data(n,"olddisplay",nn(n.nodeName)))):(r=Dt(n,"display"),!i[s]&&r!=="none"&&v._data(n,"olddisplay",r))}for(s=0;s<o;s++){n=e[s];if(!n.style)continue;if(!t||n.style.display==="none"||n.style.display==="")n.style.display=t?i[s]||"":"none"}return e}function Zt(e,t,n){var r=Rt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function en(e,t,n,r){var i=n===(r?"border":"content")?4:t==="width"?1:0,s=0;for(;i<4;i+=2)n==="margin"&&(s+=v.css(e,n+$t[i],!0)),r?(n==="content"&&(s-=parseFloat(Dt(e,"padding"+$t[i]))||0),n!=="margin"&&(s-=parseFloat(Dt(e,"border"+$t[i]+"Width"))||0)):(s+=parseFloat(Dt(e,"padding"+$t[i]))||0,n!=="padding"&&(s+=parseFloat(Dt(e,"border"+$t[i]+"Width"))||0));return s}function tn(e,t,n){var r=t==="width"?e.offsetWidth:e.offsetHeight,i=!0,s=v.support.boxSizing&&v.css(e,"boxSizing")==="border-box";if(r<=0||r==null){r=Dt(e,t);if(r<0||r==null)r=e.style[t];if(Ut.test(r))return r;i=s&&(v.support.boxSizingReliable||r===e.style[t]),r=parseFloat(r)||0}return r+en(e,t,n||(s?"border":"content"),i)+"px"}function nn(e){if(Wt[e])return Wt[e];var t=v("<"+e+">").appendTo(i.body),n=t.css("display");t.remove();if(n==="none"||n===""){Pt=i.body.appendChild(Pt||v.extend(i.createElement("iframe"),{frameBorder:0,width:0,height:0}));if(!Ht||!Pt.createElement)Ht=(Pt.contentWindow||Pt.contentDocument).document,Ht.write("<!doctype html><html><body>"),Ht.close();t=Ht.body.appendChild(Ht.createElement(e)),n=Dt(t,"display"),i.body.removeChild(Pt)}return Wt[e]=n,n}function fn(e,t,n,r){var i;if(v.isArray(t))v.each(t,function(t,i){n||sn.test(e)?r(e,i):fn(e+"["+(typeof i=="object"?t:"")+"]",i,n,r)});else if(!n&&v.type(t)==="object")for(i in t)fn(e+"["+i+"]",t[i],n,r);else r(e,t)}function Cn(e){return function(t,n){typeof t!="string"&&(n=t,t="*");var r,i,s,o=t.toLowerCase().split(y),u=0,a=o.length;if(v.isFunction(n))for(;u<a;u++)r=o[u],s=/^\+/.test(r),s&&(r=r.substr(1)||"*"),i=e[r]=e[r]||[],i[s?"unshift":"push"](n)}}function kn(e,n,r,i,s,o){s=s||n.dataTypes[0],o=o||{},o[s]=!0;var u,a=e[s],f=0,l=a?a.length:0,c=e===Sn;for(;f<l&&(c||!u);f++)u=a[f](n,r,i),typeof u=="string"&&(!c||o[u]?u=t:(n.dataTypes.unshift(u),u=kn(e,n,r,i,u,o)));return(c||!u)&&!o["*"]&&(u=kn(e,n,r,i,"*",o)),u}function Ln(e,n){var r,i,s=v.ajaxSettings.flatOptions||{};for(r in n)n[r]!==t&&((s[r]?e:i||(i={}))[r]=n[r]);i&&v.extend(!0,e,i)}function An(e,n,r){var i,s,o,u,a=e.contents,f=e.dataTypes,l=e.responseFields;for(s in l)s in r&&(n[l[s]]=r[s]);while(f[0]==="*")f.shift(),i===t&&(i=e.mimeType||n.getResponseHeader("content-type"));if(i)for(s in a)if(a[s]&&a[s].test(i)){f.unshift(s);break}if(f[0]in r)o=f[0];else{for(s in r){if(!f[0]||e.converters[s+" "+f[0]]){o=s;break}u||(u=s)}o=o||u}if(o)return o!==f[0]&&f.unshift(o),r[o]}function On(e,t){var n,r,i,s,o=e.dataTypes.slice(),u=o[0],a={},f=0;e.dataFilter&&(t=e.dataFilter(t,e.dataType));if(o[1])for(n in e.converters)a[n.toLowerCase()]=e.converters[n];for(;i=o[++f];)if(i!=="*"){if(u!=="*"&&u!==i){n=a[u+" "+i]||a["* "+i];if(!n)for(r in a){s=r.split(" ");if(s[1]===i){n=a[u+" "+s[0]]||a["* "+s[0]];if(n){n===!0?n=a[r]:a[r]!==!0&&(i=s[0],o.splice(f--,0,i));break}}}if(n!==!0)if(n&&e["throws"])t=n(t);else try{t=n(t)}catch(l){return{state:"parsererror",error:n?l:"No conversion from "+u+" to "+i}}}u=i}return{state:"success",data:t}}function Fn(){try{return new e.XMLHttpRequest}catch(t){}}function In(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}function $n(){return setTimeout(function(){qn=t},0),qn=v.now()}function Jn(e,t){v.each(t,function(t,n){var r=(Vn[t]||[]).concat(Vn["*"]),i=0,s=r.length;for(;i<s;i++)if(r[i].call(e,t,n))return})}function Kn(e,t,n){var r,i=0,s=0,o=Xn.length,u=v.Deferred().always(function(){delete a.elem}),a=function(){var t=qn||$n(),n=Math.max(0,f.startTime+f.duration-t),r=n/f.duration||0,i=1-r,s=0,o=f.tweens.length;for(;s<o;s++)f.tweens[s].run(i);return u.notifyWith(e,[f,i,n]),i<1&&o?n:(u.resolveWith(e,[f]),!1)},f=u.promise({elem:e,props:v.extend({},t),opts:v.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:qn||$n(),duration:n.duration,tweens:[],createTween:function(t,n,r){var i=v.Tween(e,f.opts,t,n,f.opts.specialEasing[t]||f.opts.easing);return f.tweens.push(i),i},stop:function(t){var n=0,r=t?f.tweens.length:0;for(;n<r;n++)f.tweens[n].run(1);return t?u.resolveWith(e,[f,t]):u.rejectWith(e,[f,t]),this}}),l=f.props;Qn(l,f.opts.specialEasing);for(;i<o;i++){r=Xn[i].call(f,e,l,f.opts);if(r)return r}return Jn(f,l),v.isFunction(f.opts.start)&&f.opts.start.call(e,f),v.fx.timer(v.extend(a,{anim:f,queue:f.opts.queue,elem:e})),f.progress(f.opts.progress).done(f.opts.done,f.opts.complete).fail(f.opts.fail).always(f.opts.always)}function Qn(e,t){var n,r,i,s,o;for(n in e){r=v.camelCase(n),i=t[r],s=e[n],v.isArray(s)&&(i=s[1],s=e[n]=s[0]),n!==r&&(e[r]=s,delete e[n]),o=v.cssHooks[r];if(o&&"expand"in o){s=o.expand(s),delete e[r];for(n in s)n in e||(e[n]=s[n],t[n]=i)}else t[r]=i}}function Gn(e,t,n){var r,i,s,o,u,a,f,l,c,h=this,p=e.style,d={},m=[],g=e.nodeType&&Gt(e);n.queue||(l=v._queueHooks(e,"fx"),l.unqueued==null&&(l.unqueued=0,c=l.empty.fire,l.empty.fire=function(){l.unqueued||c()}),l.unqueued++,h.always(function(){h.always(function(){l.unqueued--,v.queue(e,"fx").length||l.empty.fire()})})),e.nodeType===1&&("height"in t||"width"in t)&&(n.overflow=[p.overflow,p.overflowX,p.overflowY],v.css(e,"display")==="inline"&&v.css(e,"float")==="none"&&(!v.support.inlineBlockNeedsLayout||nn(e.nodeName)==="inline"?p.display="inline-block":p.zoom=1)),n.overflow&&(p.overflow="hidden",v.support.shrinkWrapBlocks||h.done(function(){p.overflow=n.overflow[0],p.overflowX=n.overflow[1],p.overflowY=n.overflow[2]}));for(r in t){s=t[r];if(Un.exec(s)){delete t[r],a=a||s==="toggle";if(s===(g?"hide":"show"))continue;m.push(r)}}o=m.length;if(o){u=v._data(e,"fxshow")||v._data(e,"fxshow",{}),"hidden"in u&&(g=u.hidden),a&&(u.hidden=!g),g?v(e).show():h.done(function(){v(e).hide()}),h.done(function(){var t;v.removeData(e,"fxshow",!0);for(t in d)v.style(e,t,d[t])});for(r=0;r<o;r++)i=m[r],f=h.createTween(i,g?u[i]:0),d[i]=u[i]||v.style(e,i),i in u||(u[i]=f.start,g&&(f.end=f.start,f.start=i==="width"||i==="height"?1:0))}}function Yn(e,t,n,r,i){return new Yn.prototype.init(e,t,n,r,i)}function Zn(e,t){var n,r={height:e},i=0;t=t?1:0;for(;i<4;i+=2-t)n=$t[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}function tr(e){return v.isWindow(e)?e:e.nodeType===9?e.defaultView||e.parentWindow:!1}var n,r,i=e.document,s=e.location,o=e.navigator,u=e.jQuery,a=e.$,f=Array.prototype.push,l=Array.prototype.slice,c=Array.prototype.indexOf,h=Object.prototype.toString,p=Object.prototype.hasOwnProperty,d=String.prototype.trim,v=function(e,t){return new v.fn.init(e,t,n)},m=/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,g=/\S/,y=/\s+/,b=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,w=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,E=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,S=/^[\],:{}\s]*$/,x=/(?:^|:|,)(?:\s*\[)+/g,T=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,N=/"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,C=/^-ms-/,k=/-([\da-z])/gi,L=function(e,t){return(t+"").toUpperCase()},A=function(){i.addEventListener?(i.removeEventListener("DOMContentLoaded",A,!1),v.ready()):i.readyState==="complete"&&(i.detachEvent("onreadystatechange",A),v.ready())},O={};v.fn=v.prototype={constructor:v,init:function(e,n,r){var s,o,u,a;if(!e)return this;if(e.nodeType)return this.context=this[0]=e,this.length=1,this;if(typeof e=="string"){e.charAt(0)==="<"&&e.charAt(e.length-1)===">"&&e.length>=3?s=[null,e,null]:s=w.exec(e);if(s&&(s[1]||!n)){if(s[1])return n=n instanceof v?n[0]:n,a=n&&n.nodeType?n.ownerDocument||n:i,e=v.parseHTML(s[1],a,!0),E.test(s[1])&&v.isPlainObject(n)&&this.attr.call(e,n,!0),v.merge(this,e);o=i.getElementById(s[2]);if(o&&o.parentNode){if(o.id!==s[2])return r.find(e);this.length=1,this[0]=o}return this.context=i,this.selector=e,this}return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e)}return v.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),v.makeArray(e,this))},selector:"",jquery:"1.8.3",length:0,size:function(){return this.length},toArray:function(){return l.call(this)},get:function(e){return e==null?this.toArray():e<0?this[this.length+e]:this[e]},pushStack:function(e,t,n){var r=v.merge(this.constructor(),e);return r.prevObject=this,r.context=this.context,t==="find"?r.selector=this.selector+(this.selector?" ":"")+n:t&&(r.selector=this.selector+"."+t+"("+n+")"),r},each:function(e,t){return v.each(this,e,t)},ready:function(e){return v.ready.promise().done(e),this},eq:function(e){return e=+e,e===-1?this.slice(e):this.slice(e,e+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(l.apply(this,arguments),"slice",l.call(arguments).join(","))},map:function(e){return this.pushStack(v.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:[].sort,splice:[].splice},v.fn.init.prototype=v.fn,v.extend=v.fn.extend=function(){var e,n,r,i,s,o,u=arguments[0]||{},a=1,f=arguments.length,l=!1;typeof u=="boolean"&&(l=u,u=arguments[1]||{},a=2),typeof u!="object"&&!v.isFunction(u)&&(u={}),f===a&&(u=this,--a);for(;a<f;a++)if((e=arguments[a])!=null)for(n in e){r=u[n],i=e[n];if(u===i)continue;l&&i&&(v.isPlainObject(i)||(s=v.isArray(i)))?(s?(s=!1,o=r&&v.isArray(r)?r:[]):o=r&&v.isPlainObject(r)?r:{},u[n]=v.extend(l,o,i)):i!==t&&(u[n]=i)}return u},v.extend({noConflict:function(t){return e.$===v&&(e.$=a),t&&e.jQuery===v&&(e.jQuery=u),v},isReady:!1,readyWait:1,holdReady:function(e){e?v.readyWait++:v.ready(!0)},ready:function(e){if(e===!0?--v.readyWait:v.isReady)return;if(!i.body)return setTimeout(v.ready,1);v.isReady=!0;if(e!==!0&&--v.readyWait>0)return;r.resolveWith(i,[v]),v.fn.trigger&&v(i).trigger("ready").off("ready")},isFunction:function(e){return v.type(e)==="function"},isArray:Array.isArray||function(e){return v.type(e)==="array"},isWindow:function(e){return e!=null&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return e==null?String(e):O[h.call(e)]||"object"},isPlainObject:function(e){if(!e||v.type(e)!=="object"||e.nodeType||v.isWindow(e))return!1;try{if(e.constructor&&!p.call(e,"constructor")&&!p.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||p.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw new Error(e)},parseHTML:function(e,t,n){var r;return!e||typeof e!="string"?null:(typeof t=="boolean"&&(n=t,t=0),t=t||i,(r=E.exec(e))?[t.createElement(r[1])]:(r=v.buildFragment([e],t,n?null:[]),v.merge([],(r.cacheable?v.clone(r.fragment):r.fragment).childNodes)))},parseJSON:function(t){if(!t||typeof t!="string")return null;t=v.trim(t);if(e.JSON&&e.JSON.parse)return e.JSON.parse(t);if(S.test(t.replace(T,"@").replace(N,"]").replace(x,"")))return(new Function("return "+t))();v.error("Invalid JSON: "+t)},parseXML:function(n){var r,i;if(!n||typeof n!="string")return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(s){r=t}return(!r||!r.documentElement||r.getElementsByTagName("parsererror").length)&&v.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&g.test(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(C,"ms-").replace(k,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,n,r){var i,s=0,o=e.length,u=o===t||v.isFunction(e);if(r){if(u){for(i in e)if(n.apply(e[i],r)===!1)break}else for(;s<o;)if(n.apply(e[s++],r)===!1)break}else if(u){for(i in e)if(n.call(e[i],i,e[i])===!1)break}else for(;s<o;)if(n.call(e[s],s,e[s++])===!1)break;return e},trim:d&&!d.call("\ufeff\u00a0")?function(e){return e==null?"":d.call(e)}:function(e){return e==null?"":(e+"").replace(b,"")},makeArray:function(e,t){var n,r=t||[];return e!=null&&(n=v.type(e),e.length==null||n==="string"||n==="function"||n==="regexp"||v.isWindow(e)?f.call(r,e):v.merge(r,e)),r},inArray:function(e,t,n){var r;if(t){if(c)return c.call(t,e,n);r=t.length,n=n?n<0?Math.max(0,r+n):n:0;for(;n<r;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,s=0;if(typeof r=="number")for(;s<r;s++)e[i++]=n[s];else while(n[s]!==t)e[i++]=n[s++];return e.length=i,e},grep:function(e,t,n){var r,i=[],s=0,o=e.length;n=!!n;for(;s<o;s++)r=!!t(e[s],s),n!==r&&i.push(e[s]);return i},map:function(e,n,r){var i,s,o=[],u=0,a=e.length,f=e instanceof v||a!==t&&typeof a=="number"&&(a>0&&e[0]&&e[a-1]||a===0||v.isArray(e));if(f)for(;u<a;u++)i=n(e[u],u,r),i!=null&&(o[o.length]=i);else for(s in e)i=n(e[s],s,r),i!=null&&(o[o.length]=i);return o.concat.apply([],o)},guid:1,proxy:function(e,n){var r,i,s;return typeof n=="string"&&(r=e[n],n=e,e=r),v.isFunction(e)?(i=l.call(arguments,2),s=function(){return e.apply(n,i.concat(l.call(arguments)))},s.guid=e.guid=e.guid||v.guid++,s):t},access:function(e,n,r,i,s,o,u){var a,f=r==null,l=0,c=e.length;if(r&&typeof r=="object"){for(l in r)v.access(e,n,l,r[l],1,o,i);s=1}else if(i!==t){a=u===t&&v.isFunction(i),f&&(a?(a=n,n=function(e,t,n){return a.call(v(e),n)}):(n.call(e,i),n=null));if(n)for(;l<c;l++)n(e[l],r,a?i.call(e[l],l,n(e[l],r)):i,u);s=1}return s?e:f?n.call(e):c?n(e[0],r):o},now:function(){return(new Date).getTime()}}),v.ready.promise=function(t){if(!r){r=v.Deferred();if(i.readyState==="complete")setTimeout(v.ready,1);else if(i.addEventListener)i.addEventListener("DOMContentLoaded",A,!1),e.addEventListener("load",v.ready,!1);else{i.attachEvent("onreadystatechange",A),e.attachEvent("onload",v.ready);var n=!1;try{n=e.frameElement==null&&i.documentElement}catch(s){}n&&n.doScroll&&function o(){if(!v.isReady){try{n.doScroll("left")}catch(e){return setTimeout(o,50)}v.ready()}}()}}return r.promise(t)},v.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(e,t){O["[object "+t+"]"]=t.toLowerCase()}),n=v(i);var M={};v.Callbacks=function(e){e=typeof e=="string"?M[e]||_(e):v.extend({},e);var n,r,i,s,o,u,a=[],f=!e.once&&[],l=function(t){n=e.memory&&t,r=!0,u=s||0,s=0,o=a.length,i=!0;for(;a&&u<o;u++)if(a[u].apply(t[0],t[1])===!1&&e.stopOnFalse){n=!1;break}i=!1,a&&(f?f.length&&l(f.shift()):n?a=[]:c.disable())},c={add:function(){if(a){var t=a.length;(function r(t){v.each(t,function(t,n){var i=v.type(n);i==="function"?(!e.unique||!c.has(n))&&a.push(n):n&&n.length&&i!=="string"&&r(n)})})(arguments),i?o=a.length:n&&(s=t,l(n))}return this},remove:function(){return a&&v.each(arguments,function(e,t){var n;while((n=v.inArray(t,a,n))>-1)a.splice(n,1),i&&(n<=o&&o--,n<=u&&u--)}),this},has:function(e){return v.inArray(e,a)>-1},empty:function(){return a=[],this},disable:function(){return a=f=n=t,this},disabled:function(){return!a},lock:function(){return f=t,n||c.disable(),this},locked:function(){return!f},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],a&&(!r||f)&&(i?f.push(t):l(t)),this},fire:function(){return c.fireWith(this,arguments),this},fired:function(){return!!r}};return c},v.extend({Deferred:function(e){var t=[["resolve","done",v.Callbacks("once memory"),"resolved"],["reject","fail",v.Callbacks("once memory"),"rejected"],["notify","progress",v.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return v.Deferred(function(n){v.each(t,function(t,r){var s=r[0],o=e[t];i[r[1]](v.isFunction(o)?function(){var e=o.apply(this,arguments);e&&v.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[s+"With"](this===i?n:this,[e])}:n[s])}),e=null}).promise()},promise:function(e){return e!=null?v.extend(e,r):r}},i={};return r.pipe=r.then,v.each(t,function(e,s){var o=s[2],u=s[3];r[s[1]]=o.add,u&&o.add(function(){n=u},t[e^1][2].disable,t[2][2].lock),i[s[0]]=o.fire,i[s[0]+"With"]=o.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=l.call(arguments),r=n.length,i=r!==1||e&&v.isFunction(e.promise)?r:0,s=i===1?e:v.Deferred(),o=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?l.call(arguments):r,n===u?s.notifyWith(t,n):--i||s.resolveWith(t,n)}},u,a,f;if(r>1){u=new Array(r),a=new Array(r),f=new Array(r);for(;t<r;t++)n[t]&&v.isFunction(n[t].promise)?n[t].promise().done(o(t,f,n)).fail(s.reject).progress(o(t,a,u)):--i}return i||s.resolveWith(f,n),s.promise()}}),v.support=function(){var t,n,r,s,o,u,a,f,l,c,h,p=i.createElement("div");p.setAttribute("className","t"),p.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=p.getElementsByTagName("*"),r=p.getElementsByTagName("a")[0];if(!n||!r||!n.length)return{};s=i.createElement("select"),o=s.appendChild(i.createElement("option")),u=p.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={leadingWhitespace:p.firstChild.nodeType===3,tbody:!p.getElementsByTagName("tbody").length,htmlSerialize:!!p.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:r.getAttribute("href")==="/a",opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:u.value==="on",optSelected:o.selected,getSetAttribute:p.className!=="t",enctype:!!i.createElement("form").enctype,html5Clone:i.createElement("nav").cloneNode(!0).outerHTML!=="<:nav></:nav>",boxModel:i.compatMode==="CSS1Compat",submitBubbles:!0,changeBubbles:!0,focusinBubbles:!1,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},u.checked=!0,t.noCloneChecked=u.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!o.disabled;try{delete p.test}catch(d){t.deleteExpando=!1}!p.addEventListener&&p.attachEvent&&p.fireEvent&&(p.attachEvent("onclick",h=function(){t.noCloneEvent=!1}),p.cloneNode(!0).fireEvent("onclick"),p.detachEvent("onclick",h)),u=i.createElement("input"),u.value="t",u.setAttribute("type","radio"),t.radioValue=u.value==="t",u.setAttribute("checked","checked"),u.setAttribute("name","t"),p.appendChild(u),a=i.createDocumentFragment(),a.appendChild(p.lastChild),t.checkClone=a.cloneNode(!0).cloneNode(!0).lastChild.checked,t.appendChecked=u.checked,a.removeChild(u),a.appendChild(p);if(p.attachEvent)for(l in{submit:!0,change:!0,focusin:!0})f="on"+l,c=f in p,c||(p.setAttribute(f,"return;"),c=typeof p[f]=="function"),t[l+"Bubbles"]=c;return v(function(){var n,r,s,o,u="padding:0;margin:0;border:0;display:block;overflow:hidden;",a=i.getElementsByTagName("body")[0];if(!a)return;n=i.createElement("div"),n.style.cssText="visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px",a.insertBefore(n,a.firstChild),r=i.createElement("div"),n.appendChild(r),r.innerHTML="<table><tr><td></td><td>t</td></tr></table>",s=r.getElementsByTagName("td"),s[0].style.cssText="padding:0;margin:0;border:0;display:none",c=s[0].offsetHeight===0,s[0].style.display="",s[1].style.display="none",t.reliableHiddenOffsets=c&&s[0].offsetHeight===0,r.innerHTML="",r.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=r.offsetWidth===4,t.doesNotIncludeMarginInBodyOffset=a.offsetTop!==1,e.getComputedStyle&&(t.pixelPosition=(e.getComputedStyle(r,null)||{}).top!=="1%",t.boxSizingReliable=(e.getComputedStyle(r,null)||{width:"4px"}).width==="4px",o=i.createElement("div"),o.style.cssText=r.style.cssText=u,o.style.marginRight=o.style.width="0",r.style.width="1px",r.appendChild(o),t.reliableMarginRight=!parseFloat((e.getComputedStyle(o,null)||{}).marginRight)),typeof r.style.zoom!="undefined"&&(r.innerHTML="",r.style.cssText=u+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=r.offsetWidth===3,r.style.display="block",r.style.overflow="visible",r.innerHTML="<div></div>",r.firstChild.style.width="5px",t.shrinkWrapBlocks=r.offsetWidth!==3,n.style.zoom=1),a.removeChild(n),n=r=s=o=null}),a.removeChild(p),n=r=s=o=u=a=p=null,t}();var D=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,P=/([A-Z])/g;v.extend({cache:{},deletedIds:[],uuid:0,expando:"jQuery"+(v.fn.jquery+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?v.cache[e[v.expando]]:e[v.expando],!!e&&!B(e)},data:function(e,n,r,i){if(!v.acceptData(e))return;var s,o,u=v.expando,a=typeof n=="string",f=e.nodeType,l=f?v.cache:e,c=f?e[u]:e[u]&&u;if((!c||!l[c]||!i&&!l[c].data)&&a&&r===t)return;c||(f?e[u]=c=v.deletedIds.pop()||v.guid++:c=u),l[c]||(l[c]={},f||(l[c].toJSON=v.noop));if(typeof n=="object"||typeof n=="function")i?l[c]=v.extend(l[c],n):l[c].data=v.extend(l[c].data,n);return s=l[c],i||(s.data||(s.data={}),s=s.data),r!==t&&(s[v.camelCase(n)]=r),a?(o=s[n],o==null&&(o=s[v.camelCase(n)])):o=s,o},removeData:function(e,t,n){if(!v.acceptData(e))return;var r,i,s,o=e.nodeType,u=o?v.cache:e,a=o?e[v.expando]:v.expando;if(!u[a])return;if(t){r=n?u[a]:u[a].data;if(r){v.isArray(t)||(t in r?t=[t]:(t=v.camelCase(t),t in r?t=[t]:t=t.split(" ")));for(i=0,s=t.length;i<s;i++)delete r[t[i]];if(!(n?B:v.isEmptyObject)(r))return}}if(!n){delete u[a].data;if(!B(u[a]))return}o?v.cleanData([e],!0):v.support.deleteExpando||u!=u.window?delete u[a]:u[a]=null},_data:function(e,t,n){return v.data(e,t,n,!0)},acceptData:function(e){var t=e.nodeName&&v.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),v.fn.extend({data:function(e,n){var r,i,s,o,u,a=this[0],f=0,l=null;if(e===t){if(this.length){l=v.data(a);if(a.nodeType===1&&!v._data(a,"parsedAttrs")){s=a.attributes;for(u=s.length;f<u;f++)o=s[f].name,o.indexOf("data-")||(o=v.camelCase(o.substring(5)),H(a,o,l[o]));v._data(a,"parsedAttrs",!0)}}return l}return typeof e=="object"?this.each(function(){v.data(this,e)}):(r=e.split(".",2),r[1]=r[1]?"."+r[1]:"",i=r[1]+"!",v.access(this,function(n){if(n===t)return l=this.triggerHandler("getData"+i,[r[0]]),l===t&&a&&(l=v.data(a,e),l=H(a,e,l)),l===t&&r[1]?this.data(r[0]):l;r[1]=n,this.each(function(){var t=v(this);t.triggerHandler("setData"+i,r),v.data(this,e,n),t.triggerHandler("changeData"+i,r)})},null,n,arguments.length>1,null,!1))},removeData:function(e){return this.each(function(){v.removeData(this,e)})}}),v.extend({queue:function(e,t,n){var r;if(e)return t=(t||"fx")+"queue",r=v._data(e,t),n&&(!r||v.isArray(n)?r=v._data(e,t,v.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||"fx";var n=v.queue(e,t),r=n.length,i=n.shift(),s=v._queueHooks(e,t),o=function(){v.dequeue(e,t)};i==="inprogress"&&(i=n.shift(),r--),i&&(t==="fx"&&n.unshift("inprogress"),delete s.stop,i.call(e,o,s)),!r&&s&&s.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return v._data(e,n)||v._data(e,n,{empty:v.Callbacks("once memory").add(function(){v.removeData(e,t+"queue",!0),v.removeData(e,n,!0)})})}}),v.fn.extend({queue:function(e,n){var r=2;return typeof e!="string"&&(n=e,e="fx",r--),arguments.length<r?v.queue(this[0],e):n===t?this:this.each(function(){var t=v.queue(this,e,n);v._queueHooks(this,e),e==="fx"&&t[0]!=="inprogress"&&v.dequeue(this,e)})},dequeue:function(e){return this.each(function(){v.dequeue(this,e)})},delay:function(e,t){return e=v.fx?v.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,s=v.Deferred(),o=this,u=this.length,a=function(){--i||s.resolveWith(o,[o])};typeof e!="string"&&(n=e,e=t),e=e||"fx";while(u--)r=v._data(o[u],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(a));return a(),s.promise(n)}});var j,F,I,q=/[\t\r\n]/g,R=/\r/g,U=/^(?:button|input)$/i,z=/^(?:button|input|object|select|textarea)$/i,W=/^a(?:rea|)$/i,X=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,V=v.support.getSetAttribute;v.fn.extend({attr:function(e,t){return v.access(this,v.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){v.removeAttr(this,e)})},prop:function(e,t){return v.access(this,v.prop,e,t,arguments.length>1)},removeProp:function(e){return e=v.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,s,o,u;if(v.isFunction(e))return this.each(function(t){v(this).addClass(e.call(this,t,this.className))});if(e&&typeof e=="string"){t=e.split(y);for(n=0,r=this.length;n<r;n++){i=this[n];if(i.nodeType===1)if(!i.className&&t.length===1)i.className=e;else{s=" "+i.className+" ";for(o=0,u=t.length;o<u;o++)s.indexOf(" "+t[o]+" ")<0&&(s+=t[o]+" ");i.className=v.trim(s)}}}return this},removeClass:function(e){var n,r,i,s,o,u,a;if(v.isFunction(e))return this.each(function(t){v(this).removeClass(e.call(this,t,this.className))});if(e&&typeof e=="string"||e===t){n=(e||"").split(y);for(u=0,a=this.length;u<a;u++){i=this[u];if(i.nodeType===1&&i.className){r=(" "+i.className+" ").replace(q," ");for(s=0,o=n.length;s<o;s++)while(r.indexOf(" "+n[s]+" ")>=0)r=r.replace(" "+n[s]+" "," ");i.className=e?v.trim(r):""}}}return this},toggleClass:function(e,t){var n=typeof e,r=typeof t=="boolean";return v.isFunction(e)?this.each(function(n){v(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if(n==="string"){var i,s=0,o=v(this),u=t,a=e.split(y);while(i=a[s++])u=r?u:!o.hasClass(i),o[u?"addClass":"removeClass"](i)}else if(n==="undefined"||n==="boolean")this.className&&v._data(this,"__className__",this.className),this.className=this.className||e===!1?"":v._data(this,"__className__")||""})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;n<r;n++)if(this[n].nodeType===1&&(" "+this[n].className+" ").replace(q," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,s=this[0];if(!arguments.length){if(s)return n=v.valHooks[s.type]||v.valHooks[s.nodeName.toLowerCase()],n&&"get"in n&&(r=n.get(s,"value"))!==t?r:(r=s.value,typeof r=="string"?r.replace(R,""):r==null?"":r);return}return i=v.isFunction(e),this.each(function(r){var s,o=v(this);if(this.nodeType!==1)return;i?s=e.call(this,r,o.val()):s=e,s==null?s="":typeof s=="number"?s+="":v.isArray(s)&&(s=v.map(s,function(e){return e==null?"":e+""})),n=v.valHooks[this.type]||v.valHooks[this.nodeName.toLowerCase()];if(!n||!("set"in n)||n.set(this,s,"value")===t)this.value=s})}}),v.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,s=e.type==="select-one"||i<0,o=s?null:[],u=s?i+1:r.length,a=i<0?u:s?i:0;for(;a<u;a++){n=r[a];if((n.selected||a===i)&&(v.support.optDisabled?!n.disabled:n.getAttribute("disabled")===null)&&(!n.parentNode.disabled||!v.nodeName(n.parentNode,"optgroup"))){t=v(n).val();if(s)return t;o.push(t)}}return o},set:function(e,t){var n=v.makeArray(t);return v(e).find("option").each(function(){this.selected=v.inArray(v(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attrFn:{},attr:function(e,n,r,i){var s,o,u,a=e.nodeType;if(!e||a===3||a===8||a===2)return;if(i&&v.isFunction(v.fn[n]))return v(e)[n](r);if(typeof e.getAttribute=="undefined")return v.prop(e,n,r);u=a!==1||!v.isXMLDoc(e),u&&(n=n.toLowerCase(),o=v.attrHooks[n]||(X.test(n)?F:j));if(r!==t){if(r===null){v.removeAttr(e,n);return}return o&&"set"in o&&u&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r)}return o&&"get"in o&&u&&(s=o.get(e,n))!==null?s:(s=e.getAttribute(n),s===null?t:s)},removeAttr:function(e,t){var n,r,i,s,o=0;if(t&&e.nodeType===1){r=t.split(y);for(;o<r.length;o++)i=r[o],i&&(n=v.propFix[i]||i,s=X.test(i),s||v.attr(e,i,""),e.removeAttribute(V?i:n),s&&n in e&&(e[n]=!1))}},attrHooks:{type:{set:function(e,t){if(U.test(e.nodeName)&&e.parentNode)v.error("type property can't be changed");else if(!v.support.radioValue&&t==="radio"&&v.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}},value:{get:function(e,t){return j&&v.nodeName(e,"button")?j.get(e,t):t in e?e.value:null},set:function(e,t,n){if(j&&v.nodeName(e,"button"))return j.set(e,t,n);e.value=t}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,s,o,u=e.nodeType;if(!e||u===3||u===8||u===2)return;return o=u!==1||!v.isXMLDoc(e),o&&(n=v.propFix[n]||n,s=v.propHooks[n]),r!==t?s&&"set"in s&&(i=s.set(e,r,n))!==t?i:e[n]=r:s&&"get"in s&&(i=s.get(e,n))!==null?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):z.test(e.nodeName)||W.test(e.nodeName)&&e.href?0:t}}}}),F={get:function(e,n){var r,i=v.prop(e,n);return i===!0||typeof i!="boolean"&&(r=e.getAttributeNode(n))&&r.nodeValue!==!1?n.toLowerCase():t},set:function(e,t,n){var r;return t===!1?v.removeAttr(e,n):(r=v.propFix[n]||n,r in e&&(e[r]=!0),e.setAttribute(n,n.toLowerCase())),n}},V||(I={name:!0,id:!0,coords:!0},j=v.valHooks.button={get:function(e,n){var r;return r=e.getAttributeNode(n),r&&(I[n]?r.value!=="":r.specified)?r.value:t},set:function(e,t,n){var r=e.getAttributeNode(n);return r||(r=i.createAttribute(n),e.setAttributeNode(r)),r.value=t+""}},v.each(["width","height"],function(e,t){v.attrHooks[t]=v.extend(v.attrHooks[t],{set:function(e,n){if(n==="")return e.setAttribute(t,"auto"),n}})}),v.attrHooks.contenteditable={get:j.get,set:function(e,t,n){t===""&&(t="false"),j.set(e,t,n)}}),v.support.hrefNormalized||v.each(["href","src","width","height"],function(e,n){v.attrHooks[n]=v.extend(v.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return r===null?t:r}})}),v.support.style||(v.attrHooks.style={get:function(e){return e.style.cssText.toLowerCase()||t},set:function(e,t){return e.style.cssText=t+""}}),v.support.optSelected||(v.propHooks.selected=v.extend(v.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),v.support.enctype||(v.propFix.enctype="encoding"),v.support.checkOn||v.each(["radio","checkbox"],function(){v.valHooks[this]={get:function(e){return e.getAttribute("value")===null?"on":e.value}}}),v.each(["radio","checkbox"],function(){v.valHooks[this]=v.extend(v.valHooks[this],{set:function(e,t){if(v.isArray(t))return e.checked=v.inArray(v(e).val(),t)>=0}})});var $=/^(?:textarea|input|select)$/i,J=/^([^\.]*|)(?:\.(.+)|)$/,K=/(?:^|\s)hover(\.\S+|)\b/,Q=/^key/,G=/^(?:mouse|contextmenu)|click/,Y=/^(?:focusinfocus|focusoutblur)$/,Z=function(e){return v.event.special.hover?e:e.replace(K,"mouseenter$1 mouseleave$1")};v.event={add:function(e,n,r,i,s){var o,u,a,f,l,c,h,p,d,m,g;if(e.nodeType===3||e.nodeType===8||!n||!r||!(o=v._data(e)))return;r.handler&&(d=r,r=d.handler,s=d.selector),r.guid||(r.guid=v.guid++),a=o.events,a||(o.events=a={}),u=o.handle,u||(o.handle=u=function(e){return typeof v=="undefined"||!!e&&v.event.triggered===e.type?t:v.event.dispatch.apply(u.elem,arguments)},u.elem=e),n=v.trim(Z(n)).split(" ");for(f=0;f<n.length;f++){l=J.exec(n[f])||[],c=l[1],h=(l[2]||"").split(".").sort(),g=v.event.special[c]||{},c=(s?g.delegateType:g.bindType)||c,g=v.event.special[c]||{},p=v.extend({type:c,origType:l[1],data:i,handler:r,guid:r.guid,selector:s,needsContext:s&&v.expr.match.needsContext.test(s),namespace:h.join(".")},d),m=a[c];if(!m){m=a[c]=[],m.delegateCount=0;if(!g.setup||g.setup.call(e,i,h,u)===!1)e.addEventListener?e.addEventListener(c,u,!1):e.attachEvent&&e.attachEvent("on"+c,u)}g.add&&(g.add.call(e,p),p.handler.guid||(p.handler.guid=r.guid)),s?m.splice(m.delegateCount++,0,p):m.push(p),v.event.global[c]=!0}e=null},global:{},remove:function(e,t,n,r,i){var s,o,u,a,f,l,c,h,p,d,m,g=v.hasData(e)&&v._data(e);if(!g||!(h=g.events))return;t=v.trim(Z(t||"")).split(" ");for(s=0;s<t.length;s++){o=J.exec(t[s])||[],u=a=o[1],f=o[2];if(!u){for(u in h)v.event.remove(e,u+t[s],n,r,!0);continue}p=v.event.special[u]||{},u=(r?p.delegateType:p.bindType)||u,d=h[u]||[],l=d.length,f=f?new RegExp("(^|\\.)"+f.split(".").sort().join("\\.(?:.*\\.|)")+"(\\.|$)"):null;for(c=0;c<d.length;c++)m=d[c],(i||a===m.origType)&&(!n||n.guid===m.guid)&&(!f||f.test(m.namespace))&&(!r||r===m.selector||r==="**"&&m.selector)&&(d.splice(c--,1),m.selector&&d.delegateCount--,p.remove&&p.remove.call(e,m));d.length===0&&l!==d.length&&((!p.teardown||p.teardown.call(e,f,g.handle)===!1)&&v.removeEvent(e,u,g.handle),delete h[u])}v.isEmptyObject(h)&&(delete g.handle,v.removeData(e,"events",!0))},customEvent:{getData:!0,setData:!0,changeData:!0},trigger:function(n,r,s,o){if(!s||s.nodeType!==3&&s.nodeType!==8){var u,a,f,l,c,h,p,d,m,g,y=n.type||n,b=[];if(Y.test(y+v.event.triggered))return;y.indexOf("!")>=0&&(y=y.slice(0,-1),a=!0),y.indexOf(".")>=0&&(b=y.split("."),y=b.shift(),b.sort());if((!s||v.event.customEvent[y])&&!v.event.global[y])return;n=typeof n=="object"?n[v.expando]?n:new v.Event(y,n):new v.Event(y),n.type=y,n.isTrigger=!0,n.exclusive=a,n.namespace=b.join("."),n.namespace_re=n.namespace?new RegExp("(^|\\.)"+b.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,h=y.indexOf(":")<0?"on"+y:"";if(!s){u=v.cache;for(f in u)u[f].events&&u[f].events[y]&&v.event.trigger(n,r,u[f].handle.elem,!0);return}n.result=t,n.target||(n.target=s),r=r!=null?v.makeArray(r):[],r.unshift(n),p=v.event.special[y]||{};if(p.trigger&&p.trigger.apply(s,r)===!1)return;m=[[s,p.bindType||y]];if(!o&&!p.noBubble&&!v.isWindow(s)){g=p.delegateType||y,l=Y.test(g+y)?s:s.parentNode;for(c=s;l;l=l.parentNode)m.push([l,g]),c=l;c===(s.ownerDocument||i)&&m.push([c.defaultView||c.parentWindow||e,g])}for(f=0;f<m.length&&!n.isPropagationStopped();f++)l=m[f][0],n.type=m[f][1],d=(v._data(l,"events")||{})[n.type]&&v._data(l,"handle"),d&&d.apply(l,r),d=h&&l[h],d&&v.acceptData(l)&&d.apply&&d.apply(l,r)===!1&&n.preventDefault();return n.type=y,!o&&!n.isDefaultPrevented()&&(!p._default||p._default.apply(s.ownerDocument,r)===!1)&&(y!=="click"||!v.nodeName(s,"a"))&&v.acceptData(s)&&h&&s[y]&&(y!=="focus"&&y!=="blur"||n.target.offsetWidth!==0)&&!v.isWindow(s)&&(c=s[h],c&&(s[h]=null),v.event.triggered=y,s[y](),v.event.triggered=t,c&&(s[h]=c)),n.result}return},dispatch:function(n){n=v.event.fix(n||e.event);var r,i,s,o,u,a,f,c,h,p,d=(v._data(this,"events")||{})[n.type]||[],m=d.delegateCount,g=l.call(arguments),y=!n.exclusive&&!n.namespace,b=v.event.special[n.type]||{},w=[];g[0]=n,n.delegateTarget=this;if(b.preDispatch&&b.preDispatch.call(this,n)===!1)return;if(m&&(!n.button||n.type!=="click"))for(s=n.target;s!=this;s=s.parentNode||this)if(s.disabled!==!0||n.type!=="click"){u={},f=[];for(r=0;r<m;r++)c=d[r],h=c.selector,u[h]===t&&(u[h]=c.needsContext?v(h,this).index(s)>=0:v.find(h,this,null,[s]).length),u[h]&&f.push(c);f.length&&w.push({elem:s,matches:f})}d.length>m&&w.push({elem:this,matches:d.slice(m)});for(r=0;r<w.length&&!n.isPropagationStopped();r++){a=w[r],n.currentTarget=a.elem;for(i=0;i<a.matches.length&&!n.isImmediatePropagationStopped();i++){c=a.matches[i];if(y||!n.namespace&&!c.namespace||n.namespace_re&&n.namespace_re.test(c.namespace))n.data=c.data,n.handleObj=c,o=((v.event.special[c.origType]||{}).handle||c.handler).apply(a.elem,g),o!==t&&(n.result=o,o===!1&&(n.preventDefault(),n.stopPropagation()))}}return b.postDispatch&&b.postDispatch.call(this,n),n.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return e.which==null&&(e.which=t.charCode!=null?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,s,o,u=n.button,a=n.fromElement;return e.pageX==null&&n.clientX!=null&&(r=e.target.ownerDocument||i,s=r.documentElement,o=r.body,e.pageX=n.clientX+(s&&s.scrollLeft||o&&o.scrollLeft||0)-(s&&s.clientLeft||o&&o.clientLeft||0),e.pageY=n.clientY+(s&&s.scrollTop||o&&o.scrollTop||0)-(s&&s.clientTop||o&&o.clientTop||0)),!e.relatedTarget&&a&&(e.relatedTarget=a===e.target?n.toElement:a),!e.which&&u!==t&&(e.which=u&1?1:u&2?3:u&4?2:0),e}},fix:function(e){if(e[v.expando])return e;var t,n,r=e,s=v.event.fixHooks[e.type]||{},o=s.props?this.props.concat(s.props):this.props;e=v.Event(r);for(t=o.length;t;)n=o[--t],e[n]=r[n];return e.target||(e.target=r.srcElement||i),e.target.nodeType===3&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,r):e},special:{load:{noBubble:!0},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(e,t,n){v.isWindow(this)&&(this.onbeforeunload=n)},teardown:function(e,t){this.onbeforeunload===t&&(this.onbeforeunload=null)}}},simulate:function(e,t,n,r){var i=v.extend(new v.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?v.event.trigger(i,null,t):v.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},v.event.handle=v.event.dispatch,v.removeEvent=i.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]=="undefined"&&(e[r]=null),e.detachEvent(r,n))},v.Event=function(e,t){if(!(this instanceof v.Event))return new v.Event(e,t);e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?tt:et):this.type=e,t&&v.extend(this,t),this.timeStamp=e&&e.timeStamp||v.now(),this[v.expando]=!0},v.Event.prototype={preventDefault:function(){this.isDefaultPrevented=tt;var e=this.originalEvent;if(!e)return;e.preventDefault?e.preventDefault():e.returnValue=!1},stopPropagation:function(){this.isPropagationStopped=tt;var e=this.originalEvent;if(!e)return;e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=tt,this.stopPropagation()},isDefaultPrevented:et,isPropagationStopped:et,isImmediatePropagationStopped:et},v.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){v.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,s=e.handleObj,o=s.selector;if(!i||i!==r&&!v.contains(r,i))e.type=s.origType,n=s.handler.apply(this,arguments),e.type=t;return n}}}),v.support.submitBubbles||(v.event.special.submit={setup:function(){if(v.nodeName(this,"form"))return!1;v.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=v.nodeName(n,"input")||v.nodeName(n,"button")?n.form:t;r&&!v._data(r,"_submit_attached")&&(v.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),v._data(r,"_submit_attached",!0))})},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&v.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){if(v.nodeName(this,"form"))return!1;v.event.remove(this,"._submit")}}),v.support.changeBubbles||(v.event.special.change={setup:function(){if($.test(this.nodeName)){if(this.type==="checkbox"||this.type==="radio")v.event.add(this,"propertychange._change",function(e){e.originalEvent.propertyName==="checked"&&(this._just_changed=!0)}),v.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),v.event.simulate("change",this,e,!0)});return!1}v.event.add(this,"beforeactivate._change",function(e){var t=e.target;$.test(t.nodeName)&&!v._data(t,"_change_attached")&&(v.event.add(t,"change._change",function(e){this.parentNode&&!e.isSimulated&&!e.isTrigger&&v.event.simulate("change",this.parentNode,e,!0)}),v._data(t,"_change_attached",!0))})},handle:function(e){var t=e.target;if(this!==t||e.isSimulated||e.isTrigger||t.type!=="radio"&&t.type!=="checkbox")return e.handleObj.handler.apply(this,arguments)},teardown:function(){return v.event.remove(this,"._change"),!$.test(this.nodeName)}}),v.support.focusinBubbles||v.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){v.event.simulate(t,e.target,v.event.fix(e),!0)};v.event.special[t]={setup:function(){n++===0&&i.addEventListener(e,r,!0)},teardown:function(){--n===0&&i.removeEventListener(e,r,!0)}}}),v.fn.extend({on:function(e,n,r,i,s){var o,u;if(typeof e=="object"){typeof n!="string"&&(r=r||n,n=t);for(u in e)this.on(u,n,r,e[u],s);return this}r==null&&i==null?(i=n,r=n=t):i==null&&(typeof n=="string"?(i=r,r=t):(i=r,r=n,n=t));if(i===!1)i=et;else if(!i)return this;return s===1&&(o=i,i=function(e){return v().off(e),o.apply(this,arguments)},i.guid=o.guid||(o.guid=v.guid++)),this.each(function(){v.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,s;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,v(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if(typeof e=="object"){for(s in e)this.off(s,n,e[s]);return this}if(n===!1||typeof n=="function")r=n,n=t;return r===!1&&(r=et),this.each(function(){v.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},live:function(e,t,n){return v(this.context).on(e,this.selector,t,n),this},die:function(e,t){return v(this.context).off(e,this.selector||"**",t),this},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return arguments.length===1?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){v.event.trigger(e,t,this)})},triggerHandler:function(e,t){if(this[0])return v.event.trigger(e,t,this[0],!0)},toggle:function(e){var t=arguments,n=e.guid||v.guid++,r=0,i=function(n){var i=(v._data(this,"lastToggle"+e.guid)||0)%r;return v._data(this,"lastToggle"+e.guid,i+1),n.preventDefault(),t[i].apply(this,arguments)||!1};i.guid=n;while(r<t.length)t[r++].guid=n;return this.click(i)},hover:function(e,t){return this.mouseenter(e).mouseleave(t||e)}}),v.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){v.fn[t]=function(e,n){return n==null&&(n=e,e=null),arguments.length>0?this.on(t,null,e,n):this.trigger(t)},Q.test(t)&&(v.event.fixHooks[t]=v.event.keyHooks),G.test(t)&&(v.event.fixHooks[t]=v.event.mouseHooks)}),function(e,t){function nt(e,t,n,r){n=n||[],t=t||g;var i,s,a,f,l=t.nodeType;if(!e||typeof e!="string")return n;if(l!==1&&l!==9)return[];a=o(t);if(!a&&!r)if(i=R.exec(e))if(f=i[1]){if(l===9){s=t.getElementById(f);if(!s||!s.parentNode)return n;if(s.id===f)return n.push(s),n}else if(t.ownerDocument&&(s=t.ownerDocument.getElementById(f))&&u(t,s)&&s.id===f)return n.push(s),n}else{if(i[2])return S.apply(n,x.call(t.getElementsByTagName(e),0)),n;if((f=i[3])&&Z&&t.getElementsByClassName)return S.apply(n,x.call(t.getElementsByClassName(f),0)),n}return vt(e.replace(j,"$1"),t,n,r,a)}function rt(e){return function(t){var n=t.nodeName.toLowerCase();return n==="input"&&t.type===e}}function it(e){return function(t){var n=t.nodeName.toLowerCase();return(n==="input"||n==="button")&&t.type===e}}function st(e){return N(function(t){return t=+t,N(function(n,r){var i,s=e([],n.length,t),o=s.length;while(o--)n[i=s[o]]&&(n[i]=!(r[i]=n[i]))})})}function ot(e,t,n){if(e===t)return n;var r=e.nextSibling;while(r){if(r===t)return-1;r=r.nextSibling}return 1}function ut(e,t){var n,r,s,o,u,a,f,l=L[d][e+" "];if(l)return t?0:l.slice(0);u=e,a=[],f=i.preFilter;while(u){if(!n||(r=F.exec(u)))r&&(u=u.slice(r[0].length)||u),a.push(s=[]);n=!1;if(r=I.exec(u))s.push(n=new m(r.shift())),u=u.slice(n.length),n.type=r[0].replace(j," ");for(o in i.filter)(r=J[o].exec(u))&&(!f[o]||(r=f[o](r)))&&(s.push(n=new m(r.shift())),u=u.slice(n.length),n.type=o,n.matches=r);if(!n)break}return t?u.length:u?nt.error(e):L(e,a).slice(0)}function at(e,t,r){var i=t.dir,s=r&&t.dir==="parentNode",o=w++;return t.first?function(t,n,r){while(t=t[i])if(s||t.nodeType===1)return e(t,n,r)}:function(t,r,u){if(!u){var a,f=b+" "+o+" ",l=f+n;while(t=t[i])if(s||t.nodeType===1){if((a=t[d])===l)return t.sizset;if(typeof a=="string"&&a.indexOf(f)===0){if(t.sizset)return t}else{t[d]=l;if(e(t,r,u))return t.sizset=!0,t;t.sizset=!1}}}else while(t=t[i])if(s||t.nodeType===1)if(e(t,r,u))return t}}function ft(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function lt(e,t,n,r,i){var s,o=[],u=0,a=e.length,f=t!=null;for(;u<a;u++)if(s=e[u])if(!n||n(s,r,i))o.push(s),f&&t.push(u);return o}function ct(e,t,n,r,i,s){return r&&!r[d]&&(r=ct(r)),i&&!i[d]&&(i=ct(i,s)),N(function(s,o,u,a){var f,l,c,h=[],p=[],d=o.length,v=s||dt(t||"*",u.nodeType?[u]:u,[]),m=e&&(s||!t)?lt(v,h,e,u,a):v,g=n?i||(s?e:d||r)?[]:o:m;n&&n(m,g,u,a);if(r){f=lt(g,p),r(f,[],u,a),l=f.length;while(l--)if(c=f[l])g[p[l]]=!(m[p[l]]=c)}if(s){if(i||e){if(i){f=[],l=g.length;while(l--)(c=g[l])&&f.push(m[l]=c);i(null,g=[],f,a)}l=g.length;while(l--)(c=g[l])&&(f=i?T.call(s,c):h[l])>-1&&(s[f]=!(o[f]=c))}}else g=lt(g===o?g.splice(d,g.length):g),i?i(null,o,g,a):S.apply(o,g)})}function ht(e){var t,n,r,s=e.length,o=i.relative[e[0].type],u=o||i.relative[" "],a=o?1:0,f=at(function(e){return e===t},u,!0),l=at(function(e){return T.call(t,e)>-1},u,!0),h=[function(e,n,r){return!o&&(r||n!==c)||((t=n).nodeType?f(e,n,r):l(e,n,r))}];for(;a<s;a++)if(n=i.relative[e[a].type])h=[at(ft(h),n)];else{n=i.filter[e[a].type].apply(null,e[a].matches);if(n[d]){r=++a;for(;r<s;r++)if(i.relative[e[r].type])break;return ct(a>1&&ft(h),a>1&&e.slice(0,a-1).join("").replace(j,"$1"),n,a<r&&ht(e.slice(a,r)),r<s&&ht(e=e.slice(r)),r<s&&e.join(""))}h.push(n)}return ft(h)}function pt(e,t){var r=t.length>0,s=e.length>0,o=function(u,a,f,l,h){var p,d,v,m=[],y=0,w="0",x=u&&[],T=h!=null,N=c,C=u||s&&i.find.TAG("*",h&&a.parentNode||a),k=b+=N==null?1:Math.E;T&&(c=a!==g&&a,n=o.el);for(;(p=C[w])!=null;w++){if(s&&p){for(d=0;v=e[d];d++)if(v(p,a,f)){l.push(p);break}T&&(b=k,n=++o.el)}r&&((p=!v&&p)&&y--,u&&x.push(p))}y+=w;if(r&&w!==y){for(d=0;v=t[d];d++)v(x,m,a,f);if(u){if(y>0)while(w--)!x[w]&&!m[w]&&(m[w]=E.call(l));m=lt(m)}S.apply(l,m),T&&!u&&m.length>0&&y+t.length>1&&nt.uniqueSort(l)}return T&&(b=k,c=N),x};return o.el=0,r?N(o):o}function dt(e,t,n){var r=0,i=t.length;for(;r<i;r++)nt(e,t[r],n);return n}function vt(e,t,n,r,s){var o,u,f,l,c,h=ut(e),p=h.length;if(!r&&h.length===1){u=h[0]=h[0].slice(0);if(u.length>2&&(f=u[0]).type==="ID"&&t.nodeType===9&&!s&&i.relative[u[1].type]){t=i.find.ID(f.matches[0].replace($,""),t,s)[0];if(!t)return n;e=e.slice(u.shift().length)}for(o=J.POS.test(e)?-1:u.length-1;o>=0;o--){f=u[o];if(i.relative[l=f.type])break;if(c=i.find[l])if(r=c(f.matches[0].replace($,""),z.test(u[0].type)&&t.parentNode||t,s)){u.splice(o,1),e=r.length&&u.join("");if(!e)return S.apply(n,x.call(r,0)),n;break}}}return a(e,h)(r,t,s,n,z.test(e)),n}function mt(){}var n,r,i,s,o,u,a,f,l,c,h=!0,p="undefined",d=("sizcache"+Math.random()).replace(".",""),m=String,g=e.document,y=g.documentElement,b=0,w=0,E=[].pop,S=[].push,x=[].slice,T=[].indexOf||function(e){var t=0,n=this.length;for(;t<n;t++)if(this[t]===e)return t;return-1},N=function(e,t){return e[d]=t==null||t,e},C=function(){var e={},t=[];return N(function(n,r){return t.push(n)>i.cacheLength&&delete e[t.shift()],e[n+" "]=r},e)},k=C(),L=C(),A=C(),O="[\\x20\\t\\r\\n\\f]",M="(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",_=M.replace("w","w#"),D="([*^$|!~]?=)",P="\\["+O+"*("+M+")"+O+"*(?:"+D+O+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+_+")|)|)"+O+"*\\]",H=":("+M+")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:"+P+")|[^:]|\\\\.)*|.*))\\)|)",B=":(even|odd|eq|gt|lt|nth|first|last)(?:\\("+O+"*((?:-\\d)?\\d*)"+O+"*\\)|)(?=[^-]|$)",j=new RegExp("^"+O+"+|((?:^|[^\\\\])(?:\\\\.)*)"+O+"+$","g"),F=new RegExp("^"+O+"*,"+O+"*"),I=new RegExp("^"+O+"*([\\x20\\t\\r\\n\\f>+~])"+O+"*"),q=new RegExp(H),R=/^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,U=/^:not/,z=/[\x20\t\r\n\f]*[+~]/,W=/:not\($/,X=/h\d/i,V=/input|select|textarea|button/i,$=/\\(?!\\)/g,J={ID:new RegExp("^#("+M+")"),CLASS:new RegExp("^\\.("+M+")"),NAME:new RegExp("^\\[name=['\"]?("+M+")['\"]?\\]"),TAG:new RegExp("^("+M.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+H),POS:new RegExp(B,"i"),CHILD:new RegExp("^:(only|nth|first|last)-child(?:\\("+O+"*(even|odd|(([+-]|)(\\d*)n|)"+O+"*(?:([+-]|)"+O+"*(\\d+)|))"+O+"*\\)|)","i"),needsContext:new RegExp("^"+O+"*[>+~]|"+B,"i")},K=function(e){var t=g.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}},Q=K(function(e){return e.appendChild(g.createComment("")),!e.getElementsByTagName("*").length}),G=K(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==p&&e.firstChild.getAttribute("href")==="#"}),Y=K(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return t!=="boolean"&&t!=="string"}),Z=K(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",!e.getElementsByClassName||!e.getElementsByClassName("e").length?!1:(e.lastChild.className="e",e.getElementsByClassName("e").length===2)}),et=K(function(e){e.id=d+0,e.innerHTML="<a name='"+d+"'></a><div name='"+d+"'></div>",y.insertBefore(e,y.firstChild);var t=g.getElementsByName&&g.getElementsByName(d).length===2+g.getElementsByName(d+0).length;return r=!g.getElementById(d),y.removeChild(e),t});try{x.call(y.childNodes,0)[0].nodeType}catch(tt){x=function(e){var t,n=[];for(;t=this[e];e++)n.push(t);return n}}nt.matches=function(e,t){return nt(e,null,null,t)},nt.matchesSelector=function(e,t){return nt(t,null,null,[e]).length>0},s=nt.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(i===1||i===9||i===11){if(typeof e.textContent=="string")return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=s(e)}else if(i===3||i===4)return e.nodeValue}else for(;t=e[r];r++)n+=s(t);return n},o=nt.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?t.nodeName!=="HTML":!1},u=nt.contains=y.contains?function(e,t){var n=e.nodeType===9?e.documentElement:e,r=t&&t.parentNode;return e===r||!!(r&&r.nodeType===1&&n.contains&&n.contains(r))}:y.compareDocumentPosition?function(e,t){return t&&!!(e.compareDocumentPosition(t)&16)}:function(e,t){while(t=t.parentNode)if(t===e)return!0;return!1},nt.attr=function(e,t){var n,r=o(e);return r||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):r||Y?e.getAttribute(t):(n=e.getAttributeNode(t),n?typeof e[t]=="boolean"?e[t]?t:null:n.specified?n.value:null:null)},i=nt.selectors={cacheLength:50,createPseudo:N,match:J,attrHandle:G?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},find:{ID:r?function(e,t,n){if(typeof t.getElementById!==p&&!n){var r=t.getElementById(e);return r&&r.parentNode?[r]:[]}}:function(e,n,r){if(typeof n.getElementById!==p&&!r){var i=n.getElementById(e);return i?i.id===e||typeof i.getAttributeNode!==p&&i.getAttributeNode("id").value===e?[i]:t:[]}},TAG:Q?function(e,t){if(typeof t.getElementsByTagName!==p)return t.getElementsByTagName(e)}:function(e,t){var n=t.getElementsByTagName(e);if(e==="*"){var r,i=[],s=0;for(;r=n[s];s++)r.nodeType===1&&i.push(r);return i}return n},NAME:et&&function(e,t){if(typeof t.getElementsByName!==p)return t.getElementsByName(name)},CLASS:Z&&function(e,t,n){if(typeof t.getElementsByClassName!==p&&!n)return t.getElementsByClassName(e)}},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace($,""),e[3]=(e[4]||e[5]||"").replace($,""),e[2]==="~="&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),e[1]==="nth"?(e[2]||nt.error(e[0]),e[3]=+(e[3]?e[4]+(e[5]||1):2*(e[2]==="even"||e[2]==="odd")),e[4]=+(e[6]+e[7]||e[2]==="odd")):e[2]&&nt.error(e[0]),e},PSEUDO:function(e){var t,n;if(J.CHILD.test(e[0]))return null;if(e[3])e[2]=e[3];else if(t=e[4])q.test(t)&&(n=ut(t,!0))&&(n=t.indexOf(")",t.length-n)-t.length)&&(t=t.slice(0,n),e[0]=e[0].slice(0,n)),e[2]=t;return e.slice(0,3)}},filter:{ID:r?function(e){return e=e.replace($,""),function(t){return t.getAttribute("id")===e}}:function(e){return e=e.replace($,""),function(t){var n=typeof t.getAttributeNode!==p&&t.getAttributeNode("id");return n&&n.value===e}},TAG:function(e){return e==="*"?function(){return!0}:(e=e.replace($,"").toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[d][e+" "];return t||(t=new RegExp("(^|"+O+")"+e+"("+O+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==p&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r,i){var s=nt.attr(r,e);return s==null?t==="!=":t?(s+="",t==="="?s===n:t==="!="?s!==n:t==="^="?n&&s.indexOf(n)===0:t==="*="?n&&s.indexOf(n)>-1:t==="$="?n&&s.substr(s.length-n.length)===n:t==="~="?(" "+s+" ").indexOf(n)>-1:t==="|="?s===n||s.substr(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r){return e==="nth"?function(e){var t,i,s=e.parentNode;if(n===1&&r===0)return!0;if(s){i=0;for(t=s.firstChild;t;t=t.nextSibling)if(t.nodeType===1){i++;if(e===t)break}}return i-=r,i===n||i%n===0&&i/n>=0}:function(t){var n=t;switch(e){case"only":case"first":while(n=n.previousSibling)if(n.nodeType===1)return!1;if(e==="first")return!0;n=t;case"last":while(n=n.nextSibling)if(n.nodeType===1)return!1;return!0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||nt.error("unsupported pseudo: "+e);return r[d]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?N(function(e,n){var i,s=r(e,t),o=s.length;while(o--)i=T.call(e,s[o]),e[i]=!(n[i]=s[o])}):function(e){return r(e,0,n)}):r}},pseudos:{not:N(function(e){var t=[],n=[],r=a(e.replace(j,"$1"));return r[d]?N(function(e,t,n,i){var s,o=r(e,null,i,[]),u=e.length;while(u--)if(s=o[u])e[u]=!(t[u]=s)}):function(e,i,s){return t[0]=e,r(t,null,s,n),!n.pop()}}),has:N(function(e){return function(t){return nt(e,t).length>0}}),contains:N(function(e){return function(t){return(t.textContent||t.innerText||s(t)).indexOf(e)>-1}}),enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&!!e.checked||t==="option"&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},parent:function(e){return!i.pseudos.empty(e)},empty:function(e){var t;e=e.firstChild;while(e){if(e.nodeName>"@"||(t=e.nodeType)===3||t===4)return!1;e=e.nextSibling}return!0},header:function(e){return X.test(e.nodeName)},text:function(e){var t,n;return e.nodeName.toLowerCase()==="input"&&(t=e.type)==="text"&&((n=e.getAttribute("type"))==null||n.toLowerCase()===t)},radio:rt("radio"),checkbox:rt("checkbox"),file:rt("file"),password:rt("password"),image:rt("image"),submit:it("submit"),reset:it("reset"),button:function(e){var t=e.nodeName.toLowerCase();return t==="input"&&e.type==="button"||t==="button"},input:function(e){return V.test(e.nodeName)},focus:function(e){var t=e.ownerDocument;return e===t.activeElement&&(!t.hasFocus||t.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},active:function(e){return e===e.ownerDocument.activeElement},first:st(function(){return[0]}),last:st(function(e,t){return[t-1]}),eq:st(function(e,t,n){return[n<0?n+t:n]}),even:st(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:st(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:st(function(e,t,n){for(var r=n<0?n+t:n;--r>=0;)e.push(r);return e}),gt:st(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}},f=y.compareDocumentPosition?function(e,t){return e===t?(l=!0,0):(!e.compareDocumentPosition||!t.compareDocumentPosition?e.compareDocumentPosition:e.compareDocumentPosition(t)&4)?-1:1}:function(e,t){if(e===t)return l=!0,0;if(e.sourceIndex&&t.sourceIndex)return e.sourceIndex-t.sourceIndex;var n,r,i=[],s=[],o=e.parentNode,u=t.parentNode,a=o;if(o===u)return ot(e,t);if(!o)return-1;if(!u)return 1;while(a)i.unshift(a),a=a.parentNode;a=u;while(a)s.unshift(a),a=a.parentNode;n=i.length,r=s.length;for(var f=0;f<n&&f<r;f++)if(i[f]!==s[f])return ot(i[f],s[f]);return f===n?ot(e,s[f],-1):ot(i[f],t,1)},[0,0].sort(f),h=!l,nt.uniqueSort=function(e){var t,n=[],r=1,i=0;l=h,e.sort(f);if(l){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e},nt.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},a=nt.compile=function(e,t){var n,r=[],i=[],s=A[d][e+" "];if(!s){t||(t=ut(e)),n=t.length;while(n--)s=ht(t[n]),s[d]?r.push(s):i.push(s);s=A(e,pt(i,r))}return s},g.querySelectorAll&&function(){var e,t=vt,n=/'|\\/g,r=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,i=[":focus"],s=[":active"],u=y.matchesSelector||y.mozMatchesSelector||y.webkitMatchesSelector||y.oMatchesSelector||y.msMatchesSelector;K(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||i.push("\\["+O+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||i.push(":checked")}),K(function(e){e.innerHTML="<p test=''></p>",e.querySelectorAll("[test^='']").length&&i.push("[*^$]="+O+"*(?:\"\"|'')"),e.innerHTML="<input type='hidden'/>",e.querySelectorAll(":enabled").length||i.push(":enabled",":disabled")}),i=new RegExp(i.join("|")),vt=function(e,r,s,o,u){if(!o&&!u&&!i.test(e)){var a,f,l=!0,c=d,h=r,p=r.nodeType===9&&e;if(r.nodeType===1&&r.nodeName.toLowerCase()!=="object"){a=ut(e),(l=r.getAttribute("id"))?c=l.replace(n,"\\$&"):r.setAttribute("id",c),c="[id='"+c+"'] ",f=a.length;while(f--)a[f]=c+a[f].join("");h=z.test(e)&&r.parentNode||r,p=a.join(",")}if(p)try{return S.apply(s,x.call(h.querySelectorAll(p),0)),s}catch(v){}finally{l||r.removeAttribute("id")}}return t(e,r,s,o,u)},u&&(K(function(t){e=u.call(t,"div");try{u.call(t,"[test!='']:sizzle"),s.push("!=",H)}catch(n){}}),s=new RegExp(s.join("|")),nt.matchesSelector=function(t,n){n=n.replace(r,"='$1']");if(!o(t)&&!s.test(n)&&!i.test(n))try{var a=u.call(t,n);if(a||e||t.document&&t.document.nodeType!==11)return a}catch(f){}return nt(n,null,null,[t]).length>0})}(),i.pseudos.nth=i.pseudos.eq,i.filters=mt.prototype=i.pseudos,i.setFilters=new mt,nt.attr=v.attr,v.find=nt,v.expr=nt.selectors,v.expr[":"]=v.expr.pseudos,v.unique=nt.uniqueSort,v.text=nt.getText,v.isXMLDoc=nt.isXML,v.contains=nt.contains}(e);var nt=/Until$/,rt=/^(?:parents|prev(?:Until|All))/,it=/^.[^:#\[\.,]*$/,st=v.expr.match.needsContext,ot={children:!0,contents:!0,next:!0,prev:!0};v.fn.extend({find:function(e){var t,n,r,i,s,o,u=this;if(typeof e!="string")return v(e).filter(function(){for(t=0,n=u.length;t<n;t++)if(v.contains(u[t],this))return!0});o=this.pushStack("","find",e);for(t=0,n=this.length;t<n;t++){r=o.length,v.find(e,this[t],o);if(t>0)for(i=r;i<o.length;i++)for(s=0;s<r;s++)if(o[s]===o[i]){o.splice(i--,1);break}}return o},has:function(e){var t,n=v(e,this),r=n.length;return this.filter(function(){for(t=0;t<r;t++)if(v.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1),"not",e)},filter:function(e){return this.pushStack(ft(this,e,!0),"filter",e)},is:function(e){return!!e&&(typeof e=="string"?st.test(e)?v(e,this.context).index(this[0])>=0:v.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,s=[],o=st.test(e)||typeof e!="string"?v(e,t||this.context):0;for(;r<i;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&n.nodeType!==11){if(o?o.index(n)>-1:v.find.matchesSelector(n,e)){s.push(n);break}n=n.parentNode}}return s=s.length>1?v.unique(s):s,this.pushStack(s,"closest",e)},index:function(e){return e?typeof e=="string"?v.inArray(this[0],v(e)):v.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.prevAll().length:-1},add:function(e,t){var n=typeof e=="string"?v(e,t):v.makeArray(e&&e.nodeType?[e]:e),r=v.merge(this.get(),n);return this.pushStack(ut(n[0])||ut(r[0])?r:v.unique(r))},addBack:function(e){return this.add(e==null?this.prevObject:this.prevObject.filter(e))}}),v.fn.andSelf=v.fn.addBack,v.each({parent:function(e){var t=e.parentNode;return t&&t.nodeType!==11?t:null},parents:function(e){return v.dir(e,"parentNode")},parentsUntil:function(e,t,n){return v.dir(e,"parentNode",n)},next:function(e){return at(e,"nextSibling")},prev:function(e){return at(e,"previousSibling")},nextAll:function(e){return v.dir(e,"nextSibling")},prevAll:function(e){return v.dir(e,"previousSibling")},nextUntil:function(e,t,n){return v.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return v.dir(e,"previousSibling",n)},siblings:function(e){return v.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return v.sibling(e.firstChild)},contents:function(e){return v.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:v.merge([],e.childNodes)}},function(e,t){v.fn[e]=function(n,r){var i=v.map(this,t,n);return nt.test(e)||(r=n),r&&typeof r=="string"&&(i=v.filter(r,i)),i=this.length>1&&!ot[e]?v.unique(i):i,this.length>1&&rt.test(e)&&(i=i.reverse()),this.pushStack(i,e,l.call(arguments).join(","))}}),v.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),t.length===1?v.find.matchesSelector(t[0],e)?[t[0]]:[]:v.find.matches(e,t)},dir:function(e,n,r){var i=[],s=e[n];while(s&&s.nodeType!==9&&(r===t||s.nodeType!==1||!v(s).is(r)))s.nodeType===1&&i.push(s),s=s[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)e.nodeType===1&&e!==t&&n.push(e);return n}});var ct="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",ht=/ jQuery\d+="(?:null|\d+)"/g,pt=/^\s+/,dt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,vt=/<([\w:]+)/,mt=/<tbody/i,gt=/<|&#?\w+;/,yt=/<(?:script|style|link)/i,bt=/<(?:script|object|embed|option|style)/i,wt=new RegExp("<(?:"+ct+")[\\s/>]","i"),Et=/^(?:checkbox|radio)$/,St=/checked\s*(?:[^=]|=\s*.checked.)/i,xt=/\/(java|ecma)script/i,Tt=/^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,Nt={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},Ct=lt(i),kt=Ct.appendChild(i.createElement("div"));Nt.optgroup=Nt.option,Nt.tbody=Nt.tfoot=Nt.colgroup=Nt.caption=Nt.thead,Nt.th=Nt.td,v.support.htmlSerialize||(Nt._default=[1,"X<div>","</div>"]),v.fn.extend({text:function(e){return v.access(this,function(e){return e===t?v.text(this):this.empty().append((this[0]&&this[0].ownerDocument||i).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(v.isFunction(e))return this.each(function(t){v(this).wrapAll(e.call(this,t))});if(this[0]){var t=v(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&e.firstChild.nodeType===1)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return v.isFunction(e)?this.each(function(t){v(this).wrapInner(e.call(this,t))}):this.each(function(){var t=v(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=v.isFunction(e);return this.each(function(n){v(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){v.nodeName(this,"body")||v(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(this.nodeType===1||this.nodeType===11)&&this.insertBefore(e,this.firstChild)})},before:function(){if(!ut(this[0]))return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this)});if(arguments.length){var e=v.clean(arguments);return this.pushStack(v.merge(e,this),"before",this.selector)}},after:function(){if(!ut(this[0]))return this.domManip(arguments,!1,function(e){this.parentNode.insertBefore(e,this.nextSibling)});if(arguments.length){var e=v.clean(arguments);return this.pushStack(v.merge(this,e),"after",this.selector)}},remove:function(e,t){var n,r=0;for(;(n=this[r])!=null;r++)if(!e||v.filter(e,[n]).length)!t&&n.nodeType===1&&(v.cleanData(n.getElementsByTagName("*")),v.cleanData([n])),n.parentNode&&n.parentNode.removeChild(n);return this},empty:function(){var e,t=0;for(;(e=this[t])!=null;t++){e.nodeType===1&&v.cleanData(e.getElementsByTagName("*"));while(e.firstChild)e.removeChild(e.firstChild)}return this},clone:function(e,t){return e=e==null?!1:e,t=t==null?e:t,this.map(function(){return v.clone(this,e,t)})},html:function(e){return v.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return n.nodeType===1?n.innerHTML.replace(ht,""):t;if(typeof e=="string"&&!yt.test(e)&&(v.support.htmlSerialize||!wt.test(e))&&(v.support.leadingWhitespace||!pt.test(e))&&!Nt[(vt.exec(e)||["",""])[1].toLowerCase()]){e=e.replace(dt,"<$1></$2>");try{for(;r<i;r++)n=this[r]||{},n.nodeType===1&&(v.cleanData(n.getElementsByTagName("*")),n.innerHTML=e);n=0}catch(s){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){return ut(this[0])?this.length?this.pushStack(v(v.isFunction(e)?e():e),"replaceWith",e):this:v.isFunction(e)?this.each(function(t){var n=v(this),r=n.html();n.replaceWith(e.call(this,t,r))}):(typeof e!="string"&&(e=v(e).detach()),this.each(function(){var t=this.nextSibling,n=this.parentNode;v(this).remove(),t?v(t).before(e):v(n).append(e)}))},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=[].concat.apply([],e);var i,s,o,u,a=0,f=e[0],l=[],c=this.length;if(!v.support.checkClone&&c>1&&typeof f=="string"&&St.test(f))return this.each(function(){v(this).domManip(e,n,r)});if(v.isFunction(f))return this.each(function(i){var s=v(this);e[0]=f.call(this,i,n?s.html():t),s.domManip(e,n,r)});if(this[0]){i=v.buildFragment(e,this,l),o=i.fragment,s=o.firstChild,o.childNodes.length===1&&(o=s);if(s){n=n&&v.nodeName(s,"tr");for(u=i.cacheable||c-1;a<c;a++)r.call(n&&v.nodeName(this[a],"table")?Lt(this[a],"tbody"):this[a],a===u?o:v.clone(o,!0,!0))}o=s=null,l.length&&v.each(l,function(e,t){t.src?v.ajax?v.ajax({url:t.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):v.error("no ajax"):v.globalEval((t.text||t.textContent||t.innerHTML||"").replace(Tt,"")),t.parentNode&&t.parentNode.removeChild(t)})}return this}}),v.buildFragment=function(e,n,r){var s,o,u,a=e[0];return n=n||i,n=!n.nodeType&&n[0]||n,n=n.ownerDocument||n,e.length===1&&typeof a=="string"&&a.length<512&&n===i&&a.charAt(0)==="<"&&!bt.test(a)&&(v.support.checkClone||!St.test(a))&&(v.support.html5Clone||!wt.test(a))&&(o=!0,s=v.fragments[a],u=s!==t),s||(s=n.createDocumentFragment(),v.clean(e,n,s,r),o&&(v.fragments[a]=u&&s)),{fragment:s,cacheable:o}},v.fragments={},v.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){v.fn[e]=function(n){var r,i=0,s=[],o=v(n),u=o.length,a=this.length===1&&this[0].parentNode;if((a==null||a&&a.nodeType===11&&a.childNodes.length===1)&&u===1)return o[t](this[0]),this;for(;i<u;i++)r=(i>0?this.clone(!0):this).get(),v(o[i])[t](r),s=s.concat(r);return this.pushStack(s,e,o.selector)}}),v.extend({clone:function(e,t,n){var r,i,s,o;v.support.html5Clone||v.isXMLDoc(e)||!wt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(kt.innerHTML=e.outerHTML,kt.removeChild(o=kt.firstChild));if((!v.support.noCloneEvent||!v.support.noCloneChecked)&&(e.nodeType===1||e.nodeType===11)&&!v.isXMLDoc(e)){Ot(e,o),r=Mt(e),i=Mt(o);for(s=0;r[s];++s)i[s]&&Ot(r[s],i[s])}if(t){At(e,o);if(n){r=Mt(e),i=Mt(o);for(s=0;r[s];++s)At(r[s],i[s])}}return r=i=null,o},clean:function(e,t,n,r){var s,o,u,a,f,l,c,h,p,d,m,g,y=t===i&&Ct,b=[];if(!t||typeof t.createDocumentFragment=="undefined")t=i;for(s=0;(u=e[s])!=null;s++){typeof u=="number"&&(u+="");if(!u)continue;if(typeof u=="string")if(!gt.test(u))u=t.createTextNode(u);else{y=y||lt(t),c=t.createElement("div"),y.appendChild(c),u=u.replace(dt,"<$1></$2>"),a=(vt.exec(u)||["",""])[1].toLowerCase(),f=Nt[a]||Nt._default,l=f[0],c.innerHTML=f[1]+u+f[2];while(l--)c=c.lastChild;if(!v.support.tbody){h=mt.test(u),p=a==="table"&&!h?c.firstChild&&c.firstChild.childNodes:f[1]==="<table>"&&!h?c.childNodes:[];for(o=p.length-1;o>=0;--o)v.nodeName(p[o],"tbody")&&!p[o].childNodes.length&&p[o].parentNode.removeChild(p[o])}!v.support.leadingWhitespace&&pt.test(u)&&c.insertBefore(t.createTextNode(pt.exec(u)[0]),c.firstChild),u=c.childNodes,c.parentNode.removeChild(c)}u.nodeType?b.push(u):v.merge(b,u)}c&&(u=c=y=null);if(!v.support.appendChecked)for(s=0;(u=b[s])!=null;s++)v.nodeName(u,"input")?_t(u):typeof u.getElementsByTagName!="undefined"&&v.grep(u.getElementsByTagName("input"),_t);if(n){m=function(e){if(!e.type||xt.test(e.type))return r?r.push(e.parentNode?e.parentNode.removeChild(e):e):n.appendChild(e)};for(s=0;(u=b[s])!=null;s++)if(!v.nodeName(u,"script")||!m(u))n.appendChild(u),typeof u.getElementsByTagName!="undefined"&&(g=v.grep(v.merge([],u.getElementsByTagName("script")),m),b.splice.apply(b,[s+1,0].concat(g)),s+=g.length)}return b},cleanData:function(e,t){var n,r,i,s,o=0,u=v.expando,a=v.cache,f=v.support.deleteExpando,l=v.event.special;for(;(i=e[o])!=null;o++)if(t||v.acceptData(i)){r=i[u],n=r&&a[r];if(n){if(n.events)for(s in n.events)l[s]?v.event.remove(i,s):v.removeEvent(i,s,n.handle);a[r]&&(delete a[r],f?delete i[u]:i.removeAttribute?i.removeAttribute(u):i[u]=null,v.deletedIds.push(r))}}}}),function(){var e,t;v.uaMatch=function(e){e=e.toLowerCase();var t=/(chrome)[ \/]([\w.]+)/.exec(e)||/(webkit)[ \/]([\w.]+)/.exec(e)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(e)||/(msie) ([\w.]+)/.exec(e)||e.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(e)||[];return{browser:t[1]||"",version:t[2]||"0"}},e=v.uaMatch(o.userAgent),t={},e.browser&&(t[e.browser]=!0,t.version=e.version),t.chrome?t.webkit=!0:t.webkit&&(t.safari=!0),v.browser=t,v.sub=function(){function e(t,n){return new e.fn.init(t,n)}v.extend(!0,e,this),e.superclass=this,e.fn=e.prototype=this(),e.fn.constructor=e,e.sub=this.sub,e.fn.init=function(r,i){return i&&i instanceof v&&!(i instanceof e)&&(i=e(i)),v.fn.init.call(this,r,i,t)},e.fn.init.prototype=e.fn;var t=e(i);return e}}();var Dt,Pt,Ht,Bt=/alpha\([^)]*\)/i,jt=/opacity=([^)]*)/,Ft=/^(top|right|bottom|left)$/,It=/^(none|table(?!-c[ea]).+)/,qt=/^margin/,Rt=new RegExp("^("+m+")(.*)$","i"),Ut=new RegExp("^("+m+")(?!px)[a-z%]+$","i"),zt=new RegExp("^([-+])=("+m+")","i"),Wt={BODY:"block"},Xt={position:"absolute",visibility:"hidden",display:"block"},Vt={letterSpacing:0,fontWeight:400},$t=["Top","Right","Bottom","Left"],Jt=["Webkit","O","Moz","ms"],Kt=v.fn.toggle;v.fn.extend({css:function(e,n){return v.access(this,function(e,n,r){return r!==t?v.style(e,n,r):v.css(e,n)},e,n,arguments.length>1)},show:function(){return Yt(this,!0)},hide:function(){return Yt(this)},toggle:function(e,t){var n=typeof e=="boolean";return v.isFunction(e)&&v.isFunction(t)?Kt.apply(this,arguments):this.each(function(){(n?e:Gt(this))?v(this).show():v(this).hide()})}}),v.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Dt(e,"opacity");return n===""?"1":n}}}},cssNumber:{fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":v.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(!e||e.nodeType===3||e.nodeType===8||!e.style)return;var s,o,u,a=v.camelCase(n),f=e.style;n=v.cssProps[a]||(v.cssProps[a]=Qt(f,a)),u=v.cssHooks[n]||v.cssHooks[a];if(r===t)return u&&"get"in u&&(s=u.get(e,!1,i))!==t?s:f[n];o=typeof r,o==="string"&&(s=zt.exec(r))&&(r=(s[1]+1)*s[2]+parseFloat(v.css(e,n)),o="number");if(r==null||o==="number"&&isNaN(r))return;o==="number"&&!v.cssNumber[a]&&(r+="px");if(!u||!("set"in u)||(r=u.set(e,r,i))!==t)try{f[n]=r}catch(l){}},css:function(e,n,r,i){var s,o,u,a=v.camelCase(n);return n=v.cssProps[a]||(v.cssProps[a]=Qt(e.style,a)),u=v.cssHooks[n]||v.cssHooks[a],u&&"get"in u&&(s=u.get(e,!0,i)),s===t&&(s=Dt(e,n)),s==="normal"&&n in Vt&&(s=Vt[n]),r||i!==t?(o=parseFloat(s),r||v.isNumeric(o)?o||0:s):s},swap:function(e,t,n){var r,i,s={};for(i in t)s[i]=e.style[i],e.style[i]=t[i];r=n.call(e);for(i in t)e.style[i]=s[i];return r}}),e.getComputedStyle?Dt=function(t,n){var r,i,s,o,u=e.getComputedStyle(t,null),a=t.style;return u&&(r=u.getPropertyValue(n)||u[n],r===""&&!v.contains(t.ownerDocument,t)&&(r=v.style(t,n)),Ut.test(r)&&qt.test(n)&&(i=a.width,s=a.minWidth,o=a.maxWidth,a.minWidth=a.maxWidth=a.width=r,r=u.width,a.width=i,a.minWidth=s,a.maxWidth=o)),r}:i.documentElement.currentStyle&&(Dt=function(e,t){var n,r,i=e.currentStyle&&e.currentStyle[t],s=e.style;return i==null&&s&&s[t]&&(i=s[t]),Ut.test(i)&&!Ft.test(t)&&(n=s.left,r=e.runtimeStyle&&e.runtimeStyle.left,r&&(e.runtimeStyle.left=e.currentStyle.left),s.left=t==="fontSize"?"1em":i,i=s.pixelLeft+"px",s.left=n,r&&(e.runtimeStyle.left=r)),i===""?"auto":i}),v.each(["height","width"],function(e,t){v.cssHooks[t]={get:function(e,n,r){if(n)return e.offsetWidth===0&&It.test(Dt(e,"display"))?v.swap(e,Xt,function(){return tn(e,t,r)}):tn(e,t,r)},set:function(e,n,r){return Zt(e,n,r?en(e,t,r,v.support.boxSizing&&v.css(e,"boxSizing")==="border-box"):0)}}}),v.support.opacity||(v.cssHooks.opacity={get:function(e,t){return jt.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=v.isNumeric(t)?"alpha(opacity="+t*100+")":"",s=r&&r.filter||n.filter||"";n.zoom=1;if(t>=1&&v.trim(s.replace(Bt,""))===""&&n.removeAttribute){n.removeAttribute("filter");if(r&&!r.filter)return}n.filter=Bt.test(s)?s.replace(Bt,i):s+" "+i}}),v(function(){v.support.reliableMarginRight||(v.cssHooks.marginRight={get:function(e,t){return v.swap(e,{display:"inline-block"},function(){if(t)return Dt(e,"marginRight")})}}),!v.support.pixelPosition&&v.fn.position&&v.each(["top","left"],function(e,t){v.cssHooks[t]={get:function(e,n){if(n){var r=Dt(e,t);return Ut.test(r)?v(e).position()[t]+"px":r}}}})}),v.expr&&v.expr.filters&&(v.expr.filters.hidden=function(e){return e.offsetWidth===0&&e.offsetHeight===0||!v.support.reliableHiddenOffsets&&(e.style&&e.style.display||Dt(e,"display"))==="none"},v.expr.filters.visible=function(e){return!v.expr.filters.hidden(e)}),v.each({margin:"",padding:"",border:"Width"},function(e,t){v.cssHooks[e+t]={expand:function(n){var r,i=typeof n=="string"?n.split(" "):[n],s={};for(r=0;r<4;r++)s[e+$t[r]+t]=i[r]||i[r-2]||i[0];return s}},qt.test(e)||(v.cssHooks[e+t].set=Zt)});var rn=/%20/g,sn=/\[\]$/,on=/\r?\n/g,un=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,an=/^(?:select|textarea)/i;v.fn.extend({serialize:function(){return v.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?v.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||an.test(this.nodeName)||un.test(this.type))}).map(function(e,t){var n=v(this).val();return n==null?null:v.isArray(n)?v.map(n,function(e,n){return{name:t.name,value:e.replace(on,"\r\n")}}):{name:t.name,value:n.replace(on,"\r\n")}}).get()}}),v.param=function(e,n){var r,i=[],s=function(e,t){t=v.isFunction(t)?t():t==null?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};n===t&&(n=v.ajaxSettings&&v.ajaxSettings.traditional);if(v.isArray(e)||e.jquery&&!v.isPlainObject(e))v.each(e,function(){s(this.name,this.value)});else for(r in e)fn(r,e[r],n,s);return i.join("&").replace(rn,"+")};var ln,cn,hn=/#.*$/,pn=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,dn=/^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,vn=/^(?:GET|HEAD)$/,mn=/^\/\//,gn=/\?/,yn=/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,bn=/([?&])_=[^&]*/,wn=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,En=v.fn.load,Sn={},xn={},Tn=["*/"]+["*"];try{cn=s.href}catch(Nn){cn=i.createElement("a"),cn.href="",cn=cn.href}ln=wn.exec(cn.toLowerCase())||[],v.fn.load=function(e,n,r){if(typeof e!="string"&&En)return En.apply(this,arguments);if(!this.length)return this;var i,s,o,u=this,a=e.indexOf(" ");return a>=0&&(i=e.slice(a,e.length),e=e.slice(0,a)),v.isFunction(n)?(r=n,n=t):n&&typeof n=="object"&&(s="POST"),v.ajax({url:e,type:s,dataType:"html",data:n,complete:function(e,t){r&&u.each(r,o||[e.responseText,t,e])}}).done(function(e){o=arguments,u.html(i?v("<div>").append(e.replace(yn,"")).find(i):e)}),this},v.each("ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split(" "),function(e,t){v.fn[t]=function(e){return this.on(t,e)}}),v.each(["get","post"],function(e,n){v[n]=function(e,r,i,s){return v.isFunction(r)&&(s=s||i,i=r,r=t),v.ajax({type:n,url:e,data:r,success:i,dataType:s})}}),v.extend({getScript:function(e,n){return v.get(e,t,n,"script")},getJSON:function(e,t,n){return v.get(e,t,n,"json")},ajaxSetup:function(e,t){return t?Ln(e,v.ajaxSettings):(t=e,e=v.ajaxSettings),Ln(e,t),e},ajaxSettings:{url:cn,isLocal:dn.test(ln[1]),global:!0,type:"GET",contentType:"application/x-www-form-urlencoded; charset=UTF-8",processData:!0,async:!0,accepts:{xml:"application/xml, text/xml",html:"text/html",text:"text/plain",json:"application/json, text/javascript","*":Tn},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":v.parseJSON,"text xml":v.parseXML},flatOptions:{context:!0,url:!0}},ajaxPrefilter:Cn(Sn),ajaxTransport:Cn(xn),ajax:function(e,n){function T(e,n,s,a){var l,y,b,w,S,T=n;if(E===2)return;E=2,u&&clearTimeout(u),o=t,i=a||"",x.readyState=e>0?4:0,s&&(w=An(c,x,s));if(e>=200&&e<300||e===304)c.ifModified&&(S=x.getResponseHeader("Last-Modified"),S&&(v.lastModified[r]=S),S=x.getResponseHeader("Etag"),S&&(v.etag[r]=S)),e===304?(T="notmodified",l=!0):(l=On(c,w),T=l.state,y=l.data,b=l.error,l=!b);else{b=T;if(!T||e)T="error",e<0&&(e=0)}x.status=e,x.statusText=(n||T)+"",l?d.resolveWith(h,[y,T,x]):d.rejectWith(h,[x,T,b]),x.statusCode(g),g=t,f&&p.trigger("ajax"+(l?"Success":"Error"),[x,c,l?y:b]),m.fireWith(h,[x,T]),f&&(p.trigger("ajaxComplete",[x,c]),--v.active||v.event.trigger("ajaxStop"))}typeof e=="object"&&(n=e,e=t),n=n||{};var r,i,s,o,u,a,f,l,c=v.ajaxSetup({},n),h=c.context||c,p=h!==c&&(h.nodeType||h instanceof v)?v(h):v.event,d=v.Deferred(),m=v.Callbacks("once memory"),g=c.statusCode||{},b={},w={},E=0,S="canceled",x={readyState:0,setRequestHeader:function(e,t){if(!E){var n=e.toLowerCase();e=w[n]=w[n]||e,b[e]=t}return this},getAllResponseHeaders:function(){return E===2?i:null},getResponseHeader:function(e){var n;if(E===2){if(!s){s={};while(n=pn.exec(i))s[n[1].toLowerCase()]=n[2]}n=s[e.toLowerCase()]}return n===t?null:n},overrideMimeType:function(e){return E||(c.mimeType=e),this},abort:function(e){return e=e||S,o&&o.abort(e),T(0,e),this}};d.promise(x),x.success=x.done,x.error=x.fail,x.complete=m.add,x.statusCode=function(e){if(e){var t;if(E<2)for(t in e)g[t]=[g[t],e[t]];else t=e[x.status],x.always(t)}return this},c.url=((e||c.url)+"").replace(hn,"").replace(mn,ln[1]+"//"),c.dataTypes=v.trim(c.dataType||"*").toLowerCase().split(y),c.crossDomain==null&&(a=wn.exec(c.url.toLowerCase()),c.crossDomain=!(!a||a[1]===ln[1]&&a[2]===ln[2]&&(a[3]||(a[1]==="http:"?80:443))==(ln[3]||(ln[1]==="http:"?80:443)))),c.data&&c.processData&&typeof c.data!="string"&&(c.data=v.param(c.data,c.traditional)),kn(Sn,c,n,x);if(E===2)return x;f=c.global,c.type=c.type.toUpperCase(),c.hasContent=!vn.test(c.type),f&&v.active++===0&&v.event.trigger("ajaxStart");if(!c.hasContent){c.data&&(c.url+=(gn.test(c.url)?"&":"?")+c.data,delete c.data),r=c.url;if(c.cache===!1){var N=v.now(),C=c.url.replace(bn,"$1_="+N);c.url=C+(C===c.url?(gn.test(c.url)?"&":"?")+"_="+N:"")}}(c.data&&c.hasContent&&c.contentType!==!1||n.contentType)&&x.setRequestHeader("Content-Type",c.contentType),c.ifModified&&(r=r||c.url,v.lastModified[r]&&x.setRequestHeader("If-Modified-Since",v.lastModified[r]),v.etag[r]&&x.setRequestHeader("If-None-Match",v.etag[r])),x.setRequestHeader("Accept",c.dataTypes[0]&&c.accepts[c.dataTypes[0]]?c.accepts[c.dataTypes[0]]+(c.dataTypes[0]!=="*"?", "+Tn+"; q=0.01":""):c.accepts["*"]);for(l in c.headers)x.setRequestHeader(l,c.headers[l]);if(!c.beforeSend||c.beforeSend.call(h,x,c)!==!1&&E!==2){S="abort";for(l in{success:1,error:1,complete:1})x[l](c[l]);o=kn(xn,c,n,x);if(!o)T(-1,"No Transport");else{x.readyState=1,f&&p.trigger("ajaxSend",[x,c]),c.async&&c.timeout>0&&(u=setTimeout(function(){x.abort("timeout")},c.timeout));try{E=1,o.send(b,T)}catch(k){if(!(E<2))throw k;T(-1,k)}}return x}return x.abort()},active:0,lastModified:{},etag:{}});var Mn=[],_n=/\?/,Dn=/(=)\?(?=&|$)|\?\?/,Pn=v.now();v.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=Mn.pop()||v.expando+"_"+Pn++;return this[e]=!0,e}}),v.ajaxPrefilter("json jsonp",function(n,r,i){var s,o,u,a=n.data,f=n.url,l=n.jsonp!==!1,c=l&&Dn.test(f),h=l&&!c&&typeof a=="string"&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Dn.test(a);if(n.dataTypes[0]==="jsonp"||c||h)return s=n.jsonpCallback=v.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,o=e[s],c?n.url=f.replace(Dn,"$1"+s):h?n.data=a.replace(Dn,"$1"+s):l&&(n.url+=(_n.test(f)?"&":"?")+n.jsonp+"="+s),n.converters["script json"]=function(){return u||v.error(s+" was not called"),u[0]},n.dataTypes[0]="json",e[s]=function(){u=arguments},i.always(function(){e[s]=o,n[s]&&(n.jsonpCallback=r.jsonpCallback,Mn.push(s)),u&&v.isFunction(o)&&o(u[0]),u=o=t}),"script"}),v.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/javascript|ecmascript/},converters:{"text script":function(e){return v.globalEval(e),e}}}),v.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),v.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=i.head||i.getElementsByTagName("head")[0]||i.documentElement;return{send:function(s,o){n=i.createElement("script"),n.async="async",e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,i){if(i||!n.readyState||/loaded|complete/.test(n.readyState))n.onload=n.onreadystatechange=null,r&&n.parentNode&&r.removeChild(n),n=t,i||o(200,"success")},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(0,1)}}}});var Hn,Bn=e.ActiveXObject?function(){for(var e in Hn)Hn[e](0,1)}:!1,jn=0;v.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&Fn()||In()}:Fn,function(e){v.extend(v.support,{ajax:!!e,cors:!!e&&"withCredentials"in e})}(v.ajaxSettings.xhr()),v.support.ajax&&v.ajaxTransport(function(n){if(!n.crossDomain||v.support.cors){var r;return{send:function(i,s){var o,u,a=n.xhr();n.username?a.open(n.type,n.url,n.async,n.username,n.password):a.open(n.type,n.url,n.async);if(n.xhrFields)for(u in n.xhrFields)a[u]=n.xhrFields[u];n.mimeType&&a.overrideMimeType&&a.overrideMimeType(n.mimeType),!n.crossDomain&&!i["X-Requested-With"]&&(i["X-Requested-With"]="XMLHttpRequest");try{for(u in i)a.setRequestHeader(u,i[u])}catch(f){}a.send(n.hasContent&&n.data||null),r=function(e,i){var u,f,l,c,h;try{if(r&&(i||a.readyState===4)){r=t,o&&(a.onreadystatechange=v.noop,Bn&&delete Hn[o]);if(i)a.readyState!==4&&a.abort();else{u=a.status,l=a.getAllResponseHeaders(),c={},h=a.responseXML,h&&h.documentElement&&(c.xml=h);try{c.text=a.responseText}catch(p){}try{f=a.statusText}catch(p){f=""}!u&&n.isLocal&&!n.crossDomain?u=c.text?200:404:u===1223&&(u=204)}}}catch(d){i||s(-1,d)}c&&s(u,f,c,l)},n.async?a.readyState===4?setTimeout(r,0):(o=++jn,Bn&&(Hn||(Hn={},v(e).unload(Bn)),Hn[o]=r),a.onreadystatechange=r):r()},abort:function(){r&&r(0,1)}}}});var qn,Rn,Un=/^(?:toggle|show|hide)$/,zn=new RegExp("^(?:([-+])=|)("+m+")([a-z%]*)$","i"),Wn=/queueHooks$/,Xn=[Gn],Vn={"*":[function(e,t){var n,r,i=this.createTween(e,t),s=zn.exec(t),o=i.cur(),u=+o||0,a=1,f=20;if(s){n=+s[2],r=s[3]||(v.cssNumber[e]?"":"px");if(r!=="px"&&u){u=v.css(i.elem,e,!0)||n||1;do a=a||".5",u/=a,v.style(i.elem,e,u+r);while(a!==(a=i.cur()/o)&&a!==1&&--f)}i.unit=r,i.start=u,i.end=s[1]?u+(s[1]+1)*n:n}return i}]};v.Animation=v.extend(Kn,{tweener:function(e,t){v.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;r<i;r++)n=e[r],Vn[n]=Vn[n]||[],Vn[n].unshift(t)},prefilter:function(e,t){t?Xn.unshift(e):Xn.push(e)}}),v.Tween=Yn,Yn.prototype={constructor:Yn,init:function(e,t,n,r,i,s){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=s||(v.cssNumber[n]?"":"px")},cur:function(){var e=Yn.propHooks[this.prop];return e&&e.get?e.get(this):Yn.propHooks._default.get(this)},run:function(e){var t,n=Yn.propHooks[this.prop];return this.options.duration?this.pos=t=v.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):this.pos=t=e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):Yn.propHooks._default.set(this),this}},Yn.prototype.init.prototype=Yn.prototype,Yn.propHooks={_default:{get:function(e){var t;return e.elem[e.prop]==null||!!e.elem.style&&e.elem.style[e.prop]!=null?(t=v.css(e.elem,e.prop,!1,""),!t||t==="auto"?0:t):e.elem[e.prop]},set:function(e){v.fx.step[e.prop]?v.fx.step[e.prop](e):e.elem.style&&(e.elem.style[v.cssProps[e.prop]]!=null||v.cssHooks[e.prop])?v.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},Yn.propHooks.scrollTop=Yn.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},v.each(["toggle","show","hide"],function(e,t){var n=v.fn[t];v.fn[t]=function(r,i,s){return r==null||typeof r=="boolean"||!e&&v.isFunction(r)&&v.isFunction(i)?n.apply(this,arguments):this.animate(Zn(t,!0),r,i,s)}}),v.fn.extend({fadeTo:function(e,t,n,r){return this.filter(Gt).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=v.isEmptyObject(e),s=v.speed(t,n,r),o=function(){var t=Kn(this,v.extend({},e),s);i&&t.stop(!0)};return i||s.queue===!1?this.each(o):this.queue(s.queue,o)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return typeof e!="string"&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=e!=null&&e+"queueHooks",s=v.timers,o=v._data(this);if(n)o[n]&&o[n].stop&&i(o[n]);else for(n in o)o[n]&&o[n].stop&&Wn.test(n)&&i(o[n]);for(n=s.length;n--;)s[n].elem===this&&(e==null||s[n].queue===e)&&(s[n].anim.stop(r),t=!1,s.splice(n,1));(t||!r)&&v.dequeue(this,e)})}}),v.each({slideDown:Zn("show"),slideUp:Zn("hide"),slideToggle:Zn("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){v.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),v.speed=function(e,t,n){var r=e&&typeof e=="object"?v.extend({},e):{complete:n||!n&&t||v.isFunction(e)&&e,duration:e,easing:n&&t||t&&!v.isFunction(t)&&t};r.duration=v.fx.off?0:typeof r.duration=="number"?r.duration:r.duration in v.fx.speeds?v.fx.speeds[r.duration]:v.fx.speeds._default;if(r.queue==null||r.queue===!0)r.queue="fx";return r.old=r.complete,r.complete=function(){v.isFunction(r.old)&&r.old.call(this),r.queue&&v.dequeue(this,r.queue)},r},v.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},v.timers=[],v.fx=Yn.prototype.init,v.fx.tick=function(){var e,n=v.timers,r=0;qn=v.now();for(;r<n.length;r++)e=n[r],!e()&&n[r]===e&&n.splice(r--,1);n.length||v.fx.stop(),qn=t},v.fx.timer=function(e){e()&&v.timers.push(e)&&!Rn&&(Rn=setInterval(v.fx.tick,v.fx.interval))},v.fx.interval=13,v.fx.stop=function(){clearInterval(Rn),Rn=null},v.fx.speeds={slow:600,fast:200,_default:400},v.fx.step={},v.expr&&v.expr.filters&&(v.expr.filters.animated=function(e){return v.grep(v.timers,function(t){return e===t.elem}).length});var er=/^(?:body|html)$/i;v.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){v.offset.setOffset(this,e,t)});var n,r,i,s,o,u,a,f={top:0,left:0},l=this[0],c=l&&l.ownerDocument;if(!c)return;return(r=c.body)===l?v.offset.bodyOffset(l):(n=c.documentElement,v.contains(n,l)?(typeof l.getBoundingClientRect!="undefined"&&(f=l.getBoundingClientRect()),i=tr(c),s=n.clientTop||r.clientTop||0,o=n.clientLeft||r.clientLeft||0,u=i.pageYOffset||n.scrollTop,a=i.pageXOffset||n.scrollLeft,{top:f.top+u-s,left:f.left+a-o}):f)},v.offset={bodyOffset:function(e){var t=e.offsetTop,n=e.offsetLeft;return v.support.doesNotIncludeMarginInBodyOffset&&(t+=parseFloat(v.css(e,"marginTop"))||0,n+=parseFloat(v.css(e,"marginLeft"))||0),{top:t,left:n}},setOffset:function(e,t,n){var r=v.css(e,"position");r==="static"&&(e.style.position="relative");var i=v(e),s=i.offset(),o=v.css(e,"top"),u=v.css(e,"left"),a=(r==="absolute"||r==="fixed")&&v.inArray("auto",[o,u])>-1,f={},l={},c,h;a?(l=i.position(),c=l.top,h=l.left):(c=parseFloat(o)||0,h=parseFloat(u)||0),v.isFunction(t)&&(t=t.call(e,n,s)),t.top!=null&&(f.top=t.top-s.top+c),t.left!=null&&(f.left=t.left-s.left+h),"using"in t?t.using.call(e,f):i.css(f)}},v.fn.extend({position:function(){if(!this[0])return;var e=this[0],t=this.offsetParent(),n=this.offset(),r=er.test(t[0].nodeName)?{top:0,left:0}:t.offset();return n.top-=parseFloat(v.css(e,"marginTop"))||0,n.left-=parseFloat(v.css(e,"marginLeft"))||0,r.top+=parseFloat(v.css(t[0],"borderTopWidth"))||0,r.left+=parseFloat(v.css(t[0],"borderLeftWidth"))||0,{top:n.top-r.top,left:n.left-r.left}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||i.body;while(e&&!er.test(e.nodeName)&&v.css(e,"position")==="static")e=e.offsetParent;return e||i.body})}}),v.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);v.fn[e]=function(i){return v.access(this,function(e,i,s){var o=tr(e);if(s===t)return o?n in o?o[n]:o.document.documentElement[i]:e[i];o?o.scrollTo(r?v(o).scrollLeft():s,r?s:v(o).scrollTop()):e[i]=s},e,i,arguments.length,null)}}),v.each({Height:"height",Width:"width"},function(e,n){v.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){v.fn[i]=function(i,s){var o=arguments.length&&(r||typeof i!="boolean"),u=r||(i===!0||s===!0?"margin":"border");return v.access(this,function(n,r,i){var s;return v.isWindow(n)?n.document.documentElement["client"+e]:n.nodeType===9?(s=n.documentElement,Math.max(n.body["scroll"+e],s["scroll"+e],n.body["offset"+e],s["offset"+e],s["client"+e])):i===t?v.css(n,r,i,u):v.style(n,r,i,u)},n,o?i:t,o,null)}})}),e.jQuery=e.$=v,typeof define=="function"&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return v})})(window);/*! jQuery UI - v1.9.1 - 2012-10-25
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.position.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.effect.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.progressbar.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.slider.js, jquery.ui.sortable.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright (c) 2012 jQuery Foundation and other contributors Licensed MIT */

(function(e,t){function i(t,n){var r,i,o,u=t.nodeName.toLowerCase();return"area"===u?(r=t.parentNode,i=r.name,!t.href||!i||r.nodeName.toLowerCase()!=="map"?!1:(o=e("img[usemap=#"+i+"]")[0],!!o&&s(o))):(/input|select|textarea|button|object/.test(u)?!t.disabled:"a"===u?t.href||n:n)&&s(t)}function s(t){return e.expr.filters.visible(t)&&!e(t).parents().andSelf().filter(function(){return e.css(this,"visibility")==="hidden"}).length}var n=0,r=/^ui-id-\d+$/;e.ui=e.ui||{};if(e.ui.version)return;e.extend(e.ui,{version:"1.9.1",keyCode:{BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38}}),e.fn.extend({_focus:e.fn.focus,focus:function(t,n){return typeof t=="number"?this.each(function(){var r=this;setTimeout(function(){e(r).focus(),n&&n.call(r)},t)}):this._focus.apply(this,arguments)},scrollParent:function(){var t;return e.ui.ie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?t=this.parents().filter(function(){return/(relative|absolute|fixed)/.test(e.css(this,"position"))&&/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0):t=this.parents().filter(function(){return/(auto|scroll)/.test(e.css(this,"overflow")+e.css(this,"overflow-y")+e.css(this,"overflow-x"))}).eq(0),/fixed/.test(this.css("position"))||!t.length?e(document):t},zIndex:function(n){if(n!==t)return this.css("zIndex",n);if(this.length){var r=e(this[0]),i,s;while(r.length&&r[0]!==document){i=r.css("position");if(i==="absolute"||i==="relative"||i==="fixed"){s=parseInt(r.css("zIndex"),10);if(!isNaN(s)&&s!==0)return s}r=r.parent()}}return 0},uniqueId:function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++n)})},removeUniqueId:function(){return this.each(function(){r.test(this.id)&&e(this).removeAttr("id")})}}),e("<a>").outerWidth(1).jquery||e.each(["Width","Height"],function(n,r){function u(t,n,r,s){return e.each(i,function(){n-=parseFloat(e.css(t,"padding"+this))||0,r&&(n-=parseFloat(e.css(t,"border"+this+"Width"))||0),s&&(n-=parseFloat(e.css(t,"margin"+this))||0)}),n}var i=r==="Width"?["Left","Right"]:["Top","Bottom"],s=r.toLowerCase(),o={innerWidth:e.fn.innerWidth,innerHeight:e.fn.innerHeight,outerWidth:e.fn.outerWidth,outerHeight:e.fn.outerHeight};e.fn["inner"+r]=function(n){return n===t?o["inner"+r].call(this):this.each(function(){e(this).css(s,u(this,n)+"px")})},e.fn["outer"+r]=function(t,n){return typeof t!="number"?o["outer"+r].call(this,t):this.each(function(){e(this).css(s,u(this,t,!0,n)+"px")})}}),e.extend(e.expr[":"],{data:e.expr.createPseudo?e.expr.createPseudo(function(t){return function(n){return!!e.data(n,t)}}):function(t,n,r){return!!e.data(t,r[3])},focusable:function(t){return i(t,!isNaN(e.attr(t,"tabindex")))},tabbable:function(t){var n=e.attr(t,"tabindex"),r=isNaN(n);return(r||n>=0)&&i(t,!r)}}),e(function(){var t=document.body,n=t.appendChild(n=document.createElement("div"));n.offsetHeight,e.extend(n.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0}),e.support.minHeight=n.offsetHeight===100,e.support.selectstart="onselectstart"in n,t.removeChild(n).style.display="none"}),function(){var t=/msie ([\w.]+)/.exec(navigator.userAgent.toLowerCase())||[];e.ui.ie=t.length?!0:!1,e.ui.ie6=parseFloat(t[1],10)===6}(),e.fn.extend({disableSelection:function(){return this.bind((e.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(e){e.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),e.extend(e.ui,{plugin:{add:function(t,n,r){var i,s=e.ui[t].prototype;for(i in r)s.plugins[i]=s.plugins[i]||[],s.plugins[i].push([n,r[i]])},call:function(e,t,n){var r,i=e.plugins[t];if(!i||!e.element[0].parentNode||e.element[0].parentNode.nodeType===11)return;for(r=0;r<i.length;r++)e.options[i[r][0]]&&i[r][1].apply(e.element,n)}},contains:e.contains,hasScroll:function(t,n){if(e(t).css("overflow")==="hidden")return!1;var r=n&&n==="left"?"scrollLeft":"scrollTop",i=!1;return t[r]>0?!0:(t[r]=1,i=t[r]>0,t[r]=0,i)},isOverAxis:function(e,t,n){return e>t&&e<t+n},isOver:function(t,n,r,i,s,o){return e.ui.isOverAxis(t,r,s)&&e.ui.isOverAxis(n,i,o)}})})(jQuery);(function(e,t){var n=0,r=Array.prototype.slice,i=e.cleanData;e.cleanData=function(t){for(var n=0,r;(r=t[n])!=null;n++)try{e(r).triggerHandler("remove")}catch(s){}i(t)},e.widget=function(t,n,r){var i,s,o,u,a=t.split(".")[0];t=t.split(".")[1],i=a+"-"+t,r||(r=n,n=e.Widget),e.expr[":"][i.toLowerCase()]=function(t){return!!e.data(t,i)},e[a]=e[a]||{},s=e[a][t],o=e[a][t]=function(e,t){if(!this._createWidget)return new o(e,t);arguments.length&&this._createWidget(e,t)},e.extend(o,s,{version:r.version,_proto:e.extend({},r),_childConstructors:[]}),u=new n,u.options=e.widget.extend({},u.options),e.each(r,function(t,i){e.isFunction(i)&&(r[t]=function(){var e=function(){return n.prototype[t].apply(this,arguments)},r=function(e){return n.prototype[t].apply(this,e)};return function(){var t=this._super,n=this._superApply,s;return this._super=e,this._superApply=r,s=i.apply(this,arguments),this._super=t,this._superApply=n,s}}())}),o.prototype=e.widget.extend(u,{widgetEventPrefix:u.widgetEventPrefix||t},r,{constructor:o,namespace:a,widgetName:t,widgetBaseClass:i,widgetFullName:i}),s?(e.each(s._childConstructors,function(t,n){var r=n.prototype;e.widget(r.namespace+"."+r.widgetName,o,n._proto)}),delete s._childConstructors):n._childConstructors.push(o),e.widget.bridge(t,o)},e.widget.extend=function(n){var i=r.call(arguments,1),s=0,o=i.length,u,a;for(;s<o;s++)for(u in i[s])a=i[s][u],i[s].hasOwnProperty(u)&&a!==t&&(e.isPlainObject(a)?n[u]=e.isPlainObject(n[u])?e.widget.extend({},n[u],a):e.widget.extend({},a):n[u]=a);return n},e.widget.bridge=function(n,i){var s=i.prototype.widgetFullName;e.fn[n]=function(o){var u=typeof o=="string",a=r.call(arguments,1),f=this;return o=!u&&a.length?e.widget.extend.apply(null,[o].concat(a)):o,u?this.each(function(){var r,i=e.data(this,s);if(!i)return e.error("cannot call methods on "+n+" prior to initialization; "+"attempted to call method '"+o+"'");if(!e.isFunction(i[o])||o.charAt(0)==="_")return e.error("no such method '"+o+"' for "+n+" widget instance");r=i[o].apply(i,a);if(r!==i&&r!==t)return f=r&&r.jquery?f.pushStack(r.get()):r,!1}):this.each(function(){var t=e.data(this,s);t?t.option(o||{})._init():new i(o,this)}),f}},e.Widget=function(){},e.Widget._childConstructors=[],e.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{disabled:!1,create:null},_createWidget:function(t,r){r=e(r||this.defaultElement||this)[0],this.element=e(r),this.uuid=n++,this.eventNamespace="."+this.widgetName+this.uuid,this.options=e.widget.extend({},this.options,this._getCreateOptions(),t),this.bindings=e(),this.hoverable=e(),this.focusable=e(),r!==this&&(e.data(r,this.widgetName,this),e.data(r,this.widgetFullName,this),this._on(this.element,{remove:function(e){e.target===r&&this.destroy()}}),this.document=e(r.style?r.ownerDocument:r.document||r),this.window=e(this.document[0].defaultView||this.document[0].parentWindow)),this._create(),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:e.noop,_getCreateEventData:e.noop,_create:e.noop,_init:e.noop,destroy:function(){this._destroy(),this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData(e.camelCase(this.widgetFullName)),this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName+"-disabled "+"ui-state-disabled"),this.bindings.unbind(this.eventNamespace),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")},_destroy:e.noop,widget:function(){return this.element},option:function(n,r){var i=n,s,o,u;if(arguments.length===0)return e.widget.extend({},this.options);if(typeof n=="string"){i={},s=n.split("."),n=s.shift();if(s.length){o=i[n]=e.widget.extend({},this.options[n]);for(u=0;u<s.length-1;u++)o[s[u]]=o[s[u]]||{},o=o[s[u]];n=s.pop();if(r===t)return o[n]===t?null:o[n];o[n]=r}else{if(r===t)return this.options[n]===t?null:this.options[n];i[n]=r}}return this._setOptions(i),this},_setOptions:function(e){var t;for(t in e)this._setOption(t,e[t]);return this},_setOption:function(e,t){return this.options[e]=t,e==="disabled"&&(this.widget().toggleClass(this.widgetFullName+"-disabled ui-state-disabled",!!t).attr("aria-disabled",t),this.hoverable.removeClass("ui-state-hover"),this.focusable.removeClass("ui-state-focus")),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_on:function(t,n){var r,i=this;n?(t=r=e(t),this.bindings=this.bindings.add(t)):(n=t,t=this.element,r=this.widget()),e.each(n,function(n,s){function o(){if(i.options.disabled===!0||e(this).hasClass("ui-state-disabled"))return;return(typeof s=="string"?i[s]:s).apply(i,arguments)}typeof s!="string"&&(o.guid=s.guid=s.guid||o.guid||e.guid++);var u=n.match(/^(\w+)\s*(.*)$/),a=u[1]+i.eventNamespace,f=u[2];f?r.delegate(f,a,o):t.bind(a,o)})},_off:function(e,t){t=(t||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.unbind(t).undelegate(t)},_delay:function(e,t){function n(){return(typeof e=="string"?r[e]:e).apply(r,arguments)}var r=this;return setTimeout(n,t||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){e(t.currentTarget).addClass("ui-state-hover")},mouseleave:function(t){e(t.currentTarget).removeClass("ui-state-hover")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){e(t.currentTarget).addClass("ui-state-focus")},focusout:function(t){e(t.currentTarget).removeClass("ui-state-focus")}})},_trigger:function(t,n,r){var i,s,o=this.options[t];r=r||{},n=e.Event(n),n.type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),n.target=this.element[0],s=n.originalEvent;if(s)for(i in s)i in n||(n[i]=s[i]);return this.element.trigger(n,r),!(e.isFunction(o)&&o.apply(this.element[0],[n].concat(r))===!1||n.isDefaultPrevented())}},e.each({show:"fadeIn",hide:"fadeOut"},function(t,n){e.Widget.prototype["_"+t]=function(r,i,s){typeof i=="string"&&(i={effect:i});var o,u=i?i===!0||typeof i=="number"?n:i.effect||n:t;i=i||{},typeof i=="number"&&(i={duration:i}),o=!e.isEmptyObject(i),i.complete=s,i.delay&&r.delay(i.delay),o&&e.effects&&(e.effects.effect[u]||e.uiBackCompat!==!1&&e.effects[u])?r[t](i):u!==t&&r[u]?r[u](i.duration,i.easing,s):r.queue(function(n){e(this)[t](),s&&s.call(r[0]),n()})}}),e.uiBackCompat!==!1&&(e.Widget.prototype._getCreateOptions=function(){return e.metadata&&e.metadata.get(this.element[0])[this.widgetName]})})(jQuery);(function(e,t){var n=!1;e(document).mouseup(function(e){n=!1}),e.widget("ui.mouse",{version:"1.9.1",options:{cancel:"input,textarea,button,select,option",distance:1,delay:0},_mouseInit:function(){var t=this;this.element.bind("mousedown."+this.widgetName,function(e){return t._mouseDown(e)}).bind("click."+this.widgetName,function(n){if(!0===e.data(n.target,t.widgetName+".preventClickEvent"))return e.removeData(n.target,t.widgetName+".preventClickEvent"),n.stopImmediatePropagation(),!1}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),this._mouseMoveDelegate&&e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(t){if(n)return;this._mouseStarted&&this._mouseUp(t),this._mouseDownEvent=t;var r=this,i=t.which===1,s=typeof this.options.cancel=="string"&&t.target.nodeName?e(t.target).closest(this.options.cancel).length:!1;if(!i||s||!this._mouseCapture(t))return!0;this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){r.mouseDelayMet=!0},this.options.delay));if(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)){this._mouseStarted=this._mouseStart(t)!==!1;if(!this._mouseStarted)return t.preventDefault(),!0}return!0===e.data(t.target,this.widgetName+".preventClickEvent")&&e.removeData(t.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(e){return r._mouseMove(e)},this._mouseUpDelegate=function(e){return r._mouseUp(e)},e(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),t.preventDefault(),n=!0,!0},_mouseMove:function(t){return!e.ui.ie||document.documentMode>=9||!!t.button?this._mouseStarted?(this._mouseDrag(t),t.preventDefault()):(this._mouseDistanceMet(t)&&this._mouseDelayMet(t)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,t)!==!1,this._mouseStarted?this._mouseDrag(t):this._mouseUp(t)),!this._mouseStarted):this._mouseUp(t)},_mouseUp:function(t){return e(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,t.target===this._mouseDownEvent.target&&e.data(t.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(t)),!1},_mouseDistanceMet:function(e){return Math.max(Math.abs(this._mouseDownEvent.pageX-e.pageX),Math.abs(this._mouseDownEvent.pageY-e.pageY))>=this.options.distance},_mouseDelayMet:function(e){return this.mouseDelayMet},_mouseStart:function(e){},_mouseDrag:function(e){},_mouseStop:function(e){},_mouseCapture:function(e){return!0}})})(jQuery);(function(e,t){function h(e,t,n){return[parseInt(e[0],10)*(l.test(e[0])?t/100:1),parseInt(e[1],10)*(l.test(e[1])?n/100:1)]}function p(t,n){return parseInt(e.css(t,n),10)||0}e.ui=e.ui||{};var n,r=Math.max,i=Math.abs,s=Math.round,o=/left|center|right/,u=/top|center|bottom/,a=/[\+\-]\d+%?/,f=/^\w+/,l=/%$/,c=e.fn.position;e.position={scrollbarWidth:function(){if(n!==t)return n;var r,i,s=e("<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return e("body").append(s),r=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,r===i&&(i=s[0].clientWidth),s.remove(),n=r-i},getScrollInfo:function(t){var n=t.isWindow?"":t.element.css("overflow-x"),r=t.isWindow?"":t.element.css("overflow-y"),i=n==="scroll"||n==="auto"&&t.width<t.element[0].scrollWidth,s=r==="scroll"||r==="auto"&&t.height<t.element[0].scrollHeight;return{width:i?e.position.scrollbarWidth():0,height:s?e.position.scrollbarWidth():0}},getWithinInfo:function(t){var n=e(t||window),r=e.isWindow(n[0]);return{element:n,isWindow:r,offset:n.offset()||{left:0,top:0},scrollLeft:n.scrollLeft(),scrollTop:n.scrollTop(),width:r?n.width():n.outerWidth(),height:r?n.height():n.outerHeight()}}},e.fn.position=function(t){if(!t||!t.of)return c.apply(this,arguments);t=e.extend({},t);var n,l,d,v,m,g=e(t.of),y=e.position.getWithinInfo(t.within),b=e.position.getScrollInfo(y),w=g[0],E=(t.collision||"flip").split(" "),S={};return w.nodeType===9?(l=g.width(),d=g.height(),v={top:0,left:0}):e.isWindow(w)?(l=g.width(),d=g.height(),v={top:g.scrollTop(),left:g.scrollLeft()}):w.preventDefault?(t.at="left top",l=d=0,v={top:w.pageY,left:w.pageX}):(l=g.outerWidth(),d=g.outerHeight(),v=g.offset()),m=e.extend({},v),e.each(["my","at"],function(){var e=(t[this]||"").split(" "),n,r;e.length===1&&(e=o.test(e[0])?e.concat(["center"]):u.test(e[0])?["center"].concat(e):["center","center"]),e[0]=o.test(e[0])?e[0]:"center",e[1]=u.test(e[1])?e[1]:"center",n=a.exec(e[0]),r=a.exec(e[1]),S[this]=[n?n[0]:0,r?r[0]:0],t[this]=[f.exec(e[0])[0],f.exec(e[1])[0]]}),E.length===1&&(E[1]=E[0]),t.at[0]==="right"?m.left+=l:t.at[0]==="center"&&(m.left+=l/2),t.at[1]==="bottom"?m.top+=d:t.at[1]==="center"&&(m.top+=d/2),n=h(S.at,l,d),m.left+=n[0],m.top+=n[1],this.each(function(){var o,u,a=e(this),f=a.outerWidth(),c=a.outerHeight(),w=p(this,"marginLeft"),x=p(this,"marginTop"),T=f+w+p(this,"marginRight")+b.width,N=c+x+p(this,"marginBottom")+b.height,C=e.extend({},m),k=h(S.my,a.outerWidth(),a.outerHeight());t.my[0]==="right"?C.left-=f:t.my[0]==="center"&&(C.left-=f/2),t.my[1]==="bottom"?C.top-=c:t.my[1]==="center"&&(C.top-=c/2),C.left+=k[0],C.top+=k[1],e.support.offsetFractions||(C.left=s(C.left),C.top=s(C.top)),o={marginLeft:w,marginTop:x},e.each(["left","top"],function(r,i){e.ui.position[E[r]]&&e.ui.position[E[r]][i](C,{targetWidth:l,targetHeight:d,elemWidth:f,elemHeight:c,collisionPosition:o,collisionWidth:T,collisionHeight:N,offset:[n[0]+k[0],n[1]+k[1]],my:t.my,at:t.at,within:y,elem:a})}),e.fn.bgiframe&&a.bgiframe(),t.using&&(u=function(e){var n=v.left-C.left,s=n+l-f,o=v.top-C.top,u=o+d-c,h={target:{element:g,left:v.left,top:v.top,width:l,height:d},element:{element:a,left:C.left,top:C.top,width:f,height:c},horizontal:s<0?"left":n>0?"right":"center",vertical:u<0?"top":o>0?"bottom":"middle"};l<f&&i(n+s)<l&&(h.horizontal="center"),d<c&&i(o+u)<d&&(h.vertical="middle"),r(i(n),i(s))>r(i(o),i(u))?h.important="horizontal":h.important="vertical",t.using.call(this,e,h)}),a.offset(e.extend(C,{using:u}))})},e.ui.position={fit:{left:function(e,t){var n=t.within,i=n.isWindow?n.scrollLeft:n.offset.left,s=n.width,o=e.left-t.collisionPosition.marginLeft,u=i-o,a=o+t.collisionWidth-s-i,f;t.collisionWidth>s?u>0&&a<=0?(f=e.left+u+t.collisionWidth-s-i,e.left+=u-f):a>0&&u<=0?e.left=i:u>a?e.left=i+s-t.collisionWidth:e.left=i:u>0?e.left+=u:a>0?e.left-=a:e.left=r(e.left-o,e.left)},top:function(e,t){var n=t.within,i=n.isWindow?n.scrollTop:n.offset.top,s=t.within.height,o=e.top-t.collisionPosition.marginTop,u=i-o,a=o+t.collisionHeight-s-i,f;t.collisionHeight>s?u>0&&a<=0?(f=e.top+u+t.collisionHeight-s-i,e.top+=u-f):a>0&&u<=0?e.top=i:u>a?e.top=i+s-t.collisionHeight:e.top=i:u>0?e.top+=u:a>0?e.top-=a:e.top=r(e.top-o,e.top)}},flip:{left:function(e,t){var n=t.within,r=n.offset.left+n.scrollLeft,s=n.width,o=n.isWindow?n.scrollLeft:n.offset.left,u=e.left-t.collisionPosition.marginLeft,a=u-o,f=u+t.collisionWidth-s-o,l=t.my[0]==="left"?-t.elemWidth:t.my[0]==="right"?t.elemWidth:0,c=t.at[0]==="left"?t.targetWidth:t.at[0]==="right"?-t.targetWidth:0,h=-2*t.offset[0],p,d;if(a<0){p=e.left+l+c+h+t.collisionWidth-s-r;if(p<0||p<i(a))e.left+=l+c+h}else if(f>0){d=e.left-t.collisionPosition.marginLeft+l+c+h-o;if(d>0||i(d)<f)e.left+=l+c+h}},top:function(e,t){var n=t.within,r=n.offset.top+n.scrollTop,s=n.height,o=n.isWindow?n.scrollTop:n.offset.top,u=e.top-t.collisionPosition.marginTop,a=u-o,f=u+t.collisionHeight-s-o,l=t.my[1]==="top",c=l?-t.elemHeight:t.my[1]==="bottom"?t.elemHeight:0,h=t.at[1]==="top"?t.targetHeight:t.at[1]==="bottom"?-t.targetHeight:0,p=-2*t.offset[1],d,v;a<0?(v=e.top+c+h+p+t.collisionHeight-s-r,e.top+c+h+p>a&&(v<0||v<i(a))&&(e.top+=c+h+p)):f>0&&(d=e.top-t.collisionPosition.marginTop+c+h+p-o,e.top+c+h+p>f&&(d>0||i(d)<f)&&(e.top+=c+h+p))}},flipfit:{left:function(){e.ui.position.flip.left.apply(this,arguments),e.ui.position.fit.left.apply(this,arguments)},top:function(){e.ui.position.flip.top.apply(this,arguments),e.ui.position.fit.top.apply(this,arguments)}}},function(){var t,n,r,i,s,o=document.getElementsByTagName("body")[0],u=document.createElement("div");t=document.createElement(o?"div":"body"),r={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},o&&e.extend(r,{position:"absolute",left:"-1000px",top:"-1000px"});for(s in r)t.style[s]=r[s];t.appendChild(u),n=o||document.documentElement,n.insertBefore(t,n.firstChild),u.style.cssText="position: absolute; left: 10.7432222px;",i=e(u).offset().left,e.support.offsetFractions=i>10&&i<11,t.innerHTML="",n.removeChild(t)}(),e.uiBackCompat!==!1&&function(e){var n=e.fn.position;e.fn.position=function(r){if(!r||!r.offset)return n.call(this,r);var i=r.offset.split(" "),s=r.at.split(" ");return i.length===1&&(i[1]=i[0]),/^\d/.test(i[0])&&(i[0]="+"+i[0]),/^\d/.test(i[1])&&(i[1]="+"+i[1]),s.length===1&&(/left|center|right/.test(s[0])?s[1]="center":(s[1]=s[0],s[0]="center")),n.call(this,e.extend(r,{at:s[0]+i[0]+" "+s[1]+i[1],offset:t}))}}(jQuery)})(jQuery);(function(e,t){var n=0,r={},i={};r.height=r.paddingTop=r.paddingBottom=r.borderTopWidth=r.borderBottomWidth="hide",i.height=i.paddingTop=i.paddingBottom=i.borderTopWidth=i.borderBottomWidth="show",e.widget("ui.accordion",{version:"1.9.1",options:{active:0,animate:{},collapsible:!1,event:"click",header:"> li > :first-child,> :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},_create:function(){var t=this.accordionId="ui-accordion-"+(this.element.attr("id")||++n),r=this.options;this.prevShow=this.prevHide=e(),this.element.addClass("ui-accordion ui-widget ui-helper-reset"),this.headers=this.element.find(r.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all"),this._hoverable(this.headers),this._focusable(this.headers),this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").hide(),!r.collapsible&&(r.active===!1||r.active==null)&&(r.active=0),r.active<0&&(r.active+=this.headers.length),this.active=this._findActive(r.active).addClass("ui-accordion-header-active ui-state-active").toggleClass("ui-corner-all ui-corner-top"),this.active.next().addClass("ui-accordion-content-active").show(),this._createIcons(),this.refresh(),this.element.attr("role","tablist"),this.headers.attr("role","tab").each(function(n){var r=e(this),i=r.attr("id"),s=r.next(),o=s.attr("id");i||(i=t+"-header-"+n,r.attr("id",i)),o||(o=t+"-panel-"+n,s.attr("id",o)),r.attr("aria-controls",o),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false",tabIndex:-1}).next().attr({"aria-expanded":"false","aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true",tabIndex:0}).next().attr({"aria-expanded":"true","aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._on(this.headers,{keydown:"_keydown"}),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._setupEvents(r.event)},_getCreateEventData:function(){return{header:this.active,content:this.active.length?this.active.next():e()}},_createIcons:function(){var t=this.options.icons;t&&(e("<span>").addClass("ui-accordion-header-icon ui-icon "+t.header).prependTo(this.headers),this.active.children(".ui-accordion-header-icon").removeClass(t.header).addClass(t.activeHeader),this.headers.addClass("ui-accordion-icons"))},_destroyIcons:function(){this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove()},_destroy:function(){var e;this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"),this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").each(function(){/^ui-accordion/.test(this.id)&&this.removeAttribute("id")}),this._destroyIcons(),e=this.headers.next().css("display","").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled").each(function(){/^ui-accordion/.test(this.id)&&this.removeAttribute("id")}),this.options.heightStyle!=="content"&&e.css("height","")},_setOption:function(e,t){if(e==="active"){this._activate(t);return}e==="event"&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(t)),this._super(e,t),e==="collapsible"&&!t&&this.options.active===!1&&this._activate(0),e==="icons"&&(this._destroyIcons(),t&&this._createIcons()),e==="disabled"&&this.headers.add(this.headers.next()).toggleClass("ui-state-disabled",!!t)},_keydown:function(t){if(t.altKey||t.ctrlKey)return;var n=e.ui.keyCode,r=this.headers.length,i=this.headers.index(t.target),s=!1;switch(t.keyCode){case n.RIGHT:case n.DOWN:s=this.headers[(i+1)%r];break;case n.LEFT:case n.UP:s=this.headers[(i-1+r)%r];break;case n.SPACE:case n.ENTER:this._eventHandler(t);break;case n.HOME:s=this.headers[0];break;case n.END:s=this.headers[r-1]}s&&(e(t.target).attr("tabIndex",-1),e(s).attr("tabIndex",0),s.focus(),t.preventDefault())},_panelKeyDown:function(t){t.keyCode===e.ui.keyCode.UP&&t.ctrlKey&&e(t.currentTarget).prev().focus()},refresh:function(){var t,n,r=this.options.heightStyle,i=this.element.parent();r==="fill"?(e.support.minHeight||(n=i.css("overflow"),i.css("overflow","hidden")),t=i.height(),this.element.siblings(":visible").each(function(){var n=e(this),r=n.css("position");if(r==="absolute"||r==="fixed")return;t-=n.outerHeight(!0)}),n&&i.css("overflow",n),this.headers.each(function(){t-=e(this).outerHeight(!0)}),this.headers.next().each(function(){e(this).height(Math.max(0,t-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):r==="auto"&&(t=0,this.headers.next().each(function(){t=Math.max(t,e(this).height("").height())}).height(t))},_activate:function(t){var n=this._findActive(t)[0];if(n===this.active[0])return;n=n||this.active[0],this._eventHandler({target:n,currentTarget:n,preventDefault:e.noop})},_findActive:function(t){return typeof t=="number"?this.headers.eq(t):e()},_setupEvents:function(t){var n={};if(!t)return;e.each(t.split(" "),function(e,t){n[t]="_eventHandler"}),this._on(this.headers,n)},_eventHandler:function(t){var n=this.options,r=this.active,i=e(t.currentTarget),s=i[0]===r[0],o=s&&n.collapsible,u=o?e():i.next(),a=r.next(),f={oldHeader:r,oldPanel:a,newHeader:o?e():i,newPanel:u};t.preventDefault();if(s&&!n.collapsible||this._trigger("beforeActivate",t,f)===!1)return;n.active=o?!1:this.headers.index(i),this.active=s?e():i,this._toggle(f),r.removeClass("ui-accordion-header-active ui-state-active"),n.icons&&r.children(".ui-accordion-header-icon").removeClass(n.icons.activeHeader).addClass(n.icons.header),s||(i.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top"),n.icons&&i.children(".ui-accordion-header-icon").removeClass(n.icons.header).addClass(n.icons.activeHeader),i.next().addClass("ui-accordion-content-active"))},_toggle:function(t){var n=t.newPanel,r=this.prevShow.length?this.prevShow:t.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=n,this.prevHide=r,this.options.animate?this._animate(n,r,t):(r.hide(),n.show(),this._toggleComplete(t)),r.attr({"aria-expanded":"false","aria-hidden":"true"}),r.prev().attr("aria-selected","false"),n.length&&r.length?r.prev().attr("tabIndex",-1):n.length&&this.headers.filter(function(){return e(this).attr("tabIndex")===0}).attr("tabIndex",-1),n.attr({"aria-expanded":"true","aria-hidden":"false"}).prev().attr({"aria-selected":"true",tabIndex:0})},_animate:function(e,t,n){var s,o,u,a=this,f=0,l=e.length&&(!t.length||e.index()<t.index()),c=this.options.animate||{},h=l&&c.down||c,p=function(){a._toggleComplete(n)};typeof h=="number"&&(u=h),typeof h=="string"&&(o=h),o=o||h.easing||c.easing,u=u||h.duration||c.duration;if(!t.length)return e.animate(i,u,o,p);if(!e.length)return t.animate(r,u,o,p);s=e.show().outerHeight(),t.animate(r,{duration:u,easing:o,step:function(e,t){t.now=Math.round(e)}}),e.hide().animate(i,{duration:u,easing:o,complete:p,step:function(e,n){n.now=Math.round(e),n.prop!=="height"?f+=n.now:a.options.heightStyle!=="content"&&(n.now=Math.round(s-t.outerHeight()-f),f=0)}})},_toggleComplete:function(e){var t=e.oldPanel;t.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all"),t.length&&(t.parent()[0].className=t.parent()[0].className),this._trigger("activate",null,e)}}),e.uiBackCompat!==!1&&(function(e,t){e.extend(t.options,{navigation:!1,navigationFilter:function(){return this.href.toLowerCase()===location.href.toLowerCase()}});var n=t._create;t._create=function(){if(this.options.navigation){var t=this,r=this.element.find(this.options.header),i=r.next(),s=r.add(i).find("a").filter(this.options.navigationFilter)[0];s&&r.add(i).each(function(n){if(e.contains(this,s))return t.options.active=Math.floor(n/2),!1})}n.call(this)}}(jQuery,jQuery.ui.accordion.prototype),function(e,t){e.extend(t.options,{heightStyle:null,autoHeight:!0,clearStyle:!1,fillSpace:!1});var n=t._create,r=t._setOption;e.extend(t,{_create:function(){this.options.heightStyle=this.options.heightStyle||this._mergeHeightStyle(),n.call(this)},_setOption:function(e){if(e==="autoHeight"||e==="clearStyle"||e==="fillSpace")this.options.heightStyle=this._mergeHeightStyle();r.apply(this,arguments)},_mergeHeightStyle:function(){var e=this.options;if(e.fillSpace)return"fill";if(e.clearStyle)return"content";if(e.autoHeight)return"auto"}})}(jQuery,jQuery.ui.accordion.prototype),function(e,t){e.extend(t.options.icons,{activeHeader:null,headerSelected:"ui-icon-triangle-1-s"});var n=t._createIcons;t._createIcons=function(){this.options.icons&&(this.options.icons.activeHeader=this.options.icons.activeHeader||this.options.icons.headerSelected),n.call(this)}}(jQuery,jQuery.ui.accordion.prototype),function(e,t){t.activate=t._activate;var n=t._findActive;t._findActive=function(e){return e===-1&&(e=!1),e&&typeof e!="number"&&(e=this.headers.index(this.headers.filter(e)),e===-1&&(e=!1)),n.call(this,e)}}(jQuery,jQuery.ui.accordion.prototype),jQuery.ui.accordion.prototype.resize=jQuery.ui.accordion.prototype.refresh,function(e,t){e.extend(t.options,{change:null,changestart:null});var n=t._trigger;t._trigger=function(e,t,r){var i=n.apply(this,arguments);return i?(e==="beforeActivate"?i=n.call(this,"changestart",t,{oldHeader:r.oldHeader,oldContent:r.oldPanel,newHeader:r.newHeader,newContent:r.newPanel}):e==="activate"&&(i=n.call(this,"change",t,{oldHeader:r.oldHeader,oldContent:r.oldPanel,newHeader:r.newHeader,newContent:r.newPanel})),i):!1}}(jQuery,jQuery.ui.accordion.prototype),function(e,t){e.extend(t.options,{animate:null,animated:"slide"});var n=t._create;t._create=function(){var e=this.options;e.animate===null&&(e.animated?e.animated==="slide"?e.animate=300:e.animated==="bounceslide"?e.animate={duration:200,down:{easing:"easeOutBounce",duration:1e3}}:e.animate=e.animated:e.animate=!1),n.call(this)}}(jQuery,jQuery.ui.accordion.prototype))})(jQuery);(function(e,t){var n=0;e.widget("ui.autocomplete",{version:"1.9.1",defaultElement:"<input>",options:{appendTo:"body",autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},pending:0,_create:function(){var t,n,r;this.isMultiLine=this._isMultiLine(),this.valueMethod=this.element[this.element.is("input,textarea")?"val":"text"],this.isNewMenu=!0,this.element.addClass("ui-autocomplete-input").attr("autocomplete","off"),this._on(this.element,{keydown:function(i){if(this.element.prop("readOnly")){t=!0,r=!0,n=!0;return}t=!1,r=!1,n=!1;var s=e.ui.keyCode;switch(i.keyCode){case s.PAGE_UP:t=!0,this._move("previousPage",i);break;case s.PAGE_DOWN:t=!0,this._move("nextPage",i);break;case s.UP:t=!0,this._keyEvent("previous",i);break;case s.DOWN:t=!0,this._keyEvent("next",i);break;case s.ENTER:case s.NUMPAD_ENTER:this.menu.active&&(t=!0,i.preventDefault(),this.menu.select(i));break;case s.TAB:this.menu.active&&this.menu.select(i);break;case s.ESCAPE:this.menu.element.is(":visible")&&(this._value(this.term),this.close(i),i.preventDefault());break;default:n=!0,this._searchTimeout(i)}},keypress:function(r){if(t){t=!1,r.preventDefault();return}if(n)return;var i=e.ui.keyCode;switch(r.keyCode){case i.PAGE_UP:this._move("previousPage",r);break;case i.PAGE_DOWN:this._move("nextPage",r);break;case i.UP:this._keyEvent("previous",r);break;case i.DOWN:this._keyEvent("next",r)}},input:function(e){if(r){r=!1,e.preventDefault();return}this._searchTimeout(e)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(e){if(this.cancelBlur){delete this.cancelBlur;return}clearTimeout(this.searching),this.close(e),this._change(e)}}),this._initSource(),this.menu=e("<ul>").addClass("ui-autocomplete").appendTo(this.document.find(this.options.appendTo||"body")[0]).menu({input:e(),role:null}).zIndex(this.element.zIndex()+1).hide().data("menu"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur});var n=this.menu.element[0];e(t.target).closest(".ui-menu-item").length||this._delay(function(){var t=this;this.document.one("mousedown",function(r){r.target!==t.element[0]&&r.target!==n&&!e.contains(n,r.target)&&t.close()})})},menufocus:function(t,n){if(this.isNewMenu){this.isNewMenu=!1;if(t.originalEvent&&/^mouse/.test(t.originalEvent.type)){this.menu.blur(),this.document.one("mousemove",function(){e(t.target).trigger(t.originalEvent)});return}}var r=n.item.data("ui-autocomplete-item")||n.item.data("item.autocomplete");!1!==this._trigger("focus",t,{item:r})?t.originalEvent&&/^key/.test(t.originalEvent.type)&&this._value(r.value):this.liveRegion.text(r.value)},menuselect:function(e,t){var n=t.item.data("ui-autocomplete-item")||t.item.data("item.autocomplete"),r=this.previous;this.element[0]!==this.document[0].activeElement&&(this.element.focus(),this.previous=r,this._delay(function(){this.previous=r,this.selectedItem=n})),!1!==this._trigger("select",e,{item:n})&&this._value(n.value),this.term=this._value(),this.close(e),this.selectedItem=n}}),this.liveRegion=e("<span>",{role:"status","aria-live":"polite"}).addClass("ui-helper-hidden-accessible").insertAfter(this.element),e.fn.bgiframe&&this.menu.element.bgiframe(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(e,t){this._super(e,t),e==="source"&&this._initSource(),e==="appendTo"&&this.menu.element.appendTo(this.document.find(t||"body")[0]),e==="disabled"&&t&&this.xhr&&this.xhr.abort()},_isMultiLine:function(){return this.element.is("textarea")?!0:this.element.is("input")?!1:this.element.prop("isContentEditable")},_initSource:function(){var t,n,r=this;e.isArray(this.options.source)?(t=this.options.source,this.source=function(n,r){r(e.ui.autocomplete.filter(t,n.term))}):typeof this.options.source=="string"?(n=this.options.source,this.source=function(t,i){r.xhr&&r.xhr.abort(),r.xhr=e.ajax({url:n,data:t,dataType:"json",success:function(e){i(e)},error:function(){i([])}})}):this.source=this.options.source},_searchTimeout:function(e){clearTimeout(this.searching),this.searching=this._delay(function(){this.term!==this._value()&&(this.selectedItem=null,this.search(null,e))},this.options.delay)},search:function(e,t){e=e!=null?e:this._value(),this.term=this._value();if(e.length<this.options.minLength)return this.close(t);if(this._trigger("search",t)===!1)return;return this._search(e)},_search:function(e){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:e},this._response())},_response:function(){var e=this,t=++n;return function(r){t===n&&e.__response(r),e.pending--,e.pending||e.element.removeClass("ui-autocomplete-loading")}},__response:function(e){e&&(e=this._normalize(e)),this._trigger("response",null,{content:e}),!this.options.disabled&&e&&e.length&&!this.cancelSearch?(this._suggest(e),this._trigger("open")):this._close()},close:function(e){this.cancelSearch=!0,this._close(e)},_close:function(e){this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",e))},_change:function(e){this.previous!==this._value()&&this._trigger("change",e,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:e.map(t,function(t){return typeof t=="string"?{label:t,value:t}:e.extend({label:t.label||t.value,value:t.value||t.label},t)})},_suggest:function(t){var n=this.menu.element.empty().zIndex(this.element.zIndex()+1);this._renderMenu(n,t),this.menu.refresh(),n.show(),this._resizeMenu(),n.position(e.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next()},_resizeMenu:function(){var e=this.menu.element;e.outerWidth(Math.max(e.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(t,n){var r=this;e.each(n,function(e,n){r._renderItemData(t,n)})},_renderItemData:function(e,t){return this._renderItem(e,t).data("ui-autocomplete-item",t)},_renderItem:function(t,n){return e("<li>").append(e("<a>").text(n.label)).appendTo(t)},_move:function(e,t){if(!this.menu.element.is(":visible")){this.search(null,t);return}if(this.menu.isFirstItem()&&/^previous/.test(e)||this.menu.isLastItem()&&/^next/.test(e)){this._value(this.term),this.menu.blur();return}this.menu[e](t)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(e,t){if(!this.isMultiLine||this.menu.element.is(":visible"))this._move(e,t),t.preventDefault()}}),e.extend(e.ui.autocomplete,{escapeRegex:function(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(t,n){var r=new RegExp(e.ui.autocomplete.escapeRegex(n),"i");return e.grep(t,function(e){return r.test(e.label||e.value||e)})}}),e.widget("ui.autocomplete",e.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(e){return e+(e>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var t;this._superApply(arguments);if(this.options.disabled||this.cancelSearch)return;e&&e.length?t=this.options.messages.results(e.length):t=this.options.messages.noResults,this.liveRegion.text(t)}})})(jQuery);(function(e,t){var n,r,i,s,o="ui-button ui-widget ui-state-default ui-corner-all",u="ui-state-hover ui-state-active ",a="ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",f=function(){var t=e(this).find(":ui-button");setTimeout(function(){t.button("refresh")},1)},l=function(t){var n=t.name,r=t.form,i=e([]);return n&&(r?i=e(r).find("[name='"+n+"']"):i=e("[name='"+n+"']",t.ownerDocument).filter(function(){return!this.form})),i};e.widget("ui.button",{version:"1.9.1",defaultElement:"<button>",options:{disabled:null,text:!0,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset"+this.eventNamespace).bind("reset"+this.eventNamespace,f),typeof this.options.disabled!="boolean"?this.options.disabled=!!this.element.prop("disabled"):this.element.prop("disabled",this.options.disabled),this._determineButtonType(),this.hasTitle=!!this.buttonElement.attr("title");var t=this,u=this.options,a=this.type==="checkbox"||this.type==="radio",c="ui-state-hover"+(a?"":" ui-state-active"),h="ui-state-focus";u.label===null&&(u.label=this.type==="input"?this.buttonElement.val():this.buttonElement.html()),this.buttonElement.addClass(o).attr("role","button").bind("mouseenter"+this.eventNamespace,function(){if(u.disabled)return;e(this).addClass("ui-state-hover"),this===n&&e(this).addClass("ui-state-active")}).bind("mouseleave"+this.eventNamespace,function(){if(u.disabled)return;e(this).removeClass(c)}).bind("click"+this.eventNamespace,function(e){u.disabled&&(e.preventDefault(),e.stopImmediatePropagation())}),this.element.bind("focus"+this.eventNamespace,function(){t.buttonElement.addClass(h)}).bind("blur"+this.eventNamespace,function(){t.buttonElement.removeClass(h)}),a&&(this.element.bind("change"+this.eventNamespace,function(){if(s)return;t.refresh()}),this.buttonElement.bind("mousedown"+this.eventNamespace,function(e){if(u.disabled)return;s=!1,r=e.pageX,i=e.pageY}).bind("mouseup"+this.eventNamespace,function(e){if(u.disabled)return;if(r!==e.pageX||i!==e.pageY)s=!0})),this.type==="checkbox"?this.buttonElement.bind("click"+this.eventNamespace,function(){if(u.disabled||s)return!1;e(this).toggleClass("ui-state-active"),t.buttonElement.attr("aria-pressed",t.element[0].checked)}):this.type==="radio"?this.buttonElement.bind("click"+this.eventNamespace,function(){if(u.disabled||s)return!1;e(this).addClass("ui-state-active"),t.buttonElement.attr("aria-pressed","true");var n=t.element[0];l(n).not(n).map(function(){return e(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")}):(this.buttonElement.bind("mousedown"+this.eventNamespace,function(){if(u.disabled)return!1;e(this).addClass("ui-state-active"),n=this,t.document.one("mouseup",function(){n=null})}).bind("mouseup"+this.eventNamespace,function(){if(u.disabled)return!1;e(this).removeClass("ui-state-active")}).bind("keydown"+this.eventNamespace,function(t){if(u.disabled)return!1;(t.keyCode===e.ui.keyCode.SPACE||t.keyCode===e.ui.keyCode.ENTER)&&e(this).addClass("ui-state-active")}).bind("keyup"+this.eventNamespace,function(){e(this).removeClass("ui-state-active")}),this.buttonElement.is("a")&&this.buttonElement.keyup(function(t){t.keyCode===e.ui.keyCode.SPACE&&e(this).click()})),this._setOption("disabled",u.disabled),this._resetButton()},_determineButtonType:function(){var e,t,n;this.element.is("[type=checkbox]")?this.type="checkbox":this.element.is("[type=radio]")?this.type="radio":this.element.is("input")?this.type="input":this.type="button",this.type==="checkbox"||this.type==="radio"?(e=this.element.parents().last(),t="label[for='"+this.element.attr("id")+"']",this.buttonElement=e.find(t),this.buttonElement.length||(e=e.length?e.siblings():this.element.siblings(),this.buttonElement=e.filter(t),this.buttonElement.length||(this.buttonElement=e.find(t))),this.element.addClass("ui-helper-hidden-accessible"),n=this.element.is(":checked"),n&&this.buttonElement.addClass("ui-state-active"),this.buttonElement.prop("aria-pressed",n)):this.buttonElement=this.element},widget:function(){return this.buttonElement},_destroy:function(){this.element.removeClass("ui-helper-hidden-accessible"),this.buttonElement.removeClass(o+" "+u+" "+a).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()),this.hasTitle||this.buttonElement.removeAttr("title")},_setOption:function(e,t){this._super(e,t);if(e==="disabled"){t?this.element.prop("disabled",!0):this.element.prop("disabled",!1);return}this._resetButton()},refresh:function(){var t=this.element.is(":disabled")||this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOption("disabled",t),this.type==="radio"?l(this.element[0]).each(function(){e(this).is(":checked")?e(this).button("widget").addClass("ui-state-active").attr("aria-pressed","true"):e(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")}):this.type==="checkbox"&&(this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false"))},_resetButton:function(){if(this.type==="input"){this.options.label&&this.element.val(this.options.label);return}var t=this.buttonElement.removeClass(a),n=e("<span></span>",this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(t.empty()).text(),r=this.options.icons,i=r.primary&&r.secondary,s=[];r.primary||r.secondary?(this.options.text&&s.push("ui-button-text-icon"+(i?"s":r.primary?"-primary":"-secondary")),r.primary&&t.prepend("<span class='ui-button-icon-primary ui-icon "+r.primary+"'></span>"),r.secondary&&t.append("<span class='ui-button-icon-secondary ui-icon "+r.secondary+"'></span>"),this.options.text||(s.push(i?"ui-button-icons-only":"ui-button-icon-only"),this.hasTitle||t.attr("title",e.trim(n)))):s.push("ui-button-text-only"),t.addClass(s.join(" "))}}),e.widget("ui.buttonset",{version:"1.9.1",options:{items:"button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(e,t){e==="disabled"&&this.buttons.button("option",e,t),this._super(e,t)},refresh:function(){var t=this.element.css("direction")==="rtl";this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return e(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(t?"ui-corner-right":"ui-corner-left").end().filter(":last").addClass(t?"ui-corner-left":"ui-corner-right").end().end()},_destroy:function(){this.element.removeClass("ui-buttonset"),this.buttons.map(function(){return e(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy")}})})(jQuery);(function($,undefined){function Datepicker(){this.debug=!1,this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},$.extend(this._defaults,this.regional[""]),this.dpDiv=bindHover($('<div id="'+this._mainDivId+'" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}function bindHover(e){var t="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return e.delegate(t,"mouseout",function(){$(this).removeClass("ui-state-hover"),this.className.indexOf("ui-datepicker-prev")!=-1&&$(this).removeClass("ui-datepicker-prev-hover"),this.className.indexOf("ui-datepicker-next")!=-1&&$(this).removeClass("ui-datepicker-next-hover")}).delegate(t,"mouseover",function(){$.datepicker._isDisabledDatepicker(instActive.inline?e.parent()[0]:instActive.input[0])||($(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),$(this).addClass("ui-state-hover"),this.className.indexOf("ui-datepicker-prev")!=-1&&$(this).addClass("ui-datepicker-prev-hover"),this.className.indexOf("ui-datepicker-next")!=-1&&$(this).addClass("ui-datepicker-next-hover"))})}function extendRemove(e,t){$.extend(e,t);for(var n in t)if(t[n]==null||t[n]==undefined)e[n]=t[n];return e}$.extend($.ui,{datepicker:{version:"1.9.1"}});var PROP_NAME="datepicker",dpuuid=(new Date).getTime(),instActive;$.extend(Datepicker.prototype,{markerClassName:"hasDatepicker",maxRows:4,log:function(){this.debug&&console.log.apply("",arguments)},_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(e){return extendRemove(this._defaults,e||{}),this},_attachDatepicker:function(target,settings){var inlineSettings=null;for(var attrName in this._defaults){var attrValue=target.getAttribute("date:"+attrName);if(attrValue){inlineSettings=inlineSettings||{};try{inlineSettings[attrName]=eval(attrValue)}catch(err){inlineSettings[attrName]=attrValue}}}var nodeName=target.nodeName.toLowerCase(),inline=nodeName=="div"||nodeName=="span";target.id||(this.uuid+=1,target.id="dp"+this.uuid);var inst=this._newInst($(target),inline);inst.settings=$.extend({},settings||{},inlineSettings||{}),nodeName=="input"?this._connectDatepicker(target,inst):inline&&this._inlineDatepicker(target,inst)},_newInst:function(e,t){var n=e[0].id.replace(/([^A-Za-z0-9_-])/g,"\\\\$1");return{id:n,input:e,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:t,dpDiv:t?bindHover($('<div class="'+this._inlineClass+' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')):this.dpDiv}},_connectDatepicker:function(e,t){var n=$(e);t.append=$([]),t.trigger=$([]);if(n.hasClass(this.markerClassName))return;this._attachments(n,t),n.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker",function(e,n,r){t.settings[n]=r}).bind("getData.datepicker",function(e,n){return this._get(t,n)}),this._autoSize(t),$.data(e,PROP_NAME,t),t.settings.disabled&&this._disableDatepicker(e)},_attachments:function(e,t){var n=this._get(t,"appendText"),r=this._get(t,"isRTL");t.append&&t.append.remove(),n&&(t.append=$('<span class="'+this._appendClass+'">'+n+"</span>"),e[r?"before":"after"](t.append)),e.unbind("focus",this._showDatepicker),t.trigger&&t.trigger.remove();var i=this._get(t,"showOn");(i=="focus"||i=="both")&&e.focus(this._showDatepicker);if(i=="button"||i=="both"){var s=this._get(t,"buttonText"),o=this._get(t,"buttonImage");t.trigger=$(this._get(t,"buttonImageOnly")?$("<img/>").addClass(this._triggerClass).attr({src:o,alt:s,title:s}):$('<button type="button"></button>').addClass(this._triggerClass).html(o==""?s:$("<img/>").attr({src:o,alt:s,title:s}))),e[r?"before":"after"](t.trigger),t.trigger.click(function(){return $.datepicker._datepickerShowing&&$.datepicker._lastInput==e[0]?$.datepicker._hideDatepicker():$.datepicker._datepickerShowing&&$.datepicker._lastInput!=e[0]?($.datepicker._hideDatepicker(),$.datepicker._showDatepicker(e[0])):$.datepicker._showDatepicker(e[0]),!1})}},_autoSize:function(e){if(this._get(e,"autoSize")&&!e.inline){var t=new Date(2009,11,20),n=this._get(e,"dateFormat");if(n.match(/[DM]/)){var r=function(e){var t=0,n=0;for(var r=0;r<e.length;r++)e[r].length>t&&(t=e[r].length,n=r);return n};t.setMonth(r(this._get(e,n.match(/MM/)?"monthNames":"monthNamesShort"))),t.setDate(r(this._get(e,n.match(/DD/)?"dayNames":"dayNamesShort"))+20-t.getDay())}e.input.attr("size",this._formatDate(e,t).length)}},_inlineDatepicker:function(e,t){var n=$(e);if(n.hasClass(this.markerClassName))return;n.addClass(this.markerClassName).append(t.dpDiv).bind("setData.datepicker",function(e,n,r){t.settings[n]=r}).bind("getData.datepicker",function(e,n){return this._get(t,n)}),$.data(e,PROP_NAME,t),this._setDate(t,this._getDefaultDate(t),!0),this._updateDatepicker(t),this._updateAlternate(t),t.settings.disabled&&this._disableDatepicker(e),t.dpDiv.css("display","block")},_dialogDatepicker:function(e,t,n,r,i){var s=this._dialogInst;if(!s){this.uuid+=1;var o="dp"+this.uuid;this._dialogInput=$('<input type="text" id="'+o+'" style="position: absolute; top: -100px; width: 0px;"/>'),this._dialogInput.keydown(this._doKeyDown),$("body").append(this._dialogInput),s=this._dialogInst=this._newInst(this._dialogInput,!1),s.settings={},$.data(this._dialogInput[0],PROP_NAME,s)}extendRemove(s.settings,r||{}),t=t&&t.constructor==Date?this._formatDate(s,t):t,this._dialogInput.val(t),this._pos=i?i.length?i:[i.pageX,i.pageY]:null;if(!this._pos){var u=document.documentElement.clientWidth,a=document.documentElement.clientHeight,f=document.documentElement.scrollLeft||document.body.scrollLeft,l=document.documentElement.scrollTop||document.body.scrollTop;this._pos=[u/2-100+f,a/2-150+l]}return this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),s.settings.onSelect=n,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),$.blockUI&&$.blockUI(this.dpDiv),$.data(this._dialogInput[0],PROP_NAME,s),this},_destroyDatepicker:function(e){var t=$(e),n=$.data(e,PROP_NAME);if(!t.hasClass(this.markerClassName))return;var r=e.nodeName.toLowerCase();$.removeData(e,PROP_NAME),r=="input"?(n.append.remove(),n.trigger.remove(),t.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)):(r=="div"||r=="span")&&t.removeClass(this.markerClassName).empty()},_enableDatepicker:function(e){var t=$(e),n=$.data(e,PROP_NAME);if(!t.hasClass(this.markerClassName))return;var r=e.nodeName.toLowerCase();if(r=="input")e.disabled=!1,n.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""});else if(r=="div"||r=="span"){var i=t.children("."+this._inlineClass);i.children().removeClass("ui-state-disabled"),i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)}this._disabledInputs=$.map(this._disabledInputs,function(t){return t==e?null:t})},_disableDatepicker:function(e){var t=$(e),n=$.data(e,PROP_NAME);if(!t.hasClass(this.markerClassName))return;var r=e.nodeName.toLowerCase();if(r=="input")e.disabled=!0,n.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"});else if(r=="div"||r=="span"){var i=t.children("."+this._inlineClass);i.children().addClass("ui-state-disabled"),i.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)}this._disabledInputs=$.map(this._disabledInputs,function(t){return t==e?null:t}),this._disabledInputs[this._disabledInputs.length]=e},_isDisabledDatepicker:function(e){if(!e)return!1;for(var t=0;t<this._disabledInputs.length;t++)if(this._disabledInputs[t]==e)return!0;return!1},_getInst:function(e){try{return $.data(e,PROP_NAME)}catch(t){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(e,t,n){var r=this._getInst(e);if(arguments.length==2&&typeof t=="string")return t=="defaults"?$.extend({},$.datepicker._defaults):r?t=="all"?$.extend({},r.settings):this._get(r,t):null;var i=t||{};typeof t=="string"&&(i={},i[t]=n);if(r){this._curInst==r&&this._hideDatepicker();var s=this._getDateDatepicker(e,!0),o=this._getMinMaxDate(r,"min"),u=this._getMinMaxDate(r,"max");extendRemove(r.settings,i),o!==null&&i.dateFormat!==undefined&&i.minDate===undefined&&(r.settings.minDate=this._formatDate(r,o)),u!==null&&i.dateFormat!==undefined&&i.maxDate===undefined&&(r.settings.maxDate=this._formatDate(r,u)),this._attachments($(e),r),this._autoSize(r),this._setDate(r,s),this._updateAlternate(r),this._updateDatepicker(r)}},_changeDatepicker:function(e,t,n){this._optionDatepicker(e,t,n)},_refreshDatepicker:function(e){var t=this._getInst(e);t&&this._updateDatepicker(t)},_setDateDatepicker:function(e,t){var n=this._getInst(e);n&&(this._setDate(n,t),this._updateDatepicker(n),this._updateAlternate(n))},_getDateDatepicker:function(e,t){var n=this._getInst(e);return n&&!n.inline&&this._setDateFromField(n,t),n?this._getDate(n):null},_doKeyDown:function(e){var t=$.datepicker._getInst(e.target),n=!0,r=t.dpDiv.is(".ui-datepicker-rtl");t._keyEvent=!0;if($.datepicker._datepickerShowing)switch(e.keyCode){case 9:$.datepicker._hideDatepicker(),n=!1;break;case 13:var i=$("td."+$.datepicker._dayOverClass+":not(."+$.datepicker._currentClass+")",t.dpDiv);i[0]&&$.datepicker._selectDay(e.target,t.selectedMonth,t.selectedYear,i[0]);var s=$.datepicker._get(t,"onSelect");if(s){var o=$.datepicker._formatDate(t);s.apply(t.input?t.input[0]:null,[o,t])}else $.datepicker._hideDatepicker();return!1;case 27:$.datepicker._hideDatepicker();break;case 33:$.datepicker._adjustDate(e.target,e.ctrlKey?-$.datepicker._get(t,"stepBigMonths"):-$.datepicker._get(t,"stepMonths"),"M");break;case 34:$.datepicker._adjustDate(e.target,e.ctrlKey?+$.datepicker._get(t,"stepBigMonths"):+$.datepicker._get(t,"stepMonths"),"M");break;case 35:(e.ctrlKey||e.metaKey)&&$.datepicker._clearDate(e.target),n=e.ctrlKey||e.metaKey;break;case 36:(e.ctrlKey||e.metaKey)&&$.datepicker._gotoToday(e.target),n=e.ctrlKey||e.metaKey;break;case 37:(e.ctrlKey||e.metaKey)&&$.datepicker._adjustDate(e.target,r?1:-1,"D"),n=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&$.datepicker._adjustDate(e.target,e.ctrlKey?-$.datepicker._get(t,"stepBigMonths"):-$.datepicker._get(t,"stepMonths"),"M");break;case 38:(e.ctrlKey||e.metaKey)&&$.datepicker._adjustDate(e.target,-7,"D"),n=e.ctrlKey||e.metaKey;break;case 39:(e.ctrlKey||e.metaKey)&&$.datepicker._adjustDate(e.target,r?-1:1,"D"),n=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&$.datepicker._adjustDate(e.target,e.ctrlKey?+$.datepicker._get(t,"stepBigMonths"):+$.datepicker._get(t,"stepMonths"),"M");break;case 40:(e.ctrlKey||e.metaKey)&&$.datepicker._adjustDate(e.target,7,"D"),n=e.ctrlKey||e.metaKey;break;default:n=!1}else e.keyCode==36&&e.ctrlKey?$.datepicker._showDatepicker(this):n=!1;n&&(e.preventDefault(),e.stopPropagation())},_doKeyPress:function(e){var t=$.datepicker._getInst(e.target);if($.datepicker._get(t,"constrainInput")){var n=$.datepicker._possibleChars($.datepicker._get(t,"dateFormat")),r=String.fromCharCode(e.charCode==undefined?e.keyCode:e.charCode);return e.ctrlKey||e.metaKey||r<" "||!n||n.indexOf(r)>-1}},_doKeyUp:function(e){var t=$.datepicker._getInst(e.target);if(t.input.val()!=t.lastVal)try{var n=$.datepicker.parseDate($.datepicker._get(t,"dateFormat"),t.input?t.input.val():null,$.datepicker._getFormatConfig(t));n&&($.datepicker._setDateFromField(t),$.datepicker._updateAlternate(t),$.datepicker._updateDatepicker(t))}catch(r){$.datepicker.log(r)}return!0},_showDatepicker:function(e){e=e.target||e,e.nodeName.toLowerCase()!="input"&&(e=$("input",e.parentNode)[0]);if($.datepicker._isDisabledDatepicker(e)||$.datepicker._lastInput==e)return;var t=$.datepicker._getInst(e);$.datepicker._curInst&&$.datepicker._curInst!=t&&($.datepicker._curInst.dpDiv.stop(!0,!0),t&&$.datepicker._datepickerShowing&&$.datepicker._hideDatepicker($.datepicker._curInst.input[0]));var n=$.datepicker._get(t,"beforeShow"),r=n?n.apply(e,[e,t]):{};if(r===!1)return;extendRemove(t.settings,r),t.lastVal=null,$.datepicker._lastInput=e,$.datepicker._setDateFromField(t),$.datepicker._inDialog&&(e.value=""),$.datepicker._pos||($.datepicker._pos=$.datepicker._findPos(e),$.datepicker._pos[1]+=e.offsetHeight);var i=!1;$(e).parents().each(function(){return i|=$(this).css("position")=="fixed",!i});var s={left:$.datepicker._pos[0],top:$.datepicker._pos[1]};$.datepicker._pos=null,t.dpDiv.empty(),t.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),$.datepicker._updateDatepicker(t),s=$.datepicker._checkOffset(t,s,i),t.dpDiv.css({position:$.datepicker._inDialog&&$.blockUI?"static":i?"fixed":"absolute",display:"none",left:s.left+"px",top:s.top+"px"});if(!t.inline){var o=$.datepicker._get(t,"showAnim"),u=$.datepicker._get(t,"duration"),a=function(){var e=t.dpDiv.find("iframe.ui-datepicker-cover");if(!!e.length){var n=$.datepicker._getBorders(t.dpDiv);e.css({left:-n[0],top:-n[1],width:t.dpDiv.outerWidth(),height:t.dpDiv.outerHeight()})}};t.dpDiv.zIndex($(e).zIndex()+1),$.datepicker._datepickerShowing=!0,$.effects&&($.effects.effect[o]||$.effects[o])?t.dpDiv.show(o,$.datepicker._get(t,"showOptions"),u,a):t.dpDiv[o||"show"](o?u:null,a),(!o||!u)&&a(),t.input.is(":visible")&&!t.input.is(":disabled")&&t.input.focus(),$.datepicker._curInst=t}},_updateDatepicker:function(e){this.maxRows=4;var t=$.datepicker._getBorders(e.dpDiv);instActive=e,e.dpDiv.empty().append(this._generateHTML(e)),this._attachHandlers(e);var n=e.dpDiv.find("iframe.ui-datepicker-cover");!n.length||n.css({left:-t[0],top:-t[1],width:e.dpDiv.outerWidth(),height:e.dpDiv.outerHeight()}),e.dpDiv.find("."+this._dayOverClass+" a").mouseover();var r=this._getNumberOfMonths(e),i=r[1],s=17;e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),i>1&&e.dpDiv.addClass("ui-datepicker-multi-"+i).css("width",s*i+"em"),e.dpDiv[(r[0]!=1||r[1]!=1?"add":"remove")+"Class"]("ui-datepicker-multi"),e.dpDiv[(this._get(e,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),e==$.datepicker._curInst&&$.datepicker._datepickerShowing&&e.input&&e.input.is(":visible")&&!e.input.is(":disabled")&&e.input[0]!=document.activeElement&&e.input.focus();if(e.yearshtml){var o=e.yearshtml;setTimeout(function(){o===e.yearshtml&&e.yearshtml&&e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml),o=e.yearshtml=null},0)}},_getBorders:function(e){var t=function(e){return{thin:1,medium:2,thick:3}[e]||e};return[parseFloat(t(e.css("border-left-width"))),parseFloat(t(e.css("border-top-width")))]},_checkOffset:function(e,t,n){var r=e.dpDiv.outerWidth(),i=e.dpDiv.outerHeight(),s=e.input?e.input.outerWidth():0,o=e.input?e.input.outerHeight():0,u=document.documentElement.clientWidth+(n?0:$(document).scrollLeft()),a=document.documentElement.clientHeight+(n?0:$(document).scrollTop());return t.left-=this._get(e,"isRTL")?r-s:0,t.left-=n&&t.left==e.input.offset().left?$(document).scrollLeft():0,t.top-=n&&t.top==e.input.offset().top+o?$(document).scrollTop():0,t.left-=Math.min(t.left,t.left+r>u&&u>r?Math.abs(t.left+r-u):0),t.top-=Math.min(t.top,t.top+i>a&&a>i?Math.abs(i+o):0),t},_findPos:function(e){var t=this._getInst(e),n=this._get(t,"isRTL");while(e&&(e.type=="hidden"||e.nodeType!=1||$.expr.filters.hidden(e)))e=e[n?"previousSibling":"nextSibling"];var r=$(e).offset();return[r.left,r.top]},_hideDatepicker:function(e){var t=this._curInst;if(!t||e&&t!=$.data(e,PROP_NAME))return;if(this._datepickerShowing){var n=this._get(t,"showAnim"),r=this._get(t,"duration"),i=function(){$.datepicker._tidyDialog(t)};$.effects&&($.effects.effect[n]||$.effects[n])?t.dpDiv.hide(n,$.datepicker._get(t,"showOptions"),r,i):t.dpDiv[n=="slideDown"?"slideUp":n=="fadeIn"?"fadeOut":"hide"](n?r:null,i),n||i(),this._datepickerShowing=!1;var s=this._get(t,"onClose");s&&s.apply(t.input?t.input[0]:null,[t.input?t.input.val():"",t]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),$.blockUI&&($.unblockUI(),$("body").append(this.dpDiv))),this._inDialog=!1}},_tidyDialog:function(e){e.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},_checkExternalClick:function(e){if(!$.datepicker._curInst)return;var t=$(e.target),n=$.datepicker._getInst(t[0]);(t[0].id!=$.datepicker._mainDivId&&t.parents("#"+$.datepicker._mainDivId).length==0&&!t.hasClass($.datepicker.markerClassName)&&!t.closest("."+$.datepicker._triggerClass).length&&$.datepicker._datepickerShowing&&(!$.datepicker._inDialog||!$.blockUI)||t.hasClass($.datepicker.markerClassName)&&$.datepicker._curInst!=n)&&$.datepicker._hideDatepicker()},_adjustDate:function(e,t,n){var r=$(e),i=this._getInst(r[0]);if(this._isDisabledDatepicker(r[0]))return;this._adjustInstDate(i,t+(n=="M"?this._get(i,"showCurrentAtPos"):0),n),this._updateDatepicker(i)},_gotoToday:function(e){var t=$(e),n=this._getInst(t[0]);if(this._get(n,"gotoCurrent")&&n.currentDay)n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear;else{var r=new Date;n.selectedDay=r.getDate(),n.drawMonth=n.selectedMonth=r.getMonth(),n.drawYear=n.selectedYear=r.getFullYear()}this._notifyChange(n),this._adjustDate(t)},_selectMonthYear:function(e,t,n){var r=$(e),i=this._getInst(r[0]);i["selected"+(n=="M"?"Month":"Year")]=i["draw"+(n=="M"?"Month":"Year")]=parseInt(t.options[t.selectedIndex].value,10),this._notifyChange(i),this._adjustDate(r)},_selectDay:function(e,t,n,r){var i=$(e);if($(r).hasClass(this._unselectableClass)||this._isDisabledDatepicker(i[0]))return;var s=this._getInst(i[0]);s.selectedDay=s.currentDay=$("a",r).html(),s.selectedMonth=s.currentMonth=t,s.selectedYear=s.currentYear=n,this._selectDate(e,this._formatDate(s,s.currentDay,s.currentMonth,s.currentYear))},_clearDate:function(e){var t=$(e),n=this._getInst(t[0]);this._selectDate(t,"")},_selectDate:function(e,t){var n=$(e),r=this._getInst(n[0]);t=t!=null?t:this._formatDate(r),r.input&&r.input.val(t),this._updateAlternate(r);var i=this._get(r,"onSelect");i?i.apply(r.input?r.input[0]:null,[t,r]):r.input&&r.input.trigger("change"),r.inline?this._updateDatepicker(r):(this._hideDatepicker(),this._lastInput=r.input[0],typeof r.input[0]!="object"&&r.input.focus(),this._lastInput=null)},_updateAlternate:function(e){var t=this._get(e,"altField");if(t){var n=this._get(e,"altFormat")||this._get(e,"dateFormat"),r=this._getDate(e),i=this.formatDate(n,r,this._getFormatConfig(e));$(t).each(function(){$(this).val(i)})}},noWeekends:function(e){var t=e.getDay();return[t>0&&t<6,""]},iso8601Week:function(e){var t=new Date(e.getTime());t.setDate(t.getDate()+4-(t.getDay()||7));var n=t.getTime();return t.setMonth(0),t.setDate(1),Math.floor(Math.round((n-t)/864e5)/7)+1},parseDate:function(e,t,n){if(e==null||t==null)throw"Invalid arguments";t=typeof t=="object"?t.toString():t+"";if(t=="")return null;var r=(n?n.shortYearCutoff:null)||this._defaults.shortYearCutoff;r=typeof r!="string"?r:(new Date).getFullYear()%100+parseInt(r,10);var i=(n?n.dayNamesShort:null)||this._defaults.dayNamesShort,s=(n?n.dayNames:null)||this._defaults.dayNames,o=(n?n.monthNamesShort:null)||this._defaults.monthNamesShort,u=(n?n.monthNames:null)||this._defaults.monthNames,a=-1,f=-1,l=-1,c=-1,h=!1,p=function(t){var n=y+1<e.length&&e.charAt(y+1)==t;return n&&y++,n},d=function(e){var n=p(e),r=e=="@"?14:e=="!"?20:e=="y"&&n?4:e=="o"?3:2,i=new RegExp("^\\d{1,"+r+"}"),s=t.substring(g).match(i);if(!s)throw"Missing number at position "+g;return g+=s[0].length,parseInt(s[0],10)},v=function(e,n,r){var i=$.map(p(e)?r:n,function(e,t){return[[t,e]]}).sort(function(e,t){return-(e[1].length-t[1].length)}),s=-1;$.each(i,function(e,n){var r=n[1];if(t.substr(g,r.length).toLowerCase()==r.toLowerCase())return s=n[0],g+=r.length,!1});if(s!=-1)return s+1;throw"Unknown name at position "+g},m=function(){if(t.charAt(g)!=e.charAt(y))throw"Unexpected literal at position "+g;g++},g=0;for(var y=0;y<e.length;y++)if(h)e.charAt(y)=="'"&&!p("'")?h=!1:m();else switch(e.charAt(y)){case"d":l=d("d");break;case"D":v("D",i,s);break;case"o":c=d("o");break;case"m":f=d("m");break;case"M":f=v("M",o,u);break;case"y":a=d("y");break;case"@":var b=new Date(d("@"));a=b.getFullYear(),f=b.getMonth()+1,l=b.getDate();break;case"!":var b=new Date((d("!")-this._ticksTo1970)/1e4);a=b.getFullYear(),f=b.getMonth()+1,l=b.getDate();break;case"'":p("'")?m():h=!0;break;default:m()}if(g<t.length){var w=t.substr(g);if(!/^\s+/.test(w))throw"Extra/unparsed characters found in date: "+w}a==-1?a=(new Date).getFullYear():a<100&&(a+=(new Date).getFullYear()-(new Date).getFullYear()%100+(a<=r?0:-100));if(c>-1){f=1,l=c;do{var E=this._getDaysInMonth(a,f-1);if(l<=E)break;f++,l-=E}while(!0)}var b=this._daylightSavingAdjust(new Date(a,f-1,l));if(b.getFullYear()!=a||b.getMonth()+1!=f||b.getDate()!=l)throw"Invalid date";return b},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*24*60*60*1e7,formatDate:function(e,t,n){if(!t)return"";var r=(n?n.dayNamesShort:null)||this._defaults.dayNamesShort,i=(n?n.dayNames:null)||this._defaults.dayNames,s=(n?n.monthNamesShort:null)||this._defaults.monthNamesShort,o=(n?n.monthNames:null)||this._defaults.monthNames,u=function(t){var n=h+1<e.length&&e.charAt(h+1)==t;return n&&h++,n},a=function(e,t,n){var r=""+t;if(u(e))while(r.length<n)r="0"+r;return r},f=function(e,t,n,r){return u(e)?r[t]:n[t]},l="",c=!1;if(t)for(var h=0;h<e.length;h++)if(c)e.charAt(h)=="'"&&!u("'")?c=!1:l+=e.charAt(h);else switch(e.charAt(h)){case"d":l+=a("d",t.getDate(),2);break;case"D":l+=f("D",t.getDay(),r,i);break;case"o":l+=a("o",Math.round(((new Date(t.getFullYear(),t.getMonth(),t.getDate())).getTime()-(new Date(t.getFullYear(),0,0)).getTime())/864e5),3);break;case"m":l+=a("m",t.getMonth()+1,2);break;case"M":l+=f("M",t.getMonth(),s,o);break;case"y":l+=u("y")?t.getFullYear():(t.getYear()%100<10?"0":"")+t.getYear()%100;break;case"@":l+=t.getTime();break;case"!":l+=t.getTime()*1e4+this._ticksTo1970;break;case"'":u("'")?l+="'":c=!0;break;default:l+=e.charAt(h)}return l},_possibleChars:function(e){var t="",n=!1,r=function(t){var n=i+1<e.length&&e.charAt(i+1)==t;return n&&i++,n};for(var i=0;i<e.length;i++)if(n)e.charAt(i)=="'"&&!r("'")?n=!1:t+=e.charAt(i);else switch(e.charAt(i)){case"d":case"m":case"y":case"@":t+="0123456789";break;case"D":case"M":return null;case"'":r("'")?t+="'":n=!0;break;default:t+=e.charAt(i)}return t},_get:function(e,t){return e.settings[t]!==undefined?e.settings[t]:this._defaults[t]},_setDateFromField:function(e,t){if(e.input.val()==e.lastVal)return;var n=this._get(e,"dateFormat"),r=e.lastVal=e.input?e.input.val():null,i,s;i=s=this._getDefaultDate(e);var o=this._getFormatConfig(e);try{i=this.parseDate(n,r,o)||s}catch(u){this.log(u),r=t?"":r}e.selectedDay=i.getDate(),e.drawMonth=e.selectedMonth=i.getMonth(),e.drawYear=e.selectedYear=i.getFullYear(),e.currentDay=r?i.getDate():0,e.currentMonth=r?i.getMonth():0,e.currentYear=r?i.getFullYear():0,this._adjustInstDate(e)},_getDefaultDate:function(e){return this._restrictMinMax(e,this._determineDate(e,this._get(e,"defaultDate"),new Date))},_determineDate:function(e,t,n){var r=function(e){var t=new Date;return t.setDate(t.getDate()+e),t},i=function(t){try{return $.datepicker.parseDate($.datepicker._get(e,"dateFormat"),t,$.datepicker._getFormatConfig(e))}catch(n){}var r=(t.toLowerCase().match(/^c/)?$.datepicker._getDate(e):null)||new Date,i=r.getFullYear(),s=r.getMonth(),o=r.getDate(),u=/([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,a=u.exec(t);while(a){switch(a[2]||"d"){case"d":case"D":o+=parseInt(a[1],10);break;case"w":case"W":o+=parseInt(a[1],10)*7;break;case"m":case"M":s+=parseInt(a[1],10),o=Math.min(o,$.datepicker._getDaysInMonth(i,s));break;case"y":case"Y":i+=parseInt(a[1],10),o=Math.min(o,$.datepicker._getDaysInMonth(i,s))}a=u.exec(t)}return new Date(i,s,o)},s=t==null||t===""?n:typeof t=="string"?i(t):typeof t=="number"?isNaN(t)?n:r(t):new Date(t.getTime());return s=s&&s.toString()=="Invalid Date"?n:s,s&&(s.setHours(0),s.setMinutes(0),s.setSeconds(0),s.setMilliseconds(0)),this._daylightSavingAdjust(s)},_daylightSavingAdjust:function(e){return e?(e.setHours(e.getHours()>12?e.getHours()+2:0),e):null},_setDate:function(e,t,n){var r=!t,i=e.selectedMonth,s=e.selectedYear,o=this._restrictMinMax(e,this._determineDate(e,t,new Date));e.selectedDay=e.currentDay=o.getDate(),e.drawMonth=e.selectedMonth=e.currentMonth=o.getMonth(),e.drawYear=e.selectedYear=e.currentYear=o.getFullYear(),(i!=e.selectedMonth||s!=e.selectedYear)&&!n&&this._notifyChange(e),this._adjustInstDate(e),e.input&&e.input.val(r?"":this._formatDate(e))},_getDate:function(e){var t=!e.currentYear||e.input&&e.input.val()==""?null:this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return t},_attachHandlers:function(e){var t=this._get(e,"stepMonths"),n="#"+e.id.replace(/\\\\/g,"\\");e.dpDiv.find("[data-handler]").map(function(){var e={prev:function(){window["DP_jQuery_"+dpuuid].datepicker._adjustDate(n,-t,"M")},next:function(){window["DP_jQuery_"+dpuuid].datepicker._adjustDate(n,+t,"M")},hide:function(){window["DP_jQuery_"+dpuuid].datepicker._hideDatepicker()},today:function(){window["DP_jQuery_"+dpuuid].datepicker._gotoToday(n)},selectDay:function(){return window["DP_jQuery_"+dpuuid].datepicker._selectDay(n,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return window["DP_jQuery_"+dpuuid].datepicker._selectMonthYear(n,this,"M"),!1},selectYear:function(){return window["DP_jQuery_"+dpuuid].datepicker._selectMonthYear(n,this,"Y"),!1}};$(this).bind(this.getAttribute("data-event"),e[this.getAttribute("data-handler")])})},_generateHTML:function(e){var t=new Date;t=this._daylightSavingAdjust(new Date(t.getFullYear(),t.getMonth(),t.getDate()));var n=this._get(e,"isRTL"),r=this._get(e,"showButtonPanel"),i=this._get(e,"hideIfNoPrevNext"),s=this._get(e,"navigationAsDateFormat"),o=this._getNumberOfMonths(e),u=this._get(e,"showCurrentAtPos"),a=this._get(e,"stepMonths"),f=o[0]!=1||o[1]!=1,l=this._daylightSavingAdjust(e.currentDay?new Date(e.currentYear,e.currentMonth,e.currentDay):new Date(9999,9,9)),c=this._getMinMaxDate(e,"min"),h=this._getMinMaxDate(e,"max"),p=e.drawMonth-u,d=e.drawYear;p<0&&(p+=12,d--);if(h){var v=this._daylightSavingAdjust(new Date(h.getFullYear(),h.getMonth()-o[0]*o[1]+1,h.getDate()));v=c&&v<c?c:v;while(this._daylightSavingAdjust(new Date(d,p,1))>v)p--,p<0&&(p=11,d--)}e.drawMonth=p,e.drawYear=d;var m=this._get(e,"prevText");m=s?this.formatDate(m,this._daylightSavingAdjust(new Date(d,p-a,1)),this._getFormatConfig(e)):m;var g=this._canAdjustMonth(e,-1,d,p)?'<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click" title="'+m+'"><span class="ui-icon ui-icon-circle-triangle-'+(n?"e":"w")+'">'+m+"</span></a>":i?"":'<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+m+'"><span class="ui-icon ui-icon-circle-triangle-'+(n?"e":"w")+'">'+m+"</span></a>",y=this._get(e,"nextText");y=s?this.formatDate(y,this._daylightSavingAdjust(new Date(d,p+a,1)),this._getFormatConfig(e)):y;var b=this._canAdjustMonth(e,1,d,p)?'<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click" title="'+y+'"><span class="ui-icon ui-icon-circle-triangle-'+(n?"w":"e")+'">'+y+"</span></a>":i?"":'<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+y+'"><span class="ui-icon ui-icon-circle-triangle-'+(n?"w":"e")+'">'+y+"</span></a>",w=this._get(e,"currentText"),E=this._get(e,"gotoCurrent")&&e.currentDay?l:t;w=s?this.formatDate(w,E,this._getFormatConfig(e)):w;var S=e.inline?"":'<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">'+this._get(e,"closeText")+"</button>",x=r?'<div class="ui-datepicker-buttonpane ui-widget-content">'+(n?S:"")+(this._isInRange(e,E)?'<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click">'+w+"</button>":"")+(n?"":S)+"</div>":"",T=parseInt(this._get(e,"firstDay"),10);T=isNaN(T)?0:T;var N=this._get(e,"showWeek"),C=this._get(e,"dayNames"),k=this._get(e,"dayNamesShort"),L=this._get(e,"dayNamesMin"),A=this._get(e,"monthNames"),O=this._get(e,"monthNamesShort"),M=this._get(e,"beforeShowDay"),_=this._get(e,"showOtherMonths"),D=this._get(e,"selectOtherMonths"),P=this._get(e,"calculateWeek")||this.iso8601Week,H=this._getDefaultDate(e),B="";for(var j=0;j<o[0];j++){var F="";this.maxRows=4;for(var I=0;I<o[1];I++){var q=this._daylightSavingAdjust(new Date(d,p,e.selectedDay)),R=" ui-corner-all",U="";if(f){U+='<div class="ui-datepicker-group';if(o[1]>1)switch(I){case 0:U+=" ui-datepicker-group-first",R=" ui-corner-"+(n?"right":"left");break;case o[1]-1:U+=" ui-datepicker-group-last",R=" ui-corner-"+(n?"left":"right");break;default:U+=" ui-datepicker-group-middle",R=""}U+='">'}U+='<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix'+R+'">'+(/all|left/.test(R)&&j==0?n?b:g:"")+(/all|right/.test(R)&&j==0?n?g:b:"")+this._generateMonthYearHeader(e,p,d,c,h,j>0||I>0,A,O)+'</div><table class="ui-datepicker-calendar"><thead>'+"<tr>";var z=N?'<th class="ui-datepicker-week-col">'+this._get(e,"weekHeader")+"</th>":"";for(var W=0;W<7;W++){var X=(W+T)%7;z+="<th"+((W+T+6)%7>=5?' class="ui-datepicker-week-end"':"")+">"+'<span title="'+C[X]+'">'+L[X]+"</span></th>"}U+=z+"</tr></thead><tbody>";var V=this._getDaysInMonth(d,p);d==e.selectedYear&&p==e.selectedMonth&&(e.selectedDay=Math.min(e.selectedDay,V));var J=(this._getFirstDayOfMonth(d,p)-T+7)%7,K=Math.ceil((J+V)/7),Q=f?this.maxRows>K?this.maxRows:K:K;this.maxRows=Q;var G=this._daylightSavingAdjust(new Date(d,p,1-J));for(var Y=0;Y<Q;Y++){U+="<tr>";var Z=N?'<td class="ui-datepicker-week-col">'+this._get(e,"calculateWeek")(G)+"</td>":"";for(var W=0;W<7;W++){var et=M?M.apply(e.input?e.input[0]:null,[G]):[!0,""],tt=G.getMonth()!=p,nt=tt&&!D||!et[0]||c&&G<c||h&&G>h;Z+='<td class="'+((W+T+6)%7>=5?" ui-datepicker-week-end":"")+(tt?" ui-datepicker-other-month":"")+(G.getTime()==q.getTime()&&p==e.selectedMonth&&e._keyEvent||H.getTime()==G.getTime()&&H.getTime()==q.getTime()?" "+this._dayOverClass:"")+(nt?" "+this._unselectableClass+" ui-state-disabled":"")+(tt&&!_?"":" "+et[1]+(G.getTime()==l.getTime()?" "+this._currentClass:"")+(G.getTime()==t.getTime()?" ui-datepicker-today":""))+'"'+((!tt||_)&&et[2]?' title="'+et[2]+'"':"")+(nt?"":' data-handler="selectDay" data-event="click" data-month="'+G.getMonth()+'" data-year="'+G.getFullYear()+'"')+">"+(tt&&!_?"&#xa0;":nt?'<span class="ui-state-default">'+G.getDate()+"</span>":'<a class="ui-state-default'+(G.getTime()==t.getTime()?" ui-state-highlight":"")+(G.getTime()==l.getTime()?" ui-state-active":"")+(tt?" ui-priority-secondary":"")+'" href="#">'+G.getDate()+"</a>")+"</td>",G.setDate(G.getDate()+1),G=this._daylightSavingAdjust(G)}U+=Z+"</tr>"}p++,p>11&&(p=0,d++),U+="</tbody></table>"+(f?"</div>"+(o[0]>0&&I==o[1]-1?'<div class="ui-datepicker-row-break"></div>':""):""),F+=U}B+=F}return B+=x+($.ui.ie6&&!e.inline?'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>':""),e._keyEvent=!1,B},_generateMonthYearHeader:function(e,t,n,r,i,s,o,u){var a=this._get(e,"changeMonth"),f=this._get(e,"changeYear"),l=this._get(e,"showMonthAfterYear"),c='<div class="ui-datepicker-title">',h="";if(s||!a)h+='<span class="ui-datepicker-month">'+o[t]+"</span>";else{var p=r&&r.getFullYear()==n,d=i&&i.getFullYear()==n;h+='<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">';for(var v=0;v<12;v++)(!p||v>=r.getMonth())&&(!d||v<=i.getMonth())&&(h+='<option value="'+v+'"'+(v==t?' selected="selected"':"")+">"+u[v]+"</option>");h+="</select>"}l||(c+=h+(s||!a||!f?"&#xa0;":""));if(!e.yearshtml){e.yearshtml="";if(s||!f)c+='<span class="ui-datepicker-year">'+n+"</span>";else{var m=this._get(e,"yearRange").split(":"),g=(new Date).getFullYear(),y=function(e){var t=e.match(/c[+-].*/)?n+parseInt(e.substring(1),10):e.match(/[+-].*/)?g+parseInt(e,10):parseInt(e,10);return isNaN(t)?g:t},b=y(m[0]),w=Math.max(b,y(m[1]||""));b=r?Math.max(b,r.getFullYear()):b,w=i?Math.min(w,i.getFullYear()):w,e.yearshtml+='<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">';for(;b<=w;b++)e.yearshtml+='<option value="'+b+'"'+(b==n?' selected="selected"':"")+">"+b+"</option>";e.yearshtml+="</select>",c+=e.yearshtml,e.yearshtml=null}}return c+=this._get(e,"yearSuffix"),l&&(c+=(s||!a||!f?"&#xa0;":"")+h),c+="</div>",c},_adjustInstDate:function(e,t,n){var r=e.drawYear+(n=="Y"?t:0),i=e.drawMonth+(n=="M"?t:0),s=Math.min(e.selectedDay,this._getDaysInMonth(r,i))+(n=="D"?t:0),o=this._restrictMinMax(e,this._daylightSavingAdjust(new Date(r,i,s)));e.selectedDay=o.getDate(),e.drawMonth=e.selectedMonth=o.getMonth(),e.drawYear=e.selectedYear=o.getFullYear(),(n=="M"||n=="Y")&&this._notifyChange(e)},_restrictMinMax:function(e,t){var n=this._getMinMaxDate(e,"min"),r=this._getMinMaxDate(e,"max"),i=n&&t<n?n:t;return i=r&&i>r?r:i,i},_notifyChange:function(e){var t=this._get(e,"onChangeMonthYear");t&&t.apply(e.input?e.input[0]:null,[e.selectedYear,e.selectedMonth+1,e])},_getNumberOfMonths:function(e){var t=this._get(e,"numberOfMonths");return t==null?[1,1]:typeof t=="number"?[1,t]:t},_getMinMaxDate:function(e,t){return this._determineDate(e,this._get(e,t+"Date"),null)},_getDaysInMonth:function(e,t){return 32-this._daylightSavingAdjust(new Date(e,t,32)).getDate()},_getFirstDayOfMonth:function(e,t){return(new Date(e,t,1)).getDay()},_canAdjustMonth:function(e,t,n,r){var i=this._getNumberOfMonths(e),s=this._daylightSavingAdjust(new Date(n,r+(t<0?t:i[0]*i[1]),1));return t<0&&s.setDate(this._getDaysInMonth(s.getFullYear(),s.getMonth())),this._isInRange(e,s)},_isInRange:function(e,t){var n=this._getMinMaxDate(e,"min"),r=this._getMinMaxDate(e,"max");return(!n||t.getTime()>=n.getTime())&&(!r||t.getTime()<=r.getTime())},_getFormatConfig:function(e){var t=this._get(e,"shortYearCutoff");return t=typeof t!="string"?t:(new Date).getFullYear()%100+parseInt(t,10),{shortYearCutoff:t,dayNamesShort:this._get(e,"dayNamesShort"),dayNames:this._get(e,"dayNames"),monthNamesShort:this._get(e,"monthNamesShort"),monthNames:this._get(e,"monthNames")}},_formatDate:function(e,t,n,r){t||(e.currentDay=e.selectedDay,e.currentMonth=e.selectedMonth,e.currentYear=e.selectedYear);var i=t?typeof t=="object"?t:this._daylightSavingAdjust(new Date(r,n,t)):this._daylightSavingAdjust(new Date(e.currentYear,e.currentMonth,e.currentDay));return this.formatDate(this._get(e,"dateFormat"),i,this._getFormatConfig(e))}}),$.fn.datepicker=function(e){if(!this.length)return this;$.datepicker.initialized||($(document).mousedown($.datepicker._checkExternalClick).find(document.body).append($.datepicker.dpDiv),$.datepicker.initialized=!0);var t=Array.prototype.slice.call(arguments,1);return typeof e!="string"||e!="isDisabled"&&e!="getDate"&&e!="widget"?e=="option"&&arguments.length==2&&typeof arguments[1]=="string"?$.datepicker["_"+e+"Datepicker"].apply($.datepicker,[this[0]].concat(t)):this.each(function(){typeof e=="string"?$.datepicker["_"+e+"Datepicker"].apply($.datepicker,[this].concat(t)):$.datepicker._attachDatepicker(this,e)}):$.datepicker["_"+e+"Datepicker"].apply($.datepicker,[this[0]].concat(t))},$.datepicker=new Datepicker,$.datepicker.initialized=!1,$.datepicker.uuid=(new Date).getTime(),$.datepicker.version="1.9.1",window["DP_jQuery_"+dpuuid]=$})(jQuery);(function(e,t){var n="ui-dialog ui-widget ui-widget-content ui-corner-all ",r={buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},i={maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0};e.widget("ui.dialog",{version:"1.9.1",options:{autoOpen:!0,buttons:{},closeOnEscape:!0,closeText:"close",dialogClass:"",draggable:!0,hide:null,height:"auto",maxHeight:!1,maxWidth:!1,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(t){var n=e(this).css(t).offset().top;n<0&&e(this).css("top",t.top-n)}},resizable:!0,show:null,stack:!0,title:"",width:300,zIndex:1e3},_create:function(){this.originalTitle=this.element.attr("title"),typeof this.originalTitle!="string"&&(this.originalTitle=""),this.oldPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.options.title=this.options.title||this.originalTitle;var t=this,r=this.options,i=r.title||"&#160;",s,o,u,a,f;s=(this.uiDialog=e("<div>")).addClass(n+r.dialogClass).css({display:"none",outline:0,zIndex:r.zIndex}).attr("tabIndex",-1).keydown(function(n){r.closeOnEscape&&!n.isDefaultPrevented()&&n.keyCode&&n.keyCode===e.ui.keyCode.ESCAPE&&(t.close(n),n.preventDefault())}).mousedown(function(e){t.moveToTop(!1,e)}).appendTo("body"),this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(s),o=(this.uiDialogTitlebar=e("<div>")).addClass("ui-dialog-titlebar  ui-widget-header  ui-corner-all  ui-helper-clearfix").bind("mousedown",function(){s.focus()}).prependTo(s),u=e("<a href='#'></a>").addClass("ui-dialog-titlebar-close  ui-corner-all").attr("role","button").click(function(e){e.preventDefault(),t.close(e)}).appendTo(o),(this.uiDialogTitlebarCloseText=e("<span>")).addClass("ui-icon ui-icon-closethick").text(r.closeText).appendTo(u),a=e("<span>").uniqueId().addClass("ui-dialog-title").html(i).prependTo(o),f=(this.uiDialogButtonPane=e("<div>")).addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),(this.uiButtonSet=e("<div>")).addClass("ui-dialog-buttonset").appendTo(f),s.attr({role:"dialog","aria-labelledby":a.attr("id")}),o.find("*").add(o).disableSelection(),this._hoverable(u),this._focusable(u),r.draggable&&e.fn.draggable&&this._makeDraggable(),r.resizable&&e.fn.resizable&&this._makeResizable(),this._createButtons(r.buttons),this._isOpen=!1,e.fn.bgiframe&&s.bgiframe(),this._on(s,{keydown:function(t){if(!r.modal||t.keyCode!==e.ui.keyCode.TAB)return;var n=e(":tabbable",s),i=n.filter(":first"),o=n.filter(":last");if(t.target===o[0]&&!t.shiftKey)return i.focus(1),!1;if(t.target===i[0]&&t.shiftKey)return o.focus(1),!1}})},_init:function(){this.options.autoOpen&&this.open()},_destroy:function(){var e,t=this.oldPosition;this.overlay&&this.overlay.destroy(),this.uiDialog.hide(),this.element.removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body"),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),e=t.parent.children().eq(t.index),e.length&&e[0]!==this.element[0]?e.before(this.element):t.parent.append(this.element)},widget:function(){return this.uiDialog},close:function(t){var n=this,r,i;if(!this._isOpen)return;if(!1===this._trigger("beforeClose",t))return;return this._isOpen=!1,this.overlay&&this.overlay.destroy(),this.options.hide?this._hide(this.uiDialog,this.options.hide,function(){n._trigger("close",t)}):(this.uiDialog.hide(),this._trigger("close",t)),e.ui.dialog.overlay.resize(),this.options.modal&&(r=0,e(".ui-dialog").each(function(){this!==n.uiDialog[0]&&(i=e(this).css("z-index"),isNaN(i)||(r=Math.max(r,i)))}),e.ui.dialog.maxZ=r),this},isOpen:function(){return this._isOpen},moveToTop:function(t,n){var r=this.options,i;return r.modal&&!t||!r.stack&&!r.modal?this._trigger("focus",n):(r.zIndex>e.ui.dialog.maxZ&&(e.ui.dialog.maxZ=r.zIndex),this.overlay&&(e.ui.dialog.maxZ+=1,e.ui.dialog.overlay.maxZ=e.ui.dialog.maxZ,this.overlay.$el.css("z-index",e.ui.dialog.overlay.maxZ)),i={scrollTop:this.element.scrollTop(),scrollLeft:this.element.scrollLeft()},e.ui.dialog.maxZ+=1,this.uiDialog.css("z-index",e.ui.dialog.maxZ),this.element.attr(i),this._trigger("focus",n),this)},open:function(){if(this._isOpen)return;var t,n=this.options,r=this.uiDialog;return this._size(),this._position(n.position),r.show(n.show),this.overlay=n.modal?new e.ui.dialog.overlay(this):null,this.moveToTop(!0),t=this.element.find(":tabbable"),t.length||(t=this.uiDialogButtonPane.find(":tabbable"),t.length||(t=r)),t.eq(0).focus(),this._isOpen=!0,this._trigger("open"),this},_createButtons:function(t){var n=this,r=!1;this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),typeof t=="object"&&t!==null&&e.each(t,function(){return!(r=!0)}),r?(e.each(t,function(t,r){r=e.isFunction(r)?{click:r,text:t}:r;var i=e("<button type='button'></button>").attr(r,!0).unbind("click").click(function(){r.click.apply(n.element[0],arguments)}).appendTo(n.uiButtonSet);e.fn.button&&i.button()}),this.uiDialog.addClass("ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog)):this.uiDialog.removeClass("ui-dialog-buttons")},_makeDraggable:function(){function r(e){return{position:e.position,offset:e.offset}}var t=this,n=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(n,i){e(this).addClass("ui-dialog-dragging"),t._trigger("dragStart",n,r(i))},drag:function(e,n){t._trigger("drag",e,r(n))},stop:function(i,s){n.position=[s.position.left-t.document.scrollLeft(),s.position.top-t.document.scrollTop()],e(this).removeClass("ui-dialog-dragging"),t._trigger("dragStop",i,r(s)),e.ui.dialog.overlay.resize()}})},_makeResizable:function(n){function u(e){return{originalPosition:e.originalPosition,originalSize:e.originalSize,position:e.position,size:e.size}}n=n===t?this.options.resizable:n;var r=this,i=this.options,s=this.uiDialog.css("position"),o=typeof n=="string"?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:i.maxWidth,maxHeight:i.maxHeight,minWidth:i.minWidth,minHeight:this._minHeight(),handles:o,start:function(t,n){e(this).addClass("ui-dialog-resizing"),r._trigger("resizeStart",t,u(n))},resize:function(e,t){r._trigger("resize",e,u(t))},stop:function(t,n){e(this).removeClass("ui-dialog-resizing"),i.height=e(this).height(),i.width=e(this).width(),r._trigger("resizeStop",t,u(n)),e.ui.dialog.overlay.resize()}}).css("position",s).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")},_minHeight:function(){var e=this.options;return e.height==="auto"?e.minHeight:Math.min(e.minHeight,e.height)},_position:function(t){var n=[],r=[0,0],i;if(t){if(typeof t=="string"||typeof t=="object"&&"0"in t)n=t.split?t.split(" "):[t[0],t[1]],n.length===1&&(n[1]=n[0]),e.each(["left","top"],function(e,t){+n[e]===n[e]&&(r[e]=n[e],n[e]=t)}),t={my:n[0]+(r[0]<0?r[0]:"+"+r[0])+" "+n[1]+(r[1]<0?r[1]:"+"+r[1]),at:n.join(" ")};t=e.extend({},e.ui.dialog.prototype.options.position,t)}else t=e.ui.dialog.prototype.options.position;i=this.uiDialog.is(":visible"),i||this.uiDialog.show(),this.uiDialog.position(t),i||this.uiDialog.hide()},_setOptions:function(t){var n=this,s={},o=!1;e.each(t,function(e,t){n._setOption(e,t),e in r&&(o=!0),e in i&&(s[e]=t)}),o&&this._size(),this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option",s)},_setOption:function(t,r){var i,s,o=this.uiDialog;switch(t){case"buttons":this._createButtons(r);break;case"closeText":this.uiDialogTitlebarCloseText.text(""+r);break;case"dialogClass":o.removeClass(this.options.dialogClass).addClass(n+r);break;case"disabled":r?o.addClass("ui-dialog-disabled"):o.removeClass("ui-dialog-disabled");break;case"draggable":i=o.is(":data(draggable)"),i&&!r&&o.draggable("destroy"),!i&&r&&this._makeDraggable();break;case"position":this._position(r);break;case"resizable":s=o.is(":data(resizable)"),s&&!r&&o.resizable("destroy"),s&&typeof r=="string"&&o.resizable("option","handles",r),!s&&r!==!1&&this._makeResizable(r);break;case"title":e(".ui-dialog-title",this.uiDialogTitlebar).html(""+(r||"&#160;"))}this._super(t,r)},_size:function(){var t,n,r,i=this.options,s=this.uiDialog.is(":visible");this.element.show().css({width:"auto",minHeight:0,height:0}),i.minWidth>i.width&&(i.width=i.minWidth),t=this.uiDialog.css({height:"auto",width:i.width}).outerHeight(),n=Math.max(0,i.minHeight-t),i.height==="auto"?e.support.minHeight?this.element.css({minHeight:n,height:"auto"}):(this.uiDialog.show(),r=this.element.css("height","auto").height(),s||this.uiDialog.hide(),this.element.height(Math.max(r,n))):this.element.height(Math.max(i.height-t,0)),this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())}}),e.extend(e.ui.dialog,{uuid:0,maxZ:0,getTitleId:function(e){var t=e.attr("id");return t||(this.uuid+=1,t=this.uuid),"ui-dialog-title-"+t},overlay:function(t){this.$el=e.ui.dialog.overlay.create(t)}}),e.extend(e.ui.dialog.overlay,{instances:[],oldInstances:[],maxZ:0,events:e.map("focus,mousedown,mouseup,keydown,keypress,click".split(","),function(e){return e+".dialog-overlay"}).join(" "),create:function(t){this.instances.length===0&&(setTimeout(function(){e.ui.dialog.overlay.instances.length&&e(document).bind(e.ui.dialog.overlay.events,function(t){if(e(t.target).zIndex()<e.ui.dialog.overlay.maxZ)return!1})},1),e(window).bind("resize.dialog-overlay",e.ui.dialog.overlay.resize));var n=this.oldInstances.pop()||e("<div>").addClass("ui-widget-overlay");return e(document).bind("keydown.dialog-overlay",function(r){var i=e.ui.dialog.overlay.instances;i.length!==0&&i[i.length-1]===n&&t.options.closeOnEscape&&!r.isDefaultPrevented()&&r.keyCode&&r.keyCode===e.ui.keyCode.ESCAPE&&(t.close(r),r.preventDefault())}),n.appendTo(document.body).css({width:this.width(),height:this.height()}),e.fn.bgiframe&&n.bgiframe(),this.instances.push(n),n},destroy:function(t){var n=e.inArray(t,this.instances),r=0;n!==-1&&this.oldInstances.push(this.instances.splice(n,1)[0]),this.instances.length===0&&e([document,window]).unbind(".dialog-overlay"),t.height(0).width(0).remove(),e.each(this.instances,function(){r=Math.max(r,this.css("z-index"))}),this.maxZ=r},height:function(){var t,n;return e.ui.ie?(t=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),n=Math.max(document.documentElement.offsetHeight,document.body.offsetHeight),t<n?e(window).height()+"px":t+"px"):e(document).height()+"px"},width:function(){var t,n;return e.ui.ie?(t=Math.max(document.documentElement.scrollWidth,document.body.scrollWidth),n=Math.max(document.documentElement.offsetWidth,document.body.offsetWidth),t<n?e(window).width()+"px":t+"px"):e(document).width()+"px"},resize:function(){var t=e([]);e.each(e.ui.dialog.overlay.instances,function(){t=t.add(this)}),t.css({width:0,height:0}).css({width:e.ui.dialog.overlay.width(),height:e.ui.dialog.overlay.height()})}}),e.extend(e.ui.dialog.overlay.prototype,{destroy:function(){e.ui.dialog.overlay.destroy(this.$el)}})})(jQuery);(function(e,t){e.widget("ui.draggable",e.ui.mouse,{version:"1.9.1",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1},_create:function(){this.options.helper=="original"&&!/^(?:r|a|f)/.test(this.element.css("position"))&&(this.element[0].style.position="relative"),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._mouseInit()},_destroy:function(){this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._mouseDestroy()},_mouseCapture:function(t){var n=this.options;return this.helper||n.disabled||e(t.target).is(".ui-resizable-handle")?!1:(this.handle=this._getHandle(t),this.handle?(e(n.iframeFix===!0?"iframe":n.iframeFix).each(function(){e('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1e3}).css(e(this).offset()).appendTo("body")}),!0):!1)},_mouseStart:function(t){var n=this.options;return this.helper=this._createHelper(t),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),e.ui.ddmanager&&(e.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(),this.offset=this.positionAbs=this.element.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.originalPosition=this.position=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,n.cursorAt&&this._adjustOffsetFromHelper(n.cursorAt),n.containment&&this._setContainment(),this._trigger("start",t)===!1?(this._clear(),!1):(this._cacheHelperProportions(),e.ui.ddmanager&&!n.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this._mouseDrag(t,!0),e.ui.ddmanager&&e.ui.ddmanager.dragStart(this,t),!0)},_mouseDrag:function(t,n){this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute");if(!n){var r=this._uiHash();if(this._trigger("drag",t,r)===!1)return this._mouseUp({}),!1;this.position=r.position}if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";return e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),!1},_mouseStop:function(t){var n=!1;e.ui.ddmanager&&!this.options.dropBehaviour&&(n=e.ui.ddmanager.drop(this,t)),this.dropped&&(n=this.dropped,this.dropped=!1);var r=this.element[0],i=!1;while(r&&(r=r.parentNode))r==document&&(i=!0);if(!i&&this.options.helper==="original")return!1;if(this.options.revert=="invalid"&&!n||this.options.revert=="valid"&&n||this.options.revert===!0||e.isFunction(this.options.revert)&&this.options.revert.call(this.element,n)){var s=this;e(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){s._trigger("stop",t)!==!1&&s._clear()})}else this._trigger("stop",t)!==!1&&this._clear();return!1},_mouseUp:function(t){return e("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)}),e.ui.ddmanager&&e.ui.ddmanager.dragStop(this,t),e.ui.mouse.prototype._mouseUp.call(this,t)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(t){var n=!this.options.handle||!e(this.options.handle,this.element).length?!0:!1;return e(this.options.handle,this.element).find("*").andSelf().each(function(){this==t.target&&(n=!0)}),n},_createHelper:function(t){var n=this.options,r=e.isFunction(n.helper)?e(n.helper.apply(this.element[0],[t])):n.helper=="clone"?this.element.clone().removeAttr("id"):this.element;return r.parents("body").length||r.appendTo(n.appendTo=="parent"?this.element[0].parentNode:n.appendTo),r[0]!=this.element[0]&&!/(fixed|absolute)/.test(r.css("position"))&&r.css("position","absolute"),r},_adjustOffsetFromHelper:function(t){typeof t=="string"&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop());if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&e.ui.ie)t={top:0,left:0};return{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var e=this.element.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t=this.options;t.containment=="parent"&&(t.containment=this.helper[0].parentNode);if(t.containment=="document"||t.containment=="window")this.containment=[t.containment=="document"?0:e(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t.containment=="document"?0:e(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,(t.containment=="document"?0:e(window).scrollLeft())+e(t.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(t.containment=="document"?0:e(window).scrollTop())+(e(t.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(t.containment)&&t.containment.constructor!=Array){var n=e(t.containment),r=n[0];if(!r)return;var i=n.offset(),s=e(r).css("overflow")!="hidden";this.containment=[(parseInt(e(r).css("borderLeftWidth"),10)||0)+(parseInt(e(r).css("paddingLeft"),10)||0),(parseInt(e(r).css("borderTopWidth"),10)||0)+(parseInt(e(r).css("paddingTop"),10)||0),(s?Math.max(r.scrollWidth,r.offsetWidth):r.offsetWidth)-(parseInt(e(r).css("borderLeftWidth"),10)||0)-(parseInt(e(r).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(s?Math.max(r.scrollHeight,r.offsetHeight):r.offsetHeight)-(parseInt(e(r).css("borderTopWidth"),10)||0)-(parseInt(e(r).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relative_container=n}else t.containment.constructor==Array&&(this.containment=t.containment)},_convertPositionTo:function(t,n){n||(n=this.position);var r=t=="absolute"?1:-1,i=this.options,s=this.cssPosition!="absolute"||this.scrollParent[0]!=document&&!!e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(s[0].tagName);return{top:n.top+this.offset.relative.top*r+this.offset.parent.top*r-(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():o?0:s.scrollTop())*r,left:n.left+this.offset.relative.left*r+this.offset.parent.left*r-(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():o?0:s.scrollLeft())*r}},_generatePosition:function(t){var n=this.options,r=this.cssPosition!="absolute"||this.scrollParent[0]!=document&&!!e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,i=/(html|body)/i.test(r[0].tagName),s=t.pageX,o=t.pageY;if(this.originalPosition){var u;if(this.containment){if(this.relative_container){var a=this.relative_container.offset();u=[this.containment[0]+a.left,this.containment[1]+a.top,this.containment[2]+a.left,this.containment[3]+a.top]}else u=this.containment;t.pageX-this.offset.click.left<u[0]&&(s=u[0]+this.offset.click.left),t.pageY-this.offset.click.top<u[1]&&(o=u[1]+this.offset.click.top),t.pageX-this.offset.click.left>u[2]&&(s=u[2]+this.offset.click.left),t.pageY-this.offset.click.top>u[3]&&(o=u[3]+this.offset.click.top)}if(n.grid){var f=n.grid[1]?this.originalPageY+Math.round((o-this.originalPageY)/n.grid[1])*n.grid[1]:this.originalPageY;o=u?f-this.offset.click.top<u[1]||f-this.offset.click.top>u[3]?f-this.offset.click.top<u[1]?f+n.grid[1]:f-n.grid[1]:f:f;var l=n.grid[0]?this.originalPageX+Math.round((s-this.originalPageX)/n.grid[0])*n.grid[0]:this.originalPageX;s=u?l-this.offset.click.left<u[0]||l-this.offset.click.left>u[2]?l-this.offset.click.left<u[0]?l+n.grid[0]:l-n.grid[0]:l:l}}return{top:o-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():i?0:r.scrollTop()),left:s-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():i?0:r.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]!=this.element[0]&&!this.cancelHelperRemoval&&this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1},_trigger:function(t,n,r){return r=r||this._uiHash(),e.ui.plugin.call(this,t,[n,r]),t=="drag"&&(this.positionAbs=this._convertPositionTo("absolute")),e.Widget.prototype._trigger.call(this,t,n,r)},plugins:{},_uiHash:function(e){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),e.ui.plugin.add("draggable","connectToSortable",{start:function(t,n){var r=e(this).data("draggable"),i=r.options,s=e.extend({},n,{item:r.element});r.sortables=[],e(i.connectToSortable).each(function(){var n=e.data(this,"sortable");n&&!n.options.disabled&&(r.sortables.push({instance:n,shouldRevert:n.options.revert}),n.refreshPositions(),n._trigger("activate",t,s))})},stop:function(t,n){var r=e(this).data("draggable"),i=e.extend({},n,{item:r.element});e.each(r.sortables,function(){this.instance.isOver?(this.instance.isOver=0,r.cancelHelperRemoval=!0,this.instance.cancelHelperRemoval=!1,this.shouldRevert&&(this.instance.options.revert=!0),this.instance._mouseStop(t),this.instance.options.helper=this.instance.options._helper,r.options.helper=="original"&&this.instance.currentItem.css({top:"auto",left:"auto"})):(this.instance.cancelHelperRemoval=!1,this.instance._trigger("deactivate",t,i))})},drag:function(t,n){var r=e(this).data("draggable"),i=this,s=function(t){var n=this.offset.click.top,r=this.offset.click.left,i=this.positionAbs.top,s=this.positionAbs.left,o=t.height,u=t.width,a=t.top,f=t.left;return e.ui.isOver(i+n,s+r,a,f,o,u)};e.each(r.sortables,function(s){var o=!1,u=this;this.instance.positionAbs=r.positionAbs,this.instance.helperProportions=r.helperProportions,this.instance.offset.click=r.offset.click,this.instance._intersectsWith(this.instance.containerCache)&&(o=!0,e.each(r.sortables,function(){return this.instance.positionAbs=r.positionAbs,this.instance.helperProportions=r.helperProportions,this.instance.offset.click=r.offset.click,this!=u&&this.instance._intersectsWith(this.instance.containerCache)&&e.ui.contains(u.instance.element[0],this.instance.element[0])&&(o=!1),o})),o?(this.instance.isOver||(this.instance.isOver=1,this.instance.currentItem=e(i).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item",!0),this.instance.options._helper=this.instance.options.helper,this.instance.options.helper=function(){return n.helper[0]},t.target=this.instance.currentItem[0],this.instance._mouseCapture(t,!0),this.instance._mouseStart(t,!0,!0),this.instance.offset.click.top=r.offset.click.top,this.instance.offset.click.left=r.offset.click.left,this.instance.offset.parent.left-=r.offset.parent.left-this.instance.offset.parent.left,this.instance.offset.parent.top-=r.offset.parent.top-this.instance.offset.parent.top,r._trigger("toSortable",t),r.dropped=this.instance.element,r.currentItem=r.element,this.instance.fromOutside=r),this.instance.currentItem&&this.instance._mouseDrag(t)):this.instance.isOver&&(this.instance.isOver=0,this.instance.cancelHelperRemoval=!0,this.instance.options.revert=!1,this.instance._trigger("out",t,this.instance._uiHash(this.instance)),this.instance._mouseStop(t,!0),this.instance.options.helper=this.instance.options._helper,this.instance.currentItem.remove(),this.instance.placeholder&&this.instance.placeholder.remove(),r._trigger("fromSortable",t),r.dropped=!1)})}}),e.ui.plugin.add("draggable","cursor",{start:function(t,n){var r=e("body"),i=e(this).data("draggable").options;r.css("cursor")&&(i._cursor=r.css("cursor")),r.css("cursor",i.cursor)},stop:function(t,n){var r=e(this).data("draggable").options;r._cursor&&e("body").css("cursor",r._cursor)}}),e.ui.plugin.add("draggable","opacity",{start:function(t,n){var r=e(n.helper),i=e(this).data("draggable").options;r.css("opacity")&&(i._opacity=r.css("opacity")),r.css("opacity",i.opacity)},stop:function(t,n){var r=e(this).data("draggable").options;r._opacity&&e(n.helper).css("opacity",r._opacity)}}),e.ui.plugin.add("draggable","scroll",{start:function(t,n){var r=e(this).data("draggable");r.scrollParent[0]!=document&&r.scrollParent[0].tagName!="HTML"&&(r.overflowOffset=r.scrollParent.offset())},drag:function(t,n){var r=e(this).data("draggable"),i=r.options,s=!1;if(r.scrollParent[0]!=document&&r.scrollParent[0].tagName!="HTML"){if(!i.axis||i.axis!="x")r.overflowOffset.top+r.scrollParent[0].offsetHeight-t.pageY<i.scrollSensitivity?r.scrollParent[0].scrollTop=s=r.scrollParent[0].scrollTop+i.scrollSpeed:t.pageY-r.overflowOffset.top<i.scrollSensitivity&&(r.scrollParent[0].scrollTop=s=r.scrollParent[0].scrollTop-i.scrollSpeed);if(!i.axis||i.axis!="y")r.overflowOffset.left+r.scrollParent[0].offsetWidth-t.pageX<i.scrollSensitivity?r.scrollParent[0].scrollLeft=s=r.scrollParent[0].scrollLeft+i.scrollSpeed:t.pageX-r.overflowOffset.left<i.scrollSensitivity&&(r.scrollParent[0].scrollLeft=s=r.scrollParent[0].scrollLeft-i.scrollSpeed)}else{if(!i.axis||i.axis!="x")t.pageY-e(document).scrollTop()<i.scrollSensitivity?s=e(document).scrollTop(e(document).scrollTop()-i.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<i.scrollSensitivity&&(s=e(document).scrollTop(e(document).scrollTop()+i.scrollSpeed));if(!i.axis||i.axis!="y")t.pageX-e(document).scrollLeft()<i.scrollSensitivity?s=e(document).scrollLeft(e(document).scrollLeft()-i.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<i.scrollSensitivity&&(s=e(document).scrollLeft(e(document).scrollLeft()+i.scrollSpeed))}s!==!1&&e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(r,t)}}),e.ui.plugin.add("draggable","snap",{start:function(t,n){var r=e(this).data("draggable"),i=r.options;r.snapElements=[],e(i.snap.constructor!=String?i.snap.items||":data(draggable)":i.snap).each(function(){var t=e(this),n=t.offset();this!=r.element[0]&&r.snapElements.push({item:this,width:t.outerWidth(),height:t.outerHeight(),top:n.top,left:n.left})})},drag:function(t,n){var r=e(this).data("draggable"),i=r.options,s=i.snapTolerance,o=n.offset.left,u=o+r.helperProportions.width,a=n.offset.top,f=a+r.helperProportions.height;for(var l=r.snapElements.length-1;l>=0;l--){var c=r.snapElements[l].left,h=c+r.snapElements[l].width,p=r.snapElements[l].top,d=p+r.snapElements[l].height;if(!(c-s<o&&o<h+s&&p-s<a&&a<d+s||c-s<o&&o<h+s&&p-s<f&&f<d+s||c-s<u&&u<h+s&&p-s<a&&a<d+s||c-s<u&&u<h+s&&p-s<f&&f<d+s)){r.snapElements[l].snapping&&r.options.snap.release&&r.options.snap.release.call(r.element,t,e.extend(r._uiHash(),{snapItem:r.snapElements[l].item})),r.snapElements[l].snapping=!1;continue}if(i.snapMode!="inner"){var v=Math.abs(p-f)<=s,m=Math.abs(d-a)<=s,g=Math.abs(c-u)<=s,y=Math.abs(h-o)<=s;v&&(n.position.top=r._convertPositionTo("relative",{top:p-r.helperProportions.height,left:0}).top-r.margins.top),m&&(n.position.top=r._convertPositionTo("relative",{top:d,left:0}).top-r.margins.top),g&&(n.position.left=r._convertPositionTo("relative",{top:0,left:c-r.helperProportions.width}).left-r.margins.left),y&&(n.position.left=r._convertPositionTo("relative",{top:0,left:h}).left-r.margins.left)}var b=v||m||g||y;if(i.snapMode!="outer"){var v=Math.abs(p-a)<=s,m=Math.abs(d-f)<=s,g=Math.abs(c-o)<=s,y=Math.abs(h-u)<=s;v&&(n.position.top=r._convertPositionTo("relative",{top:p,left:0}).top-r.margins.top),m&&(n.position.top=r._convertPositionTo("relative",{top:d-r.helperProportions.height,left:0}).top-r.margins.top),g&&(n.position.left=r._convertPositionTo("relative",{top:0,left:c}).left-r.margins.left),y&&(n.position.left=r._convertPositionTo("relative",{top:0,left:h-r.helperProportions.width}).left-r.margins.left)}!r.snapElements[l].snapping&&(v||m||g||y||b)&&r.options.snap.snap&&r.options.snap.snap.call(r.element,t,e.extend(r._uiHash(),{snapItem:r.snapElements[l].item})),r.snapElements[l].snapping=v||m||g||y||b}}}),e.ui.plugin.add("draggable","stack",{start:function(t,n){var r=e(this).data("draggable").options,i=e.makeArray(e(r.stack)).sort(function(t,n){return(parseInt(e(t).css("zIndex"),10)||0)-(parseInt(e(n).css("zIndex"),10)||0)});if(!i.length)return;var s=parseInt(i[0].style.zIndex)||0;e(i).each(function(e){this.style.zIndex=s+e}),this[0].style.zIndex=s+i.length}}),e.ui.plugin.add("draggable","zIndex",{start:function(t,n){var r=e(n.helper),i=e(this).data("draggable").options;r.css("zIndex")&&(i._zIndex=r.css("zIndex")),r.css("zIndex",i.zIndex)},stop:function(t,n){var r=e(this).data("draggable").options;r._zIndex&&e(n.helper).css("zIndex",r._zIndex)}})})(jQuery);(function(e,t){e.widget("ui.droppable",{version:"1.9.1",widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect"},_create:function(){var t=this.options,n=t.accept;this.isover=0,this.isout=1,this.accept=e.isFunction(n)?n:function(e){return e.is(n)},this.proportions={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight},e.ui.ddmanager.droppables[t.scope]=e.ui.ddmanager.droppables[t.scope]||[],e.ui.ddmanager.droppables[t.scope].push(this),t.addClasses&&this.element.addClass("ui-droppable")},_destroy:function(){var t=e.ui.ddmanager.droppables[this.options.scope];for(var n=0;n<t.length;n++)t[n]==this&&t.splice(n,1);this.element.removeClass("ui-droppable ui-droppable-disabled")},_setOption:function(t,n){t=="accept"&&(this.accept=e.isFunction(n)?n:function(e){return e.is(n)}),e.Widget.prototype._setOption.apply(this,arguments)},_activate:function(t){var n=e.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),n&&this._trigger("activate",t,this.ui(n))},_deactivate:function(t){var n=e.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),n&&this._trigger("deactivate",t,this.ui(n))},_over:function(t){var n=e.ui.ddmanager.current;if(!n||(n.currentItem||n.element)[0]==this.element[0])return;this.accept.call(this.element[0],n.currentItem||n.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",t,this.ui(n)))},_out:function(t){var n=e.ui.ddmanager.current;if(!n||(n.currentItem||n.element)[0]==this.element[0])return;this.accept.call(this.element[0],n.currentItem||n.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",t,this.ui(n)))},_drop:function(t,n){var r=n||e.ui.ddmanager.current;if(!r||(r.currentItem||r.element)[0]==this.element[0])return!1;var i=!1;return this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function(){var t=e.data(this,"droppable");if(t.options.greedy&&!t.options.disabled&&t.options.scope==r.options.scope&&t.accept.call(t.element[0],r.currentItem||r.element)&&e.ui.intersect(r,e.extend(t,{offset:t.element.offset()}),t.options.tolerance))return i=!0,!1}),i?!1:this.accept.call(this.element[0],r.currentItem||r.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",t,this.ui(r)),this.element):!1},ui:function(e){return{draggable:e.currentItem||e.element,helper:e.helper,position:e.position,offset:e.positionAbs}}}),e.ui.intersect=function(t,n,r){if(!n.offset)return!1;var i=(t.positionAbs||t.position.absolute).left,s=i+t.helperProportions.width,o=(t.positionAbs||t.position.absolute).top,u=o+t.helperProportions.height,a=n.offset.left,f=a+n.proportions.width,l=n.offset.top,c=l+n.proportions.height;switch(r){case"fit":return a<=i&&s<=f&&l<=o&&u<=c;case"intersect":return a<i+t.helperProportions.width/2&&s-t.helperProportions.width/2<f&&l<o+t.helperProportions.height/2&&u-t.helperProportions.height/2<c;case"pointer":var h=(t.positionAbs||t.position.absolute).left+(t.clickOffset||t.offset.click).left,p=(t.positionAbs||t.position.absolute).top+(t.clickOffset||t.offset.click).top,d=e.ui.isOver(p,h,l,a,n.proportions.height,n.proportions.width);return d;case"touch":return(o>=l&&o<=c||u>=l&&u<=c||o<l&&u>c)&&(i>=a&&i<=f||s>=a&&s<=f||i<a&&s>f);default:return!1}},e.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(t,n){var r=e.ui.ddmanager.droppables[t.options.scope]||[],i=n?n.type:null,s=(t.currentItem||t.element).find(":data(droppable)").andSelf();e:for(var o=0;o<r.length;o++){if(r[o].options.disabled||t&&!r[o].accept.call(r[o].element[0],t.currentItem||t.element))continue;for(var u=0;u<s.length;u++)if(s[u]==r[o].element[0]){r[o].proportions.height=0;continue e}r[o].visible=r[o].element.css("display")!="none";if(!r[o].visible)continue;i=="mousedown"&&r[o]._activate.call(r[o],n),r[o].offset=r[o].element.offset(),r[o].proportions={width:r[o].element[0].offsetWidth,height:r[o].element[0].offsetHeight}}},drop:function(t,n){var r=!1;return e.each(e.ui.ddmanager.droppables[t.options.scope]||[],function(){if(!this.options)return;!this.options.disabled&&this.visible&&e.ui.intersect(t,this,this.options.tolerance)&&(r=this._drop.call(this,n)||r),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],t.currentItem||t.element)&&(this.isout=1,this.isover=0,this._deactivate.call(this,n))}),r},dragStart:function(t,n){t.element.parentsUntil("body").bind("scroll.droppable",function(){t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,n)})},drag:function(t,n){t.options.refreshPositions&&e.ui.ddmanager.prepareOffsets(t,n),e.each(e.ui.ddmanager.droppables[t.options.scope]||[],function(){if(this.options.disabled||this.greedyChild||!this.visible)return;var r=e.ui.intersect(t,this,this.options.tolerance),i=!r&&this.isover==1?"isout":r&&this.isover==0?"isover":null;if(!i)return;var s;if(this.options.greedy){var o=this.options.scope,u=this.element.parents(":data(droppable)").filter(function(){return e.data(this,"droppable").options.scope===o});u.length&&(s=e.data(u[0],"droppable"),s.greedyChild=i=="isover"?1:0)}s&&i=="isover"&&(s.isover=0,s.isout=1,s._out.call(s,n)),this[i]=1,this[i=="isout"?"isover":"isout"]=0,this[i=="isover"?"_over":"_out"].call(this,n),s&&i=="isout"&&(s.isout=0,s.isover=1,s._over.call(s,n))})},dragStop:function(t,n){t.element.parentsUntil("body").unbind("scroll.droppable"),t.options.refreshPositions||e.ui.ddmanager.prepareOffsets(t,n)}}})(jQuery);jQuery.effects||function(e,t){var n=e.uiBackCompat!==!1,r="ui-effects-";e.effects={effect:{}},function(t,n){function p(e,t,n){var r=a[t.type]||{};return e==null?n||!t.def?null:t.def:(e=r.floor?~~e:parseFloat(e),isNaN(e)?t.def:r.mod?(e+r.mod)%r.mod:0>e?0:r.max<e?r.max:e)}function d(e){var n=o(),r=n._rgba=[];return e=e.toLowerCase(),h(s,function(t,i){var s,o=i.re.exec(e),a=o&&i.parse(o),f=i.space||"rgba";if(a)return s=n[f](a),n[u[f].cache]=s[u[f].cache],r=n._rgba=s._rgba,!1}),r.length?(r.join()==="0,0,0,0"&&t.extend(r,c.transparent),n):c[e]}function v(e,t,n){return n=(n+1)%1,n*6<1?e+(t-e)*n*6:n*2<1?t:n*3<2?e+(t-e)*(2/3-n)*6:e}var r="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor".split(" "),i=/^([\-+])=\s*(\d+\.?\d*)/,s=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1],e[2],e[3],e[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,parse:function(e){return[e[1]*2.55,e[2]*2.55,e[3]*2.55,e[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(e){return[parseInt(e[1],16),parseInt(e[2],16),parseInt(e[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(e){return[parseInt(e[1]+e[1],16),parseInt(e[2]+e[2],16),parseInt(e[3]+e[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d+(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(e){return[e[1],e[2]/100,e[3]/100,e[4]]}}],o=t.Color=function(e,n,r,i){return new t.Color.fn.parse(e,n,r,i)},u={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},a={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},f=o.support={},l=t("<p>")[0],c,h=t.each;l.style.cssText="background-color:rgba(1,1,1,.5)",f.rgba=l.style.backgroundColor.indexOf("rgba")>-1,h(u,function(e,t){t.cache="_"+e,t.props.alpha={idx:3,type:"percent",def:1}}),o.fn=t.extend(o.prototype,{parse:function(r,i,s,a){if(r===n)return this._rgba=[null,null,null,null],this;if(r.jquery||r.nodeType)r=t(r).css(i),i=n;var f=this,l=t.type(r),v=this._rgba=[];i!==n&&(r=[r,i,s,a],l="array");if(l==="string")return this.parse(d(r)||c._default);if(l==="array")return h(u.rgba.props,function(e,t){v[t.idx]=p(r[t.idx],t)}),this;if(l==="object")return r instanceof o?h(u,function(e,t){r[t.cache]&&(f[t.cache]=r[t.cache].slice())}):h(u,function(t,n){var i=n.cache;h(n.props,function(e,t){if(!f[i]&&n.to){if(e==="alpha"||r[e]==null)return;f[i]=n.to(f._rgba)}f[i][t.idx]=p(r[e],t,!0)}),f[i]&&e.inArray(null,f[i].slice(0,3))<0&&(f[i][3]=1,n.from&&(f._rgba=n.from(f[i])))}),this},is:function(e){var t=o(e),n=!0,r=this;return h(u,function(e,i){var s,o=t[i.cache];return o&&(s=r[i.cache]||i.to&&i.to(r._rgba)||[],h(i.props,function(e,t){if(o[t.idx]!=null)return n=o[t.idx]===s[t.idx],n})),n}),n},_space:function(){var e=[],t=this;return h(u,function(n,r){t[r.cache]&&e.push(n)}),e.pop()},transition:function(e,t){var n=o(e),r=n._space(),i=u[r],s=this.alpha()===0?o("transparent"):this,f=s[i.cache]||i.to(s._rgba),l=f.slice();return n=n[i.cache],h(i.props,function(e,r){var i=r.idx,s=f[i],o=n[i],u=a[r.type]||{};if(o===null)return;s===null?l[i]=o:(u.mod&&(o-s>u.mod/2?s+=u.mod:s-o>u.mod/2&&(s-=u.mod)),l[i]=p((o-s)*t+s,r))}),this[r](l)},blend:function(e){if(this._rgba[3]===1)return this;var n=this._rgba.slice(),r=n.pop(),i=o(e)._rgba;return o(t.map(n,function(e,t){return(1-r)*i[t]+r*e}))},toRgbaString:function(){var e="rgba(",n=t.map(this._rgba,function(e,t){return e==null?t>2?1:0:e});return n[3]===1&&(n.pop(),e="rgb("),e+n.join()+")"},toHslaString:function(){var e="hsla(",n=t.map(this.hsla(),function(e,t){return e==null&&(e=t>2?1:0),t&&t<3&&(e=Math.round(e*100)+"%"),e});return n[3]===1&&(n.pop(),e="hsl("),e+n.join()+")"},toHexString:function(e){var n=this._rgba.slice(),r=n.pop();return e&&n.push(~~(r*255)),"#"+t.map(n,function(e){return e=(e||0).toString(16),e.length===1?"0"+e:e}).join("")},toString:function(){return this._rgba[3]===0?"transparent":this.toRgbaString()}}),o.fn.parse.prototype=o.fn,u.hsla.to=function(e){if(e[0]==null||e[1]==null||e[2]==null)return[null,null,null,e[3]];var t=e[0]/255,n=e[1]/255,r=e[2]/255,i=e[3],s=Math.max(t,n,r),o=Math.min(t,n,r),u=s-o,a=s+o,f=a*.5,l,c;return o===s?l=0:t===s?l=60*(n-r)/u+360:n===s?l=60*(r-t)/u+120:l=60*(t-n)/u+240,f===0||f===1?c=f:f<=.5?c=u/a:c=u/(2-a),[Math.round(l)%360,c,f,i==null?1:i]},u.hsla.from=function(e){if(e[0]==null||e[1]==null||e[2]==null)return[null,null,null,e[3]];var t=e[0]/360,n=e[1],r=e[2],i=e[3],s=r<=.5?r*(1+n):r+n-r*n,o=2*r-s;return[Math.round(v(o,s,t+1/3)*255),Math.round(v(o,s,t)*255),Math.round(v(o,s,t-1/3)*255),i]},h(u,function(e,r){var s=r.props,u=r.cache,a=r.to,f=r.from;o.fn[e]=function(e){a&&!this[u]&&(this[u]=a(this._rgba));if(e===n)return this[u].slice();var r,i=t.type(e),l=i==="array"||i==="object"?e:arguments,c=this[u].slice();return h(s,function(e,t){var n=l[i==="object"?e:t.idx];n==null&&(n=c[t.idx]),c[t.idx]=p(n,t)}),f?(r=o(f(c)),r[u]=c,r):o(c)},h(s,function(n,r){if(o.fn[n])return;o.fn[n]=function(s){var o=t.type(s),u=n==="alpha"?this._hsla?"hsla":"rgba":e,a=this[u](),f=a[r.idx],l;return o==="undefined"?f:(o==="function"&&(s=s.call(this,f),o=t.type(s)),s==null&&r.empty?this:(o==="string"&&(l=i.exec(s),l&&(s=f+parseFloat(l[2])*(l[1]==="+"?1:-1))),a[r.idx]=s,this[u](a)))}})}),h(r,function(e,n){t.cssHooks[n]={set:function(e,r){var i,s,u="";if(t.type(r)!=="string"||(i=d(r))){r=o(i||r);if(!f.rgba&&r._rgba[3]!==1){s=n==="backgroundColor"?e.parentNode:e;while((u===""||u==="transparent")&&s&&s.style)try{u=t.css(s,"backgroundColor"),s=s.parentNode}catch(a){}r=r.blend(u&&u!=="transparent"?u:"_default")}r=r.toRgbaString()}try{e.style[n]=r}catch(l){}}},t.fx.step[n]=function(e){e.colorInit||(e.start=o(e.elem,n),e.end=o(e.end),e.colorInit=!0),t.cssHooks[n].set(e.elem,e.start.transition(e.end,e.pos))}}),t.cssHooks.borderColor={expand:function(e){var t={};return h(["Top","Right","Bottom","Left"],function(n,r){t["border"+r+"Color"]=e}),t}},c=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(jQuery),function(){function i(){var t=this.ownerDocument.defaultView?this.ownerDocument.defaultView.getComputedStyle(this,null):this.currentStyle,n={},r,i;if(t&&t.length&&t[0]&&t[t[0]]){i=t.length;while(i--)r=t[i],typeof t[r]=="string"&&(n[e.camelCase(r)]=t[r])}else for(r in t)typeof t[r]=="string"&&(n[r]=t[r]);return n}function s(t,n){var i={},s,o;for(s in n)o=n[s],t[s]!==o&&!r[s]&&(e.fx.step[s]||!isNaN(parseFloat(o)))&&(i[s]=o);return i}var n=["add","remove","toggle"],r={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};e.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(t,n){e.fx.step[n]=function(e){if(e.end!=="none"&&!e.setAttr||e.pos===1&&!e.setAttr)jQuery.style(e.elem,n,e.end),e.setAttr=!0}}),e.effects.animateClass=function(t,r,o,u){var a=e.speed(r,o,u);return this.queue(function(){var r=e(this),o=r.attr("class")||"",u,f=a.children?r.find("*").andSelf():r;f=f.map(function(){var t=e(this);return{el:t,start:i.call(this)}}),u=function(){e.each(n,function(e,n){t[n]&&r[n+"Class"](t[n])})},u(),f=f.map(function(){return this.end=i.call(this.el[0]),this.diff=s(this.start,this.end),this}),r.attr("class",o),f=f.map(function(){var t=this,n=e.Deferred(),r=jQuery.extend({},a,{queue:!1,complete:function(){n.resolve(t)}});return this.el.animate(this.diff,r),n.promise()}),e.when.apply(e,f.get()).done(function(){u(),e.each(arguments,function(){var t=this.el;e.each(this.diff,function(e){t.css(e,"")})}),a.complete.call(r[0])})})},e.fn.extend({_addClass:e.fn.addClass,addClass:function(t,n,r,i){return n?e.effects.animateClass.call(this,{add:t},n,r,i):this._addClass(t)},_removeClass:e.fn.removeClass,removeClass:function(t,n,r,i){return n?e.effects.animateClass.call(this,{remove:t},n,r,i):this._removeClass(t)},_toggleClass:e.fn.toggleClass,toggleClass:function(n,r,i,s,o){return typeof r=="boolean"||r===t?i?e.effects.animateClass.call(this,r?{add:n}:{remove:n},i,s,o):this._toggleClass(n,r):e.effects.animateClass.call(this,{toggle:n},r,i,s)},switchClass:function(t,n,r,i,s){return e.effects.animateClass.call(this,{add:n,remove:t},r,i,s)}})}(),function(){function i(t,n,r,i){e.isPlainObject(t)&&(n=t,t=t.effect),t={effect:t},n==null&&(n={}),e.isFunction(n)&&(i=n,r=null,n={});if(typeof n=="number"||e.fx.speeds[n])i=r,r=n,n={};return e.isFunction(r)&&(i=r,r=null),n&&e.extend(t,n),r=r||n.duration,t.duration=e.fx.off?0:typeof r=="number"?r:r in e.fx.speeds?e.fx.speeds[r]:e.fx.speeds._default,t.complete=i||n.complete,t}function s(t){return!t||typeof t=="number"||e.fx.speeds[t]?!0:typeof t=="string"&&!e.effects.effect[t]?n&&e.effects[t]?!1:!0:!1}e.extend(e.effects,{version:"1.9.1",save:function(e,t){for(var n=0;n<t.length;n++)t[n]!==null&&e.data(r+t[n],e[0].style[t[n]])},restore:function(e,n){var i,s;for(s=0;s<n.length;s++)n[s]!==null&&(i=e.data(r+n[s]),i===t&&(i=""),e.css(n[s],i))},setMode:function(e,t){return t==="toggle"&&(t=e.is(":hidden")?"show":"hide"),t},getBaseline:function(e,t){var n,r;switch(e[0]){case"top":n=0;break;case"middle":n=.5;break;case"bottom":n=1;break;default:n=e[0]/t.height}switch(e[1]){case"left":r=0;break;case"center":r=.5;break;case"right":r=1;break;default:r=e[1]/t.width}return{x:r,y:n}},createWrapper:function(t){if(t.parent().is(".ui-effects-wrapper"))return t.parent();var n={width:t.outerWidth(!0),height:t.outerHeight(!0),"float":t.css("float")},r=e("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),i={width:t.width(),height:t.height()},s=document.activeElement;try{s.id}catch(o){s=document.body}return t.wrap(r),(t[0]===s||e.contains(t[0],s))&&e(s).focus(),r=t.parent(),t.css("position")==="static"?(r.css({position:"relative"}),t.css({position:"relative"})):(e.extend(n,{position:t.css("position"),zIndex:t.css("z-index")}),e.each(["top","left","bottom","right"],function(e,r){n[r]=t.css(r),isNaN(parseInt(n[r],10))&&(n[r]="auto")}),t.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),t.css(i),r.css(n).show()},removeWrapper:function(t){var n=document.activeElement;return t.parent().is(".ui-effects-wrapper")&&(t.parent().replaceWith(t),(t[0]===n||e.contains(t[0],n))&&e(n).focus()),t},setTransition:function(t,n,r,i){return i=i||{},e.each(n,function(e,n){var s=t.cssUnit(n);s[0]>0&&(i[n]=s[0]*r+s[1])}),i}}),e.fn.extend({effect:function(){function a(n){function u(){e.isFunction(i)&&i.call(r[0]),e.isFunction(n)&&n()}var r=e(this),i=t.complete,s=t.mode;(r.is(":hidden")?s==="hide":s==="show")?u():o.call(r[0],t,u)}var t=i.apply(this,arguments),r=t.mode,s=t.queue,o=e.effects.effect[t.effect],u=!o&&n&&e.effects[t.effect];return e.fx.off||!o&&!u?r?this[r](t.duration,t.complete):this.each(function(){t.complete&&t.complete.call(this)}):o?s===!1?this.each(a):this.queue(s||"fx",a):u.call(this,{options:t,duration:t.duration,callback:t.complete,mode:t.mode})},_show:e.fn.show,show:function(e){if(s(e))return this._show.apply(this,arguments);var t=i.apply(this,arguments);return t.mode="show",this.effect.call(this,t)},_hide:e.fn.hide,hide:function(e){if(s(e))return this._hide.apply(this,arguments);var t=i.apply(this,arguments);return t.mode="hide",this.effect.call(this,t)},__toggle:e.fn.toggle,toggle:function(t){if(s(t)||typeof t=="boolean"||e.isFunction(t))return this.__toggle.apply(this,arguments);var n=i.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)},cssUnit:function(t){var n=this.css(t),r=[];return e.each(["em","px","%","pt"],function(e,t){n.indexOf(t)>0&&(r=[parseFloat(n),t])}),r}})}(),function(){var t={};e.each(["Quad","Cubic","Quart","Quint","Expo"],function(e,n){t[n]=function(t){return Math.pow(t,e+2)}}),e.extend(t,{Sine:function(e){return 1-Math.cos(e*Math.PI/2)},Circ:function(e){return 1-Math.sqrt(1-e*e)},Elastic:function(e){return e===0||e===1?e:-Math.pow(2,8*(e-1))*Math.sin(((e-1)*80-7.5)*Math.PI/15)},Back:function(e){return e*e*(3*e-2)},Bounce:function(e){var t,n=4;while(e<((t=Math.pow(2,--n))-1)/11);return 1/Math.pow(4,3-n)-7.5625*Math.pow((t*3-2)/22-e,2)}}),e.each(t,function(t,n){e.easing["easeIn"+t]=n,e.easing["easeOut"+t]=function(e){return 1-n(1-e)},e.easing["easeInOut"+t]=function(e){return e<.5?n(e*2)/2:1-n(e*-2+2)/2}})}()}(jQuery);(function(e,t){var n=/up|down|vertical/,r=/up|left|vertical|horizontal/;e.effects.effect.blind=function(t,i){var s=e(this),o=["position","top","bottom","left","right","height","width"],u=e.effects.setMode(s,t.mode||"hide"),a=t.direction||"up",f=n.test(a),l=f?"height":"width",c=f?"top":"left",h=r.test(a),p={},d=u==="show",v,m,g;s.parent().is(".ui-effects-wrapper")?e.effects.save(s.parent(),o):e.effects.save(s,o),s.show(),v=e.effects.createWrapper(s).css({overflow:"hidden"}),m=v[l](),g=parseFloat(v.css(c))||0,p[l]=d?m:0,h||(s.css(f?"bottom":"right",0).css(f?"top":"left","auto").css({position:"absolute"}),p[c]=d?g:m+g),d&&(v.css(l,0),h||v.css(c,g+m)),v.animate(p,{duration:t.duration,easing:t.easing,queue:!1,complete:function(){u==="hide"&&s.hide(),e.effects.restore(s,o),e.effects.removeWrapper(s),i()}})}})(jQuery);(function(e,t){e.effects.effect.bounce=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"effect"),o=s==="hide",u=s==="show",a=t.direction||"up",f=t.distance,l=t.times||5,c=l*2+(u||o?1:0),h=t.duration/c,p=t.easing,d=a==="up"||a==="down"?"top":"left",v=a==="up"||a==="left",m,g,y,b=r.queue(),w=b.length;(u||o)&&i.push("opacity"),e.effects.save(r,i),r.show(),e.effects.createWrapper(r),f||(f=r[d==="top"?"outerHeight":"outerWidth"]()/3),u&&(y={opacity:1},y[d]=0,r.css("opacity",0).css(d,v?-f*2:f*2).animate(y,h,p)),o&&(f/=Math.pow(2,l-1)),y={},y[d]=0;for(m=0;m<l;m++)g={},g[d]=(v?"-=":"+=")+f,r.animate(g,h,p).animate(y,h,p),f=o?f*2:f/2;o&&(g={opacity:0},g[d]=(v?"-=":"+=")+f,r.animate(g,h,p)),r.queue(function(){o&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}),w>1&&b.splice.apply(b,[1,0].concat(b.splice(w,c+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.clip=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=t.direction||"vertical",a=u==="vertical",f=a?"height":"width",l=a?"top":"left",c={},h,p,d;e.effects.save(r,i),r.show(),h=e.effects.createWrapper(r).css({overflow:"hidden"}),p=r[0].tagName==="IMG"?h:r,d=p[f](),o&&(p.css(f,0),p.css(l,d/2)),c[f]=o?d:0,c[l]=o?0:d/2,p.animate(c,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){o||r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.drop=function(t,n){var r=e(this),i=["position","top","bottom","left","right","opacity","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=t.direction||"left",a=u==="up"||u==="down"?"top":"left",f=u==="up"||u==="left"?"pos":"neg",l={opacity:o?1:0},c;e.effects.save(r,i),r.show(),e.effects.createWrapper(r),c=t.distance||r[a==="top"?"outerHeight":"outerWidth"](!0)/2,o&&r.css("opacity",0).css(a,f==="pos"?-c:c),l[a]=(o?f==="pos"?"+=":"-=":f==="pos"?"-=":"+=")+c,r.animate(l,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.explode=function(t,n){function y(){c.push(this),c.length===r*i&&b()}function b(){s.css({visibility:"visible"}),e(c).remove(),u||s.hide(),n()}var r=t.pieces?Math.round(Math.sqrt(t.pieces)):3,i=r,s=e(this),o=e.effects.setMode(s,t.mode||"hide"),u=o==="show",a=s.show().css("visibility","hidden").offset(),f=Math.ceil(s.outerWidth()/i),l=Math.ceil(s.outerHeight()/r),c=[],h,p,d,v,m,g;for(h=0;h<r;h++){v=a.top+h*l,g=h-(r-1)/2;for(p=0;p<i;p++)d=a.left+p*f,m=p-(i-1)/2,s.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-p*f,top:-h*l}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:f,height:l,left:d+(u?m*f:0),top:v+(u?g*l:0),opacity:u?0:1}).animate({left:d+(u?0:m*f),top:v+(u?0:g*l),opacity:u?1:0},t.duration||500,t.easing,y)}}})(jQuery);(function(e,t){e.effects.effect.fade=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"toggle");r.animate({opacity:i},{queue:!1,duration:t.duration,easing:t.easing,complete:n})}})(jQuery);(function(e,t){e.effects.effect.fold=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"hide"),o=s==="show",u=s==="hide",a=t.size||15,f=/([0-9]+)%/.exec(a),l=!!t.horizFirst,c=o!==l,h=c?["width","height"]:["height","width"],p=t.duration/2,d,v,m={},g={};e.effects.save(r,i),r.show(),d=e.effects.createWrapper(r).css({overflow:"hidden"}),v=c?[d.width(),d.height()]:[d.height(),d.width()],f&&(a=parseInt(f[1],10)/100*v[u?0:1]),o&&d.css(l?{height:0,width:a}:{height:a,width:0}),m[h[0]]=o?v[0]:a,g[h[1]]=o?v[1]:0,d.animate(m,p,t.easing).animate(g,p,t.easing,function(){u&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()})}})(jQuery);(function(e,t){e.effects.effect.highlight=function(t,n){var r=e(this),i=["backgroundImage","backgroundColor","opacity"],s=e.effects.setMode(r,t.mode||"show"),o={backgroundColor:r.css("backgroundColor")};s==="hide"&&(o.opacity=0),e.effects.save(r,i),r.show().css({backgroundImage:"none",backgroundColor:t.color||"#ffff99"}).animate(o,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),n()}})}})(jQuery);(function(e,t){e.effects.effect.pulsate=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"show"),s=i==="show",o=i==="hide",u=s||i==="hide",a=(t.times||5)*2+(u?1:0),f=t.duration/a,l=0,c=r.queue(),h=c.length,p;if(s||!r.is(":visible"))r.css("opacity",0).show(),l=1;for(p=1;p<a;p++)r.animate({opacity:l},f,t.easing),l=1-l;r.animate({opacity:l},f,t.easing),r.queue(function(){o&&r.hide(),n()}),h>1&&c.splice.apply(c,[1,0].concat(c.splice(h,a+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.puff=function(t,n){var r=e(this),i=e.effects.setMode(r,t.mode||"hide"),s=i==="hide",o=parseInt(t.percent,10)||150,u=o/100,a={height:r.height(),width:r.width()};e.extend(t,{effect:"scale",queue:!1,fade:!0,mode:i,complete:n,percent:s?o:100,from:s?a:{height:a.height*u,width:a.width*u}}),r.effect(t)},e.effects.effect.scale=function(t,n){var r=e(this),i=e.extend(!0,{},t),s=e.effects.setMode(r,t.mode||"effect"),o=parseInt(t.percent,10)||(parseInt(t.percent,10)===0?0:s==="hide"?0:100),u=t.direction||"both",a=t.origin,f={height:r.height(),width:r.width(),outerHeight:r.outerHeight(),outerWidth:r.outerWidth()},l={y:u!=="horizontal"?o/100:1,x:u!=="vertical"?o/100:1};i.effect="size",i.queue=!1,i.complete=n,s!=="effect"&&(i.origin=a||["middle","center"],i.restore=!0),i.from=t.from||(s==="show"?{height:0,width:0}:f),i.to={height:f.height*l.y,width:f.width*l.x,outerHeight:f.outerHeight*l.y,outerWidth:f.outerWidth*l.x},i.fade&&(s==="show"&&(i.from.opacity=0,i.to.opacity=1),s==="hide"&&(i.from.opacity=1,i.to.opacity=0)),r.effect(i)},e.effects.effect.size=function(t,n){var r,i,s,o=e(this),u=["position","top","bottom","left","right","width","height","overflow","opacity"],a=["position","top","bottom","left","right","overflow","opacity"],f=["width","height","overflow"],l=["fontSize"],c=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],h=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],p=e.effects.setMode(o,t.mode||"effect"),d=t.restore||p!=="effect",v=t.scale||"both",m=t.origin||["middle","center"],g=o.css("position"),y=d?u:a,b={height:0,width:0};p==="show"&&o.show(),r={height:o.height(),width:o.width(),outerHeight:o.outerHeight(),outerWidth:o.outerWidth()},t.mode==="toggle"&&p==="show"?(o.from=t.to||b,o.to=t.from||r):(o.from=t.from||(p==="show"?b:r),o.to=t.to||(p==="hide"?b:r)),s={from:{y:o.from.height/r.height,x:o.from.width/r.width},to:{y:o.to.height/r.height,x:o.to.width/r.width}};if(v==="box"||v==="both")s.from.y!==s.to.y&&(y=y.concat(c),o.from=e.effects.setTransition(o,c,s.from.y,o.from),o.to=e.effects.setTransition(o,c,s.to.y,o.to)),s.from.x!==s.to.x&&(y=y.concat(h),o.from=e.effects.setTransition(o,h,s.from.x,o.from),o.to=e.effects.setTransition(o,h,s.to.x,o.to));(v==="content"||v==="both")&&s.from.y!==s.to.y&&(y=y.concat(l).concat(f),o.from=e.effects.setTransition(o,l,s.from.y,o.from),o.to=e.effects.setTransition(o,l,s.to.y,o.to)),e.effects.save(o,y),o.show(),e.effects.createWrapper(o),o.css("overflow","hidden").css(o.from),m&&(i=e.effects.getBaseline(m,r),o.from.top=(r.outerHeight-o.outerHeight())*i.y,o.from.left=(r.outerWidth-o.outerWidth())*i.x,o.to.top=(r.outerHeight-o.to.outerHeight)*i.y,o.to.left=(r.outerWidth-o.to.outerWidth)*i.x),o.css(o.from);if(v==="content"||v==="both")c=c.concat(["marginTop","marginBottom"]).concat(l),h=h.concat(["marginLeft","marginRight"]),f=u.concat(c).concat(h),o.find("*[width]").each(function(){var n=e(this),r={height:n.height(),width:n.width()};d&&e.effects.save(n,f),n.from={height:r.height*s.from.y,width:r.width*s.from.x},n.to={height:r.height*s.to.y,width:r.width*s.to.x},s.from.y!==s.to.y&&(n.from=e.effects.setTransition(n,c,s.from.y,n.from),n.to=e.effects.setTransition(n,c,s.to.y,n.to)),s.from.x!==s.to.x&&(n.from=e.effects.setTransition(n,h,s.from.x,n.from),n.to=e.effects.setTransition(n,h,s.to.x,n.to)),n.css(n.from),n.animate(n.to,t.duration,t.easing,function(){d&&e.effects.restore(n,f)})});o.animate(o.to,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){o.to.opacity===0&&o.css("opacity",o.from.opacity),p==="hide"&&o.hide(),e.effects.restore(o,y),d||(g==="static"?o.css({position:"relative",top:o.to.top,left:o.to.left}):e.each(["top","left"],function(e,t){o.css(t,function(t,n){var r=parseInt(n,10),i=e?o.to.left:o.to.top;return n==="auto"?i+"px":r+i+"px"})})),e.effects.removeWrapper(o),n()}})}})(jQuery);(function(e,t){e.effects.effect.shake=function(t,n){var r=e(this),i=["position","top","bottom","left","right","height","width"],s=e.effects.setMode(r,t.mode||"effect"),o=t.direction||"left",u=t.distance||20,a=t.times||3,f=a*2+1,l=Math.round(t.duration/f),c=o==="up"||o==="down"?"top":"left",h=o==="up"||o==="left",p={},d={},v={},m,g=r.queue(),y=g.length;e.effects.save(r,i),r.show(),e.effects.createWrapper(r),p[c]=(h?"-=":"+=")+u,d[c]=(h?"+=":"-=")+u*2,v[c]=(h?"-=":"+=")+u*2,r.animate(p,l,t.easing);for(m=1;m<a;m++)r.animate(d,l,t.easing).animate(v,l,t.easing);r.animate(d,l,t.easing).animate(p,l/2,t.easing).queue(function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}),y>1&&g.splice.apply(g,[1,0].concat(g.splice(y,f+1))),r.dequeue()}})(jQuery);(function(e,t){e.effects.effect.slide=function(t,n){var r=e(this),i=["position","top","bottom","left","right","width","height"],s=e.effects.setMode(r,t.mode||"show"),o=s==="show",u=t.direction||"left",a=u==="up"||u==="down"?"top":"left",f=u==="up"||u==="left",l,c={};e.effects.save(r,i),r.show(),l=t.distance||r[a==="top"?"outerHeight":"outerWidth"](!0),e.effects.createWrapper(r).css({overflow:"hidden"}),o&&r.css(a,f?isNaN(l)?"-"+l:-l:l),c[a]=(o?f?"+=":"-=":f?"-=":"+=")+l,r.animate(c,{queue:!1,duration:t.duration,easing:t.easing,complete:function(){s==="hide"&&r.hide(),e.effects.restore(r,i),e.effects.removeWrapper(r),n()}})}})(jQuery);(function(e,t){e.effects.effect.transfer=function(t,n){var r=e(this),i=e(t.to),s=i.css("position")==="fixed",o=e("body"),u=s?o.scrollTop():0,a=s?o.scrollLeft():0,f=i.offset(),l={top:f.top-u,left:f.left-a,height:i.innerHeight(),width:i.innerWidth()},c=r.offset(),h=e('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(t.className).css({top:c.top-u,left:c.left-a,height:r.innerHeight(),width:r.innerWidth(),position:s?"fixed":"absolute"}).animate(l,t.duration,t.easing,function(){h.remove(),n()})}})(jQuery);(function(e,t){var n=!1;e.widget("ui.menu",{version:"1.9.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-carat-1-e"},menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content ui-corner-all").toggleClass("ui-menu-icons",!!this.element.find(".ui-icon").length).attr({role:this.options.role,tabIndex:0}).bind("click"+this.eventNamespace,e.proxy(function(e){this.options.disabled&&e.preventDefault()},this)),this.options.disabled&&this.element.addClass("ui-state-disabled").attr("aria-disabled","true"),this._on({"mousedown .ui-menu-item > a":function(e){e.preventDefault()},"click .ui-state-disabled > a":function(e){e.preventDefault()},"click .ui-menu-item:has(a)":function(t){var r=e(t.target).closest(".ui-menu-item");!n&&r.not(".ui-state-disabled").length&&(n=!0,this.select(t),r.has(".ui-menu").length?this.expand(t):this.element.is(":focus")||(this.element.trigger("focus",[!0]),this.active&&this.active.parents(".ui-menu").length===1&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(t){var n=e(t.currentTarget);n.siblings().children(".ui-state-active").removeClass("ui-state-active"),this.focus(t,n)},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(e,t){var n=this.active||this.element.children(".ui-menu-item").eq(0);t||this.focus(e,n)},blur:function(t){this._delay(function(){e.contains(this.element[0],this.document[0].activeElement)||this.collapseAll(t)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){e(t.target).closest(".ui-menu").length||this.collapseAll(t),n=!1}})},_destroy:function(){this.element.removeAttr("aria-activedescendant").find(".ui-menu").andSelf().removeClass("ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show(),this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").children("a").removeUniqueId().removeClass("ui-corner-all ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function(){var t=e(this);t.data("ui-menu-submenu-carat")&&t.remove()}),this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content")},_keydown:function(t){function a(e){return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")}var n,r,i,s,o,u=!0;switch(t.keyCode){case e.ui.keyCode.PAGE_UP:this.previousPage(t);break;case e.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case e.ui.keyCode.HOME:this._move("first","first",t);break;case e.ui.keyCode.END:this._move("last","last",t);break;case e.ui.keyCode.UP:this.previous(t);break;case e.ui.keyCode.DOWN:this.next(t);break;case e.ui.keyCode.LEFT:this.collapse(t);break;case e.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(t);break;case e.ui.keyCode.ENTER:case e.ui.keyCode.SPACE:this._activate(t);break;case e.ui.keyCode.ESCAPE:this.collapse(t);break;default:u=!1,r=this.previousFilter||"",i=String.fromCharCode(t.keyCode),s=!1,clearTimeout(this.filterTimer),i===r?s=!0:i=r+i,o=new RegExp("^"+a(i),"i"),n=this.activeMenu.children(".ui-menu-item").filter(function(){return o.test(e(this).children("a").text())}),n=s&&n.index(this.active.next())!==-1?this.active.nextAll(".ui-menu-item"):n,n.length||(i=String.fromCharCode(t.keyCode),o=new RegExp("^"+a(i),"i"),n=this.activeMenu.children(".ui-menu-item").filter(function(){return o.test(e(this).children("a").text())})),n.length?(this.focus(t,n),n.length>1?(this.previousFilter=i,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter):delete this.previousFilter}u&&t.preventDefault()},_activate:function(e){this.active.is(".ui-state-disabled")||(this.active.children("a[aria-haspopup='true']").length?this.expand(e):this.select(e))},refresh:function(){var t,n=this.options.icons.submenu,r=this.element.find(this.options.menus+":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-corner-all").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"});t=r.add(this.element),t.children(":not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","presentation").children("a").uniqueId().addClass("ui-corner-all").attr({tabIndex:-1,role:this._itemRole()}),t.children(":not(.ui-menu-item)").each(function(){var t=e(this);/[^\-\s]/.test(t.text())||t.addClass("ui-widget-content ui-menu-divider")}),t.children(".ui-state-disabled").attr("aria-disabled","true"),r.each(function(){var t=e(this),r=t.prev("a"),i=e("<span>").addClass("ui-menu-icon ui-icon "+n).data("ui-menu-submenu-carat",!0);r.attr("aria-haspopup","true").prepend(i),t.attr("aria-labelledby",r.attr("id"))}),this.active&&!e.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},focus:function(e,t){var n,r;this.blur(e,e&&e.type==="focus"),this._scrollIntoView(t),this.active=t.first(),r=this.active.children("a").addClass("ui-state-focus"),this.options.role&&this.element.attr("aria-activedescendant",r.attr("id")),this.active.parent().closest(".ui-menu-item").children("a:first").addClass("ui-state-active"),e&&e.type==="keydown"?this._close():this.timer=this._delay(function(){this._close()},this.delay),n=t.children(".ui-menu"),n.length&&/^mouse/.test(e.type)&&this._startOpening(n),this.activeMenu=t.parent(),this._trigger("focus",e,{item:t})},_scrollIntoView:function(t){var n,r,i,s,o,u;this._hasScroll()&&(n=parseFloat(e.css(this.activeMenu[0],"borderTopWidth"))||0,r=parseFloat(e.css(this.activeMenu[0],"paddingTop"))||0,i=t.offset().top-this.activeMenu.offset().top-n-r,s=this.activeMenu.scrollTop(),o=this.activeMenu.height(),u=t.height(),i<0?this.activeMenu.scrollTop(s+i):i+u>o&&this.activeMenu.scrollTop(s+i-o+u))},blur:function(e,t){t||clearTimeout(this.timer);if(!this.active)return;this.active.children("a").removeClass("ui-state-focus"),this.active=null,this._trigger("blur",e,{item:this.active})},_startOpening:function(e){clearTimeout(this.timer);if(e.attr("aria-hidden")!=="true")return;this.timer=this._delay(function(){this._close(),this._open(e)},this.delay)},_open:function(t){var n=e.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(t.parents(".ui-menu")).hide().attr("aria-hidden","true"),t.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(n)},collapseAll:function(t,n){clearTimeout(this.timer),this.timer=this._delay(function(){var r=n?this.element:e(t&&t.target).closest(this.element.find(".ui-menu"));r.length||(r=this.element),this._close(r),this.blur(t),this.activeMenu=r},this.delay)},_close:function(e){e||(e=this.active?this.active.parent():this.element),e.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false").end().find("a.ui-state-active").removeClass("ui-state-active")},collapse:function(e){var t=this.active&&this.active.parent().closest(".ui-menu-item",this.element);t&&t.length&&(this._close(),this.focus(e,t))},expand:function(e){var t=this.active&&this.active.children(".ui-menu ").children(".ui-menu-item").first();t&&t.length&&(this._open(t.parent()),this._delay(function(){this.focus(e,t)}))},next:function(e){this._move("next","first",e)},previous:function(e){this._move("prev","last",e)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(e,t,n){var r;this.active&&(e==="first"||e==="last"?r=this.active[e==="first"?"prevAll":"nextAll"](".ui-menu-item").eq(-1):r=this.active[e+"All"](".ui-menu-item").eq(0));if(!r||!r.length||!this.active)r=this.activeMenu.children(".ui-menu-item")[t]();this.focus(n,r)},nextPage:function(t){var n,r,i;if(!this.active){this.next(t);return}if(this.isLastItem())return;this._hasScroll()?(r=this.active.offset().top,i=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return n=e(this),n.offset().top-r-i<0}),this.focus(t,n)):this.focus(t,this.activeMenu.children(".ui-menu-item")[this.active?"last":"first"]())},previousPage:function(t){var n,r,i;if(!this.active){this.next(t);return}if(this.isFirstItem())return;this._hasScroll()?(r=this.active.offset().top,i=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return n=e(this),n.offset().top-r+i>0}),this.focus(t,n)):this.focus(t,this.activeMenu.children(".ui-menu-item").first())},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(t){this.active=this.active||e(t.target).closest(".ui-menu-item");var n={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(t,!0),this._trigger("select",t,n)}})})(jQuery);(function(e,t){e.widget("ui.progressbar",{version:"1.9.1",options:{value:0,max:100},min:0,_create:function(){this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min,"aria-valuemax":this.options.max,"aria-valuenow":this._value()}),this.valueDiv=e("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element),this.oldValue=this._value(),this._refreshValue()},_destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.valueDiv.remove()},value:function(e){return e===t?this._value():(this._setOption("value",e),this)},_setOption:function(e,t){e==="value"&&(this.options.value=t,this._refreshValue(),this._value()===this.options.max&&this._trigger("complete")),this._super(e,t)},_value:function(){var e=this.options.value;return typeof e!="number"&&(e=0),Math.min(this.options.max,Math.max(this.min,e))},_percentage:function(){return 100*this._value()/this.options.max},_refreshValue:function(){var e=this.value(),t=this._percentage();this.oldValue!==e&&(this.oldValue=e,this._trigger("change")),this.valueDiv.toggle(e>this.min).toggleClass("ui-corner-right",e===this.options.max).width(t.toFixed(0)+"%"),this.element.attr("aria-valuenow",e)}})})(jQuery);(function(e,t){e.widget("ui.resizable",e.ui.mouse,{version:"1.9.1",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1e3},_create:function(){var t=this,n=this.options;this.element.addClass("ui-resizable"),e.extend(this,{_aspectRatio:!!n.aspectRatio,aspectRatio:n.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:n.helper||n.ghost||n.animate?n.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)&&(this.element.wrap(e('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("resizable",this.element.data("resizable")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=n.handles||(e(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se");if(this.handles.constructor==String){this.handles=="all"&&(this.handles="n,e,s,w,se,sw,ne,nw");var r=this.handles.split(",");this.handles={};for(var i=0;i<r.length;i++){var s=e.trim(r[i]),o="ui-resizable-"+s,u=e('<div class="ui-resizable-handle '+o+'"></div>');u.css({zIndex:n.zIndex}),"se"==s&&u.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[s]=".ui-resizable-"+s,this.element.append(u)}}this._renderAxis=function(t){t=t||this.element;for(var n in this.handles){this.handles[n].constructor==String&&(this.handles[n]=e(this.handles[n],this.element).show());if(this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var r=e(this.handles[n],this.element),i=0;i=/sw|ne|nw|se|n|s/.test(n)?r.outerHeight():r.outerWidth();var s=["padding",/ne|nw|n/.test(n)?"Top":/se|sw|s/.test(n)?"Bottom":/^e$/.test(n)?"Right":"Left"].join("");t.css(s,i),this._proportionallyResize()}if(!e(this.handles[n]).length)continue}},this._renderAxis(this.element),this._handles=e(".ui-resizable-handle",this.element).disableSelection(),this._handles.mouseover(function(){if(!t.resizing){if(this.className)var e=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);t.axis=e&&e[1]?e[1]:"se"}}),n.autoHide&&(this._handles.hide(),e(this.element).addClass("ui-resizable-autohide").mouseenter(function(){if(n.disabled)return;e(this).removeClass("ui-resizable-autohide"),t._handles.show()}).mouseleave(function(){if(n.disabled)return;t.resizing||(e(this).addClass("ui-resizable-autohide"),t._handles.hide())})),this._mouseInit()},_destroy:function(){this._mouseDestroy();var t=function(t){e(t).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};if(this.elementIsWrapper){t(this.element);var n=this.element;this.originalElement.css({position:n.css("position"),width:n.outerWidth(),height:n.outerHeight(),top:n.css("top"),left:n.css("left")}).insertAfter(n),n.remove()}return this.originalElement.css("resize",this.originalResizeStyle),t(this.originalElement),this},_mouseCapture:function(t){var n=!1;for(var r in this.handles)e(this.handles[r])[0]==t.target&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(t){var r=this.options,i=this.element.position(),s=this.element;this.resizing=!0,this.documentScroll={top:e(document).scrollTop(),left:e(document).scrollLeft()},(s.is(".ui-draggable")||/absolute/.test(s.css("position")))&&s.css({position:"absolute",top:i.top,left:i.left}),this._renderProxy();var o=n(this.helper.css("left")),u=n(this.helper.css("top"));r.containment&&(o+=e(r.containment).scrollLeft()||0,u+=e(r.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:o,top:u},this.size=this._helper?{width:s.outerWidth(),height:s.outerHeight()}:{width:s.width(),height:s.height()},this.originalSize=this._helper?{width:s.outerWidth(),height:s.outerHeight()}:{width:s.width(),height:s.height()},this.originalPosition={left:o,top:u},this.sizeDiff={width:s.outerWidth()-s.width(),height:s.outerHeight()-s.height()},this.originalMousePosition={left:t.pageX,top:t.pageY},this.aspectRatio=typeof r.aspectRatio=="number"?r.aspectRatio:this.originalSize.width/this.originalSize.height||1;var a=e(".ui-resizable-"+this.axis).css("cursor");return e("body").css("cursor",a=="auto"?this.axis+"-resize":a),s.addClass("ui-resizable-resizing"),this._propagate("start",t),!0},_mouseDrag:function(e){var t=this.helper,n=this.options,r={},i=this,s=this.originalMousePosition,o=this.axis,u=e.pageX-s.left||0,a=e.pageY-s.top||0,f=this._change[o];if(!f)return!1;var l=f.apply(this,[e,u,a]);this._updateVirtualBoundaries(e.shiftKey);if(this._aspectRatio||e.shiftKey)l=this._updateRatio(l,e);return l=this._respectSize(l,e),this._propagate("resize",e),t.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"}),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),this._updateCache(l),this._trigger("resize",e,this.ui()),!1},_mouseStop:function(t){this.resizing=!1;var n=this.options,r=this;if(this._helper){var i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),o=s&&e.ui.hasScroll(i[0],"left")?0:r.sizeDiff.height,u=s?0:r.sizeDiff.width,a={width:r.helper.width()-u,height:r.helper.height()-o},f=parseInt(r.element.css("left"),10)+(r.position.left-r.originalPosition.left)||null,l=parseInt(r.element.css("top"),10)+(r.position.top-r.originalPosition.top)||null;n.animate||this.element.css(e.extend(a,{top:l,left:f})),r.helper.height(r.size.height),r.helper.width(r.size.width),this._helper&&!n.animate&&this._proportionallyResize()}return e("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",t),this._helper&&this.helper.remove(),!1},_updateVirtualBoundaries:function(e){var t=this.options,n,i,s,o,u;u={minWidth:r(t.minWidth)?t.minWidth:0,maxWidth:r(t.maxWidth)?t.maxWidth:Infinity,minHeight:r(t.minHeight)?t.minHeight:0,maxHeight:r(t.maxHeight)?t.maxHeight:Infinity};if(this._aspectRatio||e)n=u.minHeight*this.aspectRatio,s=u.minWidth/this.aspectRatio,i=u.maxHeight*this.aspectRatio,o=u.maxWidth/this.aspectRatio,n>u.minWidth&&(u.minWidth=n),s>u.minHeight&&(u.minHeight=s),i<u.maxWidth&&(u.maxWidth=i),o<u.maxHeight&&(u.maxHeight=o);this._vBoundaries=u},_updateCache:function(e){var t=this.options;this.offset=this.helper.offset(),r(e.left)&&(this.position.left=e.left),r(e.top)&&(this.position.top=e.top),r(e.height)&&(this.size.height=e.height),r(e.width)&&(this.size.width=e.width)},_updateRatio:function(e,t){var n=this.options,i=this.position,s=this.size,o=this.axis;return r(e.height)?e.width=e.height*this.aspectRatio:r(e.width)&&(e.height=e.width/this.aspectRatio),o=="sw"&&(e.left=i.left+(s.width-e.width),e.top=null),o=="nw"&&(e.top=i.top+(s.height-e.height),e.left=i.left+(s.width-e.width)),e},_respectSize:function(e,t){var n=this.helper,i=this._vBoundaries,s=this._aspectRatio||t.shiftKey,o=this.axis,u=r(e.width)&&i.maxWidth&&i.maxWidth<e.width,a=r(e.height)&&i.maxHeight&&i.maxHeight<e.height,f=r(e.width)&&i.minWidth&&i.minWidth>e.width,l=r(e.height)&&i.minHeight&&i.minHeight>e.height;f&&(e.width=i.minWidth),l&&(e.height=i.minHeight),u&&(e.width=i.maxWidth),a&&(e.height=i.maxHeight);var c=this.originalPosition.left+this.originalSize.width,h=this.position.top+this.size.height,p=/sw|nw|w/.test(o),d=/nw|ne|n/.test(o);f&&p&&(e.left=c-i.minWidth),u&&p&&(e.left=c-i.maxWidth),l&&d&&(e.top=h-i.minHeight),a&&d&&(e.top=h-i.maxHeight);var v=!e.width&&!e.height;return v&&!e.left&&e.top?e.top=null:v&&!e.top&&e.left&&(e.left=null),e},_proportionallyResize:function(){var t=this.options;if(!this._proportionallyResizeElements.length)return;var n=this.helper||this.element;for(var r=0;r<this._proportionallyResizeElements.length;r++){var i=this._proportionallyResizeElements[r];if(!this.borderDif){var s=[i.css("borderTopWidth"),i.css("borderRightWidth"),i.css("borderBottomWidth"),i.css("borderLeftWidth")],o=[i.css("paddingTop"),i.css("paddingRight"),i.css("paddingBottom"),i.css("paddingLeft")];this.borderDif=e.map(s,function(e,t){var n=parseInt(e,10)||0,r=parseInt(o[t],10)||0;return n+r})}i.css({height:n.height()-this.borderDif[0]-this.borderDif[2]||0,width:n.width()-this.borderDif[1]-this.borderDif[3]||0})}},_renderProxy:function(){var t=this.element,n=this.options;this.elementOffset=t.offset();if(this._helper){this.helper=this.helper||e('<div style="overflow:hidden;"></div>');var r=e.ui.ie6?1:0,i=e.ui.ie6?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+i,height:this.element.outerHeight()+i,position:"absolute",left:this.elementOffset.left-r+"px",top:this.elementOffset.top-r+"px",zIndex:++n.zIndex}),this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(e,t,n){return{width:this.originalSize.width+t}},w:function(e,t,n){var r=this.options,i=this.originalSize,s=this.originalPosition;return{left:s.left+t,width:i.width-t}},n:function(e,t,n){var r=this.options,i=this.originalSize,s=this.originalPosition;return{top:s.top+n,height:i.height-n}},s:function(e,t,n){return{height:this.originalSize.height+n}},se:function(t,n,r){return e.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[t,n,r]))},sw:function(t,n,r){return e.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[t,n,r]))},ne:function(t,n,r){return e.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[t,n,r]))},nw:function(t,n,r){return e.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[t,n,r]))}},_propagate:function(t,n){e.ui.plugin.call(this,t,[n,this.ui()]),t!="resize"&&this._trigger(t,n,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),e.ui.plugin.add("resizable","alsoResize",{start:function(t,n){var r=e(this).data("resizable"),i=r.options,s=function(t){e(t).each(function(){var t=e(this);t.data("resizable-alsoresize",{width:parseInt(t.width(),10),height:parseInt(t.height(),10),left:parseInt(t.css("left"),10),top:parseInt(t.css("top"),10)})})};typeof i.alsoResize=="object"&&!i.alsoResize.parentNode?i.alsoResize.length?(i.alsoResize=i.alsoResize[0],s(i.alsoResize)):e.each(i.alsoResize,function(e){s(e)}):s(i.alsoResize)},resize:function(t,n){var r=e(this).data("resizable"),i=r.options,s=r.originalSize,o=r.originalPosition,u={height:r.size.height-s.height||0,width:r.size.width-s.width||0,top:r.position.top-o.top||0,left:r.position.left-o.left||0},a=function(t,r){e(t).each(function(){var t=e(this),i=e(this).data("resizable-alsoresize"),s={},o=r&&r.length?r:t.parents(n.originalElement[0]).length?["width","height"]:["width","height","top","left"];e.each(o,function(e,t){var n=(i[t]||0)+(u[t]||0);n&&n>=0&&(s[t]=n||null)}),t.css(s)})};typeof i.alsoResize=="object"&&!i.alsoResize.nodeType?e.each(i.alsoResize,function(e,t){a(e,t)}):a(i.alsoResize)},stop:function(t,n){e(this).removeData("resizable-alsoresize")}}),e.ui.plugin.add("resizable","animate",{stop:function(t,n){var r=e(this).data("resizable"),i=r.options,s=r._proportionallyResizeElements,o=s.length&&/textarea/i.test(s[0].nodeName),u=o&&e.ui.hasScroll(s[0],"left")?0:r.sizeDiff.height,a=o?0:r.sizeDiff.width,f={width:r.size.width-a,height:r.size.height-u},l=parseInt(r.element.css("left"),10)+(r.position.left-r.originalPosition.left)||null,c=parseInt(r.element.css("top"),10)+(r.position.top-r.originalPosition.top)||null;r.element.animate(e.extend(f,c&&l?{top:c,left:l}:{}),{duration:i.animateDuration,easing:i.animateEasing,step:function(){var n={width:parseInt(r.element.css("width"),10),height:parseInt(r.element.css("height"),10),top:parseInt(r.element.css("top"),10),left:parseInt(r.element.css("left"),10)};s&&s.length&&e(s[0]).css({width:n.width,height:n.height}),r._updateCache(n),r._propagate("resize",t)}})}}),e.ui.plugin.add("resizable","containment",{start:function(t,r){var i=e(this).data("resizable"),s=i.options,o=i.element,u=s.containment,a=u instanceof e?u.get(0):/parent/.test(u)?o.parent().get(0):u;if(!a)return;i.containerElement=e(a);if(/document/.test(u)||u==document)i.containerOffset={left:0,top:0},i.containerPosition={left:0,top:0},i.parentData={element:e(document),left:0,top:0,width:e(document).width(),height:e(document).height()||document.body.parentNode.scrollHeight};else{var f=e(a),l=[];e(["Top","Right","Left","Bottom"]).each(function(e,t){l[e]=n(f.css("padding"+t))}),i.containerOffset=f.offset(),i.containerPosition=f.position(),i.containerSize={height:f.innerHeight()-l[3],width:f.innerWidth()-l[1]};var c=i.containerOffset,h=i.containerSize.height,p=i.containerSize.width,d=e.ui.hasScroll(a,"left")?a.scrollWidth:p,v=e.ui.hasScroll(a)?a.scrollHeight:h;i.parentData={element:a,left:c.left,top:c.top,width:d,height:v}}},resize:function(t,n){var r=e(this).data("resizable"),i=r.options,s=r.containerSize,o=r.containerOffset,u=r.size,a=r.position,f=r._aspectRatio||t.shiftKey,l={top:0,left:0},c=r.containerElement;c[0]!=document&&/static/.test(c.css("position"))&&(l=o),a.left<(r._helper?o.left:0)&&(r.size.width=r.size.width+(r._helper?r.position.left-o.left:r.position.left-l.left),f&&(r.size.height=r.size.width/r.aspectRatio),r.position.left=i.helper?o.left:0),a.top<(r._helper?o.top:0)&&(r.size.height=r.size.height+(r._helper?r.position.top-o.top:r.position.top),f&&(r.size.width=r.size.height*r.aspectRatio),r.position.top=r._helper?o.top:0),r.offset.left=r.parentData.left+r.position.left,r.offset.top=r.parentData.top+r.position.top;var h=Math.abs((r._helper?r.offset.left-l.left:r.offset.left-l.left)+r.sizeDiff.width),p=Math.abs((r._helper?r.offset.top-l.top:r.offset.top-o.top)+r.sizeDiff.height),d=r.containerElement.get(0)==r.element.parent().get(0),v=/relative|absolute/.test(r.containerElement.css("position"));d&&v&&(h-=r.parentData.left),h+r.size.width>=r.parentData.width&&(r.size.width=r.parentData.width-h,f&&(r.size.height=r.size.width/r.aspectRatio)),p+r.size.height>=r.parentData.height&&(r.size.height=r.parentData.height-p,f&&(r.size.width=r.size.height*r.aspectRatio))},stop:function(t,n){var r=e(this).data("resizable"),i=r.options,s=r.position,o=r.containerOffset,u=r.containerPosition,a=r.containerElement,f=e(r.helper),l=f.offset(),c=f.outerWidth()-r.sizeDiff.width,h=f.outerHeight()-r.sizeDiff.height;r._helper&&!i.animate&&/relative/.test(a.css("position"))&&e(this).css({left:l.left-u.left-o.left,width:c,height:h}),r._helper&&!i.animate&&/static/.test(a.css("position"))&&e(this).css({left:l.left-u.left-o.left,width:c,height:h})}}),e.ui.plugin.add("resizable","ghost",{start:function(t,n){var r=e(this).data("resizable"),i=r.options,s=r.size;r.ghost=r.originalElement.clone(),r.ghost.css({opacity:.25,display:"block",position:"relative",height:s.height,width:s.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass(typeof i.ghost=="string"?i.ghost:""),r.ghost.appendTo(r.helper)},resize:function(t,n){var r=e(this).data("resizable"),i=r.options;r.ghost&&r.ghost.css({position:"relative",height:r.size.height,width:r.size.width})},stop:function(t,n){var r=e(this).data("resizable"),i=r.options;r.ghost&&r.helper&&r.helper.get(0).removeChild(r.ghost.get(0))}}),e.ui.plugin.add("resizable","grid",{resize:function(t,n){var r=e(this).data("resizable"),i=r.options,s=r.size,o=r.originalSize,u=r.originalPosition,a=r.axis,f=i._aspectRatio||t.shiftKey;i.grid=typeof i.grid=="number"?[i.grid,i.grid]:i.grid;var l=Math.round((s.width-o.width)/(i.grid[0]||1))*(i.grid[0]||1),c=Math.round((s.height-o.height)/(i.grid[1]||1))*(i.grid[1]||1);/^(se|s|e)$/.test(a)?(r.size.width=o.width+l,r.size.height=o.height+c):/^(ne)$/.test(a)?(r.size.width=o.width+l,r.size.height=o.height+c,r.position.top=u.top-c):/^(sw)$/.test(a)?(r.size.width=o.width+l,r.size.height=o.height+c,r.position.left=u.left-l):(r.size.width=o.width+l,r.size.height=o.height+c,r.position.top=u.top-c,r.position.left=u.left-l)}});var n=function(e){return parseInt(e,10)||0},r=function(e){return!isNaN(parseInt(e,10))}})(jQuery);(function(e,t){e.widget("ui.selectable",e.ui.mouse,{version:"1.9.1",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch"},_create:function(){var t=this;this.element.addClass("ui-selectable"),this.dragged=!1;var n;this.refresh=function(){n=e(t.options.filter,t.element[0]),n.addClass("ui-selectee"),n.each(function(){var t=e(this),n=t.offset();e.data(this,"selectable-item",{element:this,$element:t,left:n.left,top:n.top,right:n.left+t.outerWidth(),bottom:n.top+t.outerHeight(),startselected:!1,selected:t.hasClass("ui-selected"),selecting:t.hasClass("ui-selecting"),unselecting:t.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=n.addClass("ui-selectee"),this._mouseInit(),this.helper=e("<div class='ui-selectable-helper'></div>")},_destroy:function(){this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled"),this._mouseDestroy()},_mouseStart:function(t){var n=this;this.opos=[t.pageX,t.pageY];if(this.options.disabled)return;var r=this.options;this.selectees=e(r.filter,this.element[0]),this._trigger("start",t),e(r.appendTo).append(this.helper),this.helper.css({left:t.clientX,top:t.clientY,width:0,height:0}),r.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var r=e.data(this,"selectable-item");r.startselected=!0,!t.metaKey&&!t.ctrlKey&&(r.$element.removeClass("ui-selected"),r.selected=!1,r.$element.addClass("ui-unselecting"),r.unselecting=!0,n._trigger("unselecting",t,{unselecting:r.element}))}),e(t.target).parents().andSelf().each(function(){var r=e.data(this,"selectable-item");if(r){var i=!t.metaKey&&!t.ctrlKey||!r.$element.hasClass("ui-selected");return r.$element.removeClass(i?"ui-unselecting":"ui-selected").addClass(i?"ui-selecting":"ui-unselecting"),r.unselecting=!i,r.selecting=i,r.selected=i,i?n._trigger("selecting",t,{selecting:r.element}):n._trigger("unselecting",t,{unselecting:r.element}),!1}})},_mouseDrag:function(t){var n=this;this.dragged=!0;if(this.options.disabled)return;var r=this.options,i=this.opos[0],s=this.opos[1],o=t.pageX,u=t.pageY;if(i>o){var a=o;o=i,i=a}if(s>u){var a=u;u=s,s=a}return this.helper.css({left:i,top:s,width:o-i,height:u-s}),this.selectees.each(function(){var a=e.data(this,"selectable-item");if(!a||a.element==n.element[0])return;var f=!1;r.tolerance=="touch"?f=!(a.left>o||a.right<i||a.top>u||a.bottom<s):r.tolerance=="fit"&&(f=a.left>i&&a.right<o&&a.top>s&&a.bottom<u),f?(a.selected&&(a.$element.removeClass("ui-selected"),a.selected=!1),a.unselecting&&(a.$element.removeClass("ui-unselecting"),a.unselecting=!1),a.selecting||(a.$element.addClass("ui-selecting"),a.selecting=!0,n._trigger("selecting",t,{selecting:a.element}))):(a.selecting&&((t.metaKey||t.ctrlKey)&&a.startselected?(a.$element.removeClass("ui-selecting"),a.selecting=!1,a.$element.addClass("ui-selected"),a.selected=!0):(a.$element.removeClass("ui-selecting"),a.selecting=!1,a.startselected&&(a.$element.addClass("ui-unselecting"),a.unselecting=!0),n._trigger("unselecting",t,{unselecting:a.element}))),a.selected&&!t.metaKey&&!t.ctrlKey&&!a.startselected&&(a.$element.removeClass("ui-selected"),a.selected=!1,a.$element.addClass("ui-unselecting"),a.unselecting=!0,n._trigger("unselecting",t,{unselecting:a.element})))}),!1},_mouseStop:function(t){var n=this;this.dragged=!1;var r=this.options;return e(".ui-unselecting",this.element[0]).each(function(){var r=e.data(this,"selectable-item");r.$element.removeClass("ui-unselecting"),r.unselecting=!1,r.startselected=!1,n._trigger("unselected",t,{unselected:r.element})}),e(".ui-selecting",this.element[0]).each(function(){var r=e.data(this,"selectable-item");r.$element.removeClass("ui-selecting").addClass("ui-selected"),r.selecting=!1,r.selected=!0,r.startselected=!0,n._trigger("selected",t,{selected:r.element})}),this._trigger("stop",t),this.helper.remove(),!1}})})(jQuery);(function(e,t){var n=5;e.widget("ui.slider",e.ui.mouse,{version:"1.9.1",widgetEventPrefix:"slide",options:{animate:!1,distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null},_create:function(){var t,r,i=this.options,s=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),o="<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",u=[];this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget"+" ui-widget-content"+" ui-corner-all"+(i.disabled?" ui-slider-disabled ui-disabled":"")),this.range=e([]),i.range&&(i.range===!0&&(i.values||(i.values=[this._valueMin(),this._valueMin()]),i.values.length&&i.values.length!==2&&(i.values=[i.values[0],i.values[0]])),this.range=e("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(i.range==="min"||i.range==="max"?" ui-slider-range-"+i.range:""))),r=i.values&&i.values.length||1;for(t=s.length;t<r;t++)u.push(o);this.handles=s.add(e(u.join("")).appendTo(this.element)),this.handle=this.handles.eq(0),this.handles.add(this.range).filter("a").click(function(e){e.preventDefault()}).mouseenter(function(){i.disabled||e(this).addClass("ui-state-hover")}).mouseleave(function(){e(this).removeClass("ui-state-hover")}).focus(function(){i.disabled?e(this).blur():(e(".ui-slider .ui-state-focus").removeClass("ui-state-focus"),e(this).addClass("ui-state-focus"))}).blur(function(){e(this).removeClass("ui-state-focus")}),this.handles.each(function(t){e(this).data("ui-slider-handle-index",t)}),this._on(this.handles,{keydown:function(t){var r,i,s,o,u=e(t.target).data("ui-slider-handle-index");switch(t.keyCode){case e.ui.keyCode.HOME:case e.ui.keyCode.END:case e.ui.keyCode.PAGE_UP:case e.ui.keyCode.PAGE_DOWN:case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:t.preventDefault();if(!this._keySliding){this._keySliding=!0,e(t.target).addClass("ui-state-active"),r=this._start(t,u);if(r===!1)return}}o=this.options.step,this.options.values&&this.options.values.length?i=s=this.values(u):i=s=this.value();switch(t.keyCode){case e.ui.keyCode.HOME:s=this._valueMin();break;case e.ui.keyCode.END:s=this._valueMax();break;case e.ui.keyCode.PAGE_UP:s=this._trimAlignValue(i+(this._valueMax()-this._valueMin())/n);break;case e.ui.keyCode.PAGE_DOWN:s=this._trimAlignValue(i-(this._valueMax()-this._valueMin())/n);break;case e.ui.keyCode.UP:case e.ui.keyCode.RIGHT:if(i===this._valueMax())return;s=this._trimAlignValue(i+o);break;case e.ui.keyCode.DOWN:case e.ui.keyCode.LEFT:if(i===this._valueMin())return;s=this._trimAlignValue(i-o)}this._slide(t,u,s)},keyup:function(t){var n=e(t.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(t,n),this._change(t,n),e(t.target).removeClass("ui-state-active"))}}),this._refreshValue(),this._animateOff=!1},_destroy:function(){this.handles.remove(),this.range.remove(),this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all"),this._mouseDestroy()},_mouseCapture:function(t){var n,r,i,s,o,u,a,f,l=this,c=this.options;return c.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),n={x:t.pageX,y:t.pageY},r=this._normValueFromMouse(n),i=this._valueMax()-this._valueMin()+1,this.handles.each(function(t){var n=Math.abs(r-l.values(t));i>n&&(i=n,s=e(this),o=t)}),c.range===!0&&this.values(1)===c.min&&(o+=1,s=e(this.handles[o])),u=this._start(t,o),u===!1?!1:(this._mouseSliding=!0,this._handleIndex=o,s.addClass("ui-state-active").focus(),a=s.offset(),f=!e(t.target).parents().andSelf().is(".ui-slider-handle"),this._clickOffset=f?{left:0,top:0}:{left:t.pageX-a.left-s.width()/2,top:t.pageY-a.top-s.height()/2-(parseInt(s.css("borderTopWidth"),10)||0)-(parseInt(s.css("borderBottomWidth"),10)||0)+(parseInt(s.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(t,o,r),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(e){var t={x:e.pageX,y:e.pageY},n=this._normValueFromMouse(t);return this._slide(e,this._handleIndex,n),!1},_mouseStop:function(e){return this.handles.removeClass("ui-state-active"),this._mouseSliding=!1,this._stop(e,this._handleIndex),this._change(e,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(e){var t,n,r,i,s;return this.orientation==="horizontal"?(t=this.elementSize.width,n=e.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(t=this.elementSize.height,n=e.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),r=n/t,r>1&&(r=1),r<0&&(r=0),this.orientation==="vertical"&&(r=1-r),i=this._valueMax()-this._valueMin(),s=this._valueMin()+r*i,this._trimAlignValue(s)},_start:function(e,t){var n={handle:this.handles[t],value:this.value()};return this.options.values&&this.options.values.length&&(n.value=this.values(t),n.values=this.values()),this._trigger("start",e,n)},_slide:function(e,t,n){var r,i,s;this.options.values&&this.options.values.length?(r=this.values(t?0:1),this.options.values.length===2&&this.options.range===!0&&(t===0&&n>r||t===1&&n<r)&&(n=r),n!==this.values(t)&&(i=this.values(),i[t]=n,s=this._trigger("slide",e,{handle:this.handles[t],value:n,values:i}),r=this.values(t?0:1),s!==!1&&this.values(t,n,!0))):n!==this.value()&&(s=this._trigger("slide",e,{handle:this.handles[t],value:n}),s!==!1&&this.value(n))},_stop:function(e,t){var n={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(n.value=this.values(t),n.values=this.values()),this._trigger("stop",e,n)},_change:function(e,t){if(!this._keySliding&&!this._mouseSliding){var n={handle:this.handles[t],value:this.value()};this.options.values&&this.options.values.length&&(n.value=this.values(t),n.values=this.values()),this._trigger("change",e,n)}},value:function(e){if(arguments.length){this.options.value=this._trimAlignValue(e),this._refreshValue(),this._change(null,0);return}return this._value()},values:function(t,n){var r,i,s;if(arguments.length>1){this.options.values[t]=this._trimAlignValue(n),this._refreshValue(),this._change(null,t);return}if(!arguments.length)return this._values();if(!e.isArray(arguments[0]))return this.options.values&&this.options.values.length?this._values(t):this.value();r=this.options.values,i=arguments[0];for(s=0;s<r.length;s+=1)r[s]=this._trimAlignValue(i[s]),this._change(null,s);this._refreshValue()},_setOption:function(t,n){var r,i=0;e.isArray(this.options.values)&&(i=this.options.values.length),e.Widget.prototype._setOption.apply(this,arguments);switch(t){case"disabled":n?(this.handles.filter(".ui-state-focus").blur(),this.handles.removeClass("ui-state-hover"),this.handles.prop("disabled",!0),this.element.addClass("ui-disabled")):(this.handles.prop("disabled",!1),this.element.removeClass("ui-disabled"));break;case"orientation":this._detectOrientation(),this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation),this._refreshValue();break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":this._animateOff=!0,this._refreshValue();for(r=0;r<i;r+=1)this._change(null,r);this._animateOff=!1;break;case"min":case"max":this._animateOff=!0,this._refreshValue(),this._animateOff=!1}},_value:function(){var e=this.options.value;return e=this._trimAlignValue(e),e},_values:function(e){var t,n,r;if(arguments.length)return t=this.options.values[e],t=this._trimAlignValue(t),t;n=this.options.values.slice();for(r=0;r<n.length;r+=1)n[r]=this._trimAlignValue(n[r]);return n},_trimAlignValue:function(e){if(e<=this._valueMin())return this._valueMin();if(e>=this._valueMax())return this._valueMax();var t=this.options.step>0?this.options.step:1,n=(e-this._valueMin())%t,r=e-n;return Math.abs(n)*2>=t&&(r+=n>0?t:-t),parseFloat(r.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var t,n,r,i,s,o=this.options.range,u=this.options,a=this,f=this._animateOff?!1:u.animate,l={};this.options.values&&this.options.values.length?this.handles.each(function(r){n=(a.values(r)-a._valueMin())/(a._valueMax()-a._valueMin())*100,l[a.orientation==="horizontal"?"left":"bottom"]=n+"%",e(this).stop(1,1)[f?"animate":"css"](l,u.animate),a.options.range===!0&&(a.orientation==="horizontal"?(r===0&&a.range.stop(1,1)[f?"animate":"css"]({left:n+"%"},u.animate),r===1&&a.range[f?"animate":"css"]({width:n-t+"%"},{queue:!1,duration:u.animate})):(r===0&&a.range.stop(1,1)[f?"animate":"css"]({bottom:n+"%"},u.animate),r===1&&a.range[f?"animate":"css"]({height:n-t+"%"},{queue:!1,duration:u.animate}))),t=n}):(r=this.value(),i=this._valueMin(),s=this._valueMax(),n=s!==i?(r-i)/(s-i)*100:0,l[this.orientation==="horizontal"?"left":"bottom"]=n+"%",this.handle.stop(1,1)[f?"animate":"css"](l,u.animate),o==="min"&&this.orientation==="horizontal"&&this.range.stop(1,1)[f?"animate":"css"]({width:n+"%"},u.animate),o==="max"&&this.orientation==="horizontal"&&this.range[f?"animate":"css"]({width:100-n+"%"},{queue:!1,duration:u.animate}),o==="min"&&this.orientation==="vertical"&&this.range.stop(1,1)[f?"animate":"css"]({height:n+"%"},u.animate),o==="max"&&this.orientation==="vertical"&&this.range[f?"animate":"css"]({height:100-n+"%"},{queue:!1,duration:u.animate}))}})})(jQuery);(function(e,t){e.widget("ui.sortable",e.ui.mouse,{version:"1.9.1",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3},_create:function(){var e=this.options;this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.floating=this.items.length?e.axis==="x"||/left|right/.test(this.items[0].item.css("float"))||/inline|table-cell/.test(this.items[0].item.css("display")):!1,this.offset=this.element.offset(),this._mouseInit(),this.ready=!0},_destroy:function(){this.element.removeClass("ui-sortable ui-sortable-disabled"),this._mouseDestroy();for(var e=this.items.length-1;e>=0;e--)this.items[e].item.removeData(this.widgetName+"-item");return this},_setOption:function(t,n){t==="disabled"?(this.options[t]=n,this.widget().toggleClass("ui-sortable-disabled",!!n)):e.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(t,n){var r=this;if(this.reverting)return!1;if(this.options.disabled||this.options.type=="static")return!1;this._refreshItems(t);var i=null,s=e(t.target).parents().each(function(){if(e.data(this,r.widgetName+"-item")==r)return i=e(this),!1});e.data(t.target,r.widgetName+"-item")==r&&(i=e(t.target));if(!i)return!1;if(this.options.handle&&!n){var o=!1;e(this.options.handle,i).find("*").andSelf().each(function(){this==t.target&&(o=!0)});if(!o)return!1}return this.currentItem=i,this._removeCurrentsFromItems(),!0},_mouseStart:function(t,n,r){var i=this.options;this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(t),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},e.extend(this.offset,{click:{left:t.pageX-this.offset.left,top:t.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(t),this.originalPageX=t.pageX,this.originalPageY=t.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!=this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),i.containment&&this._setContainment(),i.cursor&&(e("body").css("cursor")&&(this._storedCursor=e("body").css("cursor")),e("body").css("cursor",i.cursor)),i.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",i.opacity)),i.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",i.zIndex)),this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",t,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions();if(!r)for(var s=this.containers.length-1;s>=0;s--)this.containers[s]._trigger("activate",t,this._uiHash(this));return e.ui.ddmanager&&(e.ui.ddmanager.current=this),e.ui.ddmanager&&!i.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(t),!0},_mouseDrag:function(t){this.position=this._generatePosition(t),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs);if(this.options.scroll){var n=this.options,r=!1;this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-t.pageY<n.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+n.scrollSpeed:t.pageY-this.overflowOffset.top<n.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-n.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-t.pageX<n.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+n.scrollSpeed:t.pageX-this.overflowOffset.left<n.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-n.scrollSpeed)):(t.pageY-e(document).scrollTop()<n.scrollSensitivity?r=e(document).scrollTop(e(document).scrollTop()-n.scrollSpeed):e(window).height()-(t.pageY-e(document).scrollTop())<n.scrollSensitivity&&(r=e(document).scrollTop(e(document).scrollTop()+n.scrollSpeed)),t.pageX-e(document).scrollLeft()<n.scrollSensitivity?r=e(document).scrollLeft(e(document).scrollLeft()-n.scrollSpeed):e(window).width()-(t.pageX-e(document).scrollLeft())<n.scrollSensitivity&&(r=e(document).scrollLeft(e(document).scrollLeft()+n.scrollSpeed))),r!==!1&&e.ui.ddmanager&&!n.dropBehaviour&&e.ui.ddmanager.prepareOffsets(this,t)}this.positionAbs=this._convertPositionTo("absolute");if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";for(var i=this.items.length-1;i>=0;i--){var s=this.items[i],o=s.item[0],u=this._intersectsWithPointer(s);if(!u)continue;if(s.instance!==this.currentContainer)continue;if(o!=this.currentItem[0]&&this.placeholder[u==1?"next":"prev"]()[0]!=o&&!e.contains(this.placeholder[0],o)&&(this.options.type=="semi-dynamic"?!e.contains(this.element[0],o):!0)){this.direction=u==1?"down":"up";if(this.options.tolerance!="pointer"&&!this._intersectsWithSides(s))break;this._rearrange(t,s),this._trigger("change",t,this._uiHash());break}}return this._contactContainers(t),e.ui.ddmanager&&e.ui.ddmanager.drag(this,t),this._trigger("sort",t,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(t,n){if(!t)return;e.ui.ddmanager&&!this.options.dropBehaviour&&e.ui.ddmanager.drop(this,t);if(this.options.revert){var r=this,i=this.placeholder.offset();this.reverting=!0,e(this.helper).animate({left:i.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollLeft),top:i.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){r._clear(t)})}else this._clear(t,n);return!1},cancel:function(){if(this.dragging){this._mouseUp({target:null}),this.options.helper=="original"?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var t=this.containers.length-1;t>=0;t--)this.containers[t]._trigger("deactivate",null,this._uiHash(this)),this.containers[t].containerCache.over&&(this.containers[t]._trigger("out",null,this._uiHash(this)),this.containers[t].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.options.helper!="original"&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),e.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?e(this.domPosition.prev).after(this.currentItem):e(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(t){var n=this._getItemsAsjQuery(t&&t.connected),r=[];return t=t||{},e(n).each(function(){var n=(e(t.item||this).attr(t.attribute||"id")||"").match(t.expression||/(.+)[-=_](.+)/);n&&r.push((t.key||n[1]+"[]")+"="+(t.key&&t.expression?n[1]:n[2]))}),!r.length&&t.key&&r.push(t.key+"="),r.join("&")},toArray:function(t){var n=this._getItemsAsjQuery(t&&t.connected),r=[];return t=t||{},n.each(function(){r.push(e(t.item||this).attr(t.attribute||"id")||"")}),r},_intersectsWith:function(e){var t=this.positionAbs.left,n=t+this.helperProportions.width,r=this.positionAbs.top,i=r+this.helperProportions.height,s=e.left,o=s+e.width,u=e.top,a=u+e.height,f=this.offset.click.top,l=this.offset.click.left,c=r+f>u&&r+f<a&&t+l>s&&t+l<o;return this.options.tolerance=="pointer"||this.options.forcePointerForContainers||this.options.tolerance!="pointer"&&this.helperProportions[this.floating?"width":"height"]>e[this.floating?"width":"height"]?c:s<t+this.helperProportions.width/2&&n-this.helperProportions.width/2<o&&u<r+this.helperProportions.height/2&&i-this.helperProportions.height/2<a},_intersectsWithPointer:function(t){var n=this.options.axis==="x"||e.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),r=this.options.axis==="y"||e.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),i=n&&r,s=this._getDragVerticalDirection(),o=this._getDragHorizontalDirection();return i?this.floating?o&&o=="right"||s=="down"?2:1:s&&(s=="down"?2:1):!1},_intersectsWithSides:function(t){var n=e.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),r=e.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),i=this._getDragVerticalDirection(),s=this._getDragHorizontalDirection();return this.floating&&s?s=="right"&&r||s=="left"&&!r:i&&(i=="down"&&n||i=="up"&&!n)},_getDragVerticalDirection:function(){var e=this.positionAbs.top-this.lastPositionAbs.top;return e!=0&&(e>0?"down":"up")},_getDragHorizontalDirection:function(){var e=this.positionAbs.left-this.lastPositionAbs.left;return e!=0&&(e>0?"right":"left")},refresh:function(e){return this._refreshItems(e),this.refreshPositions(),this},_connectWith:function(){var e=this.options;return e.connectWith.constructor==String?[e.connectWith]:e.connectWith},_getItemsAsjQuery:function(t){var n=[],r=[],i=this._connectWith();if(i&&t)for(var s=i.length-1;s>=0;s--){var o=e(i[s]);for(var u=o.length-1;u>=0;u--){var a=e.data(o[u],this.widgetName);a&&a!=this&&!a.options.disabled&&r.push([e.isFunction(a.options.items)?a.options.items.call(a.element):e(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a])}}r.push([e.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):e(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]);for(var s=r.length-1;s>=0;s--)r[s][0].each(function(){n.push(this)});return e(n)},_removeCurrentsFromItems:function(){var t=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=e.grep(this.items,function(e){for(var n=0;n<t.length;n++)if(t[n]==e.item[0])return!1;return!0})},_refreshItems:function(t){this.items=[],this.containers=[this];var n=this.items,r=[[e.isFunction(this.options.items)?this.options.items.call(this.element[0],t,{item:this.currentItem}):e(this.options.items,this.element),this]],i=this._connectWith();if(i&&this.ready)for(var s=i.length-1;s>=0;s--){var o=e(i[s]);for(var u=o.length-1;u>=0;u--){var a=e.data(o[u],this.widgetName);a&&a!=this&&!a.options.disabled&&(r.push([e.isFunction(a.options.items)?a.options.items.call(a.element[0],t,{item:this.currentItem}):e(a.options.items,a.element),a]),this.containers.push(a))}}for(var s=r.length-1;s>=0;s--){var f=r[s][1],l=r[s][0];for(var u=0,c=l.length;u<c;u++){var h=e(l[u]);h.data(this.widgetName+"-item",f),n.push({item:h,instance:f,width:0,height:0,left:0,top:0})}}},refreshPositions:function(t){this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());for(var n=this.items.length-1;n>=0;n--){var r=this.items[n];if(r.instance!=this.currentContainer&&this.currentContainer&&r.item[0]!=this.currentItem[0])continue;var i=this.options.toleranceElement?e(this.options.toleranceElement,r.item):r.item;t||(r.width=i.outerWidth(),r.height=i.outerHeight());var s=i.offset();r.left=s.left,r.top=s.top}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(var n=this.containers.length-1;n>=0;n--){var s=this.containers[n].element.offset();this.containers[n].containerCache.left=s.left,this.containers[n].containerCache.top=s.top,this.containers[n].containerCache.width=this.containers[n].element.outerWidth(),this.containers[n].containerCache.height=this.containers[n].element.outerHeight()}return this},_createPlaceholder:function(t){t=t||this;var n=t.options;if(!n.placeholder||n.placeholder.constructor==String){var r=n.placeholder;n.placeholder={element:function(){var n=e(document.createElement(t.currentItem[0].nodeName)).addClass(r||t.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];return r||(n.style.visibility="hidden"),n},update:function(e,i){if(r&&!n.forcePlaceholderSize)return;i.height()||i.height(t.currentItem.innerHeight()-parseInt(t.currentItem.css("paddingTop")||0,10)-parseInt(t.currentItem.css("paddingBottom")||0,10)),i.width()||i.width(t.currentItem.innerWidth()-parseInt(t.currentItem.css("paddingLeft")||0,10)-parseInt(t.currentItem.css("paddingRight")||0,10))}}}t.placeholder=e(n.placeholder.element.call(t.element,t.currentItem)),t.currentItem.after(t.placeholder),n.placeholder.update(t,t.placeholder)},_contactContainers:function(t){var n=null,r=null;for(var i=this.containers.length-1;i>=0;i--){if(e.contains(this.currentItem[0],this.containers[i].element[0]))continue;if(this._intersectsWith(this.containers[i].containerCache)){if(n&&e.contains(this.containers[i].element[0],n.element[0]))continue;n=this.containers[i],r=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",t,this._uiHash(this)),this.containers[i].containerCache.over=0)}if(!n)return;if(this.containers.length===1)this.containers[r]._trigger("over",t,this._uiHash(this)),this.containers[r].containerCache.over=1;else{var s=1e4,o=null,u=this.containers[r].floating?"left":"top",a=this.containers[r].floating?"width":"height",f=this.positionAbs[u]+this.offset.click[u];for(var l=this.items.length-1;l>=0;l--){if(!e.contains(this.containers[r].element[0],this.items[l].item[0]))continue;if(this.items[l].item[0]==this.currentItem[0])continue;var c=this.items[l].item.offset()[u],h=!1;Math.abs(c-f)>Math.abs(c+this.items[l][a]-f)&&(h=!0,c+=this.items[l][a]),Math.abs(c-f)<s&&(s=Math.abs(c-f),o=this.items[l],this.direction=h?"up":"down")}if(!o&&!this.options.dropOnEmpty)return;this.currentContainer=this.containers[r],o?this._rearrange(t,o,null,!0):this._rearrange(t,null,this.containers[r].element,!0),this._trigger("change",t,this._uiHash()),this.containers[r]._trigger("change",t,this._uiHash(this)),this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[r]._trigger("over",t,this._uiHash(this)),this.containers[r].containerCache.over=1}},_createHelper:function(t){var n=this.options,r=e.isFunction(n.helper)?e(n.helper.apply(this.element[0],[t,this.currentItem])):n.helper=="clone"?this.currentItem.clone():this.currentItem;return r.parents("body").length||e(n.appendTo!="parent"?n.appendTo:this.currentItem[0].parentNode)[0].appendChild(r[0]),r[0]==this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(r[0].style.width==""||n.forceHelperSize)&&r.width(this.currentItem.width()),(r[0].style.height==""||n.forceHelperSize)&&r.height(this.currentItem.height()),r},_adjustOffsetFromHelper:function(t){typeof t=="string"&&(t=t.split(" ")),e.isArray(t)&&(t={left:+t[0],top:+t[1]||0}),"left"in t&&(this.offset.click.left=t.left+this.margins.left),"right"in t&&(this.offset.click.left=this.helperProportions.width-t.right+this.margins.left),"top"in t&&(this.offset.click.top=t.top+this.margins.top),"bottom"in t&&(this.offset.click.top=this.helperProportions.height-t.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var t=this.offsetParent.offset();this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&e.contains(this.scrollParent[0],this.offsetParent[0])&&(t.left+=this.scrollParent.scrollLeft(),t.top+=this.scrollParent.scrollTop());if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&e.ui.ie)t={top:0,left:0};return{top:t.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:t.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var e=this.currentItem.position();return{top:e.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:e.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var t=this.options;t.containment=="parent"&&(t.containment=this.helper[0].parentNode);if(t.containment=="document"||t.containment=="window")this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,e(t.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(e(t.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(t.containment)){var n=e(t.containment)[0],r=e(t.containment).offset(),i=e(n).css("overflow")!="hidden";this.containment=[r.left+(parseInt(e(n).css("borderLeftWidth"),10)||0)+(parseInt(e(n).css("paddingLeft"),10)||0)-this.margins.left,r.top+(parseInt(e(n).css("borderTopWidth"),10)||0)+(parseInt(e(n).css("paddingTop"),10)||0)-this.margins.top,r.left+(i?Math.max(n.scrollWidth,n.offsetWidth):n.offsetWidth)-(parseInt(e(n).css("borderLeftWidth"),10)||0)-(parseInt(e(n).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,r.top+(i?Math.max(n.scrollHeight,n.offsetHeight):n.offsetHeight)-(parseInt(e(n).css("borderTopWidth"),10)||0)-(parseInt(e(n).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(t,n){n||(n=this.position);var r=t=="absolute"?1:-1,i=this.options,s=this.cssPosition!="absolute"||this.scrollParent[0]!=document&&!!e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(s[0].tagName);return{top:n.top+this.offset.relative.top*r+this.offset.parent.top*r-(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():o?0:s.scrollTop())*r,left:n.left+this.offset.relative.left*r+this.offset.parent.left*r-(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():o?0:s.scrollLeft())*r}},_generatePosition:function(t){var n=this.options,r=this.cssPosition!="absolute"||this.scrollParent[0]!=document&&!!e.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,i=/(html|body)/i.test(r[0].tagName);this.cssPosition=="relative"&&(this.scrollParent[0]==document||this.scrollParent[0]==this.offsetParent[0])&&(this.offset.relative=this._getRelativeOffset());var s=t.pageX,o=t.pageY;if(this.originalPosition){this.containment&&(t.pageX-this.offset.click.left<this.containment[0]&&(s=this.containment[0]+this.offset.click.left),t.pageY-this.offset.click.top<this.containment[1]&&(o=this.containment[1]+this.offset.click.top),t.pageX-this.offset.click.left>this.containment[2]&&(s=this.containment[2]+this.offset.click.left),t.pageY-this.offset.click.top>this.containment[3]&&(o=this.containment[3]+this.offset.click.top));if(n.grid){var u=this.originalPageY+Math.round((o-this.originalPageY)/n.grid[1])*n.grid[1];o=this.containment?u-this.offset.click.top<this.containment[1]||u-this.offset.click.top>this.containment[3]?u-this.offset.click.top<this.containment[1]?u+n.grid[1]:u-n.grid[1]:u:u;var a=this.originalPageX+Math.round((s-this.originalPageX)/n.grid[0])*n.grid[0];s=this.containment?a-this.offset.click.left<this.containment[0]||a-this.offset.click.left>this.containment[2]?a-this.offset.click.left<this.containment[0]?a+n.grid[0]:a-n.grid[0]:a:a}}return{top:o-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():i?0:r.scrollTop()),left:s-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():i?0:r.scrollLeft())}},_rearrange:function(e,t,n,r){n?n[0].appendChild(this.placeholder[0]):t.item[0].parentNode.insertBefore(this.placeholder[0],this.direction=="down"?t.item[0]:t.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var i=this.counter;this._delay(function(){i==this.counter&&this.refreshPositions(!r)})},_clear:function(t,n){this.reverting=!1;var r=[];!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null;if(this.helper[0]==this.currentItem[0]){for(var i in this._storedCSS)if(this._storedCSS[i]=="auto"||this._storedCSS[i]=="static")this._storedCSS[i]="";this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();this.fromOutside&&!n&&r.push(function(e){this._trigger("receive",e,this._uiHash(this.fromOutside))}),(this.fromOutside||this.domPosition.prev!=this.currentItem.prev().not(".ui-sortable-helper")[0]||this.domPosition.parent!=this.currentItem.parent()[0])&&!n&&r.push(function(e){this._trigger("update",e,this._uiHash())}),this!==this.currentContainer&&(n||(r.push(function(e){this._trigger("remove",e,this._uiHash())}),r.push(function(e){return function(t){e._trigger("receive",t,this._uiHash(this))}}.call(this,this.currentContainer)),r.push(function(e){return function(t){e._trigger("update",t,this._uiHash(this))}}.call(this,this.currentContainer))));for(var i=this.containers.length-1;i>=0;i--)n||r.push(function(e){return function(t){e._trigger("deactivate",t,this._uiHash(this))}}.call(this,this.containers[i])),this.containers[i].containerCache.over&&(r.push(function(e){return function(t){e._trigger("out",t,this._uiHash(this))}}.call(this,this.containers[i])),this.containers[i].containerCache.over=0);this._storedCursor&&e("body").css("cursor",this._storedCursor),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex",this._storedZIndex=="auto"?"":this._storedZIndex),this.dragging=!1;if(this.cancelHelperRemoval){if(!n){this._trigger("beforeStop",t,this._uiHash());for(var i=0;i<r.length;i++)r[i].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!1}n||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.helper[0]!=this.currentItem[0]&&this.helper.remove(),this.helper=null;if(!n){for(var i=0;i<r.length;i++)r[i].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!0},_trigger:function(){e.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(t){var n=t||this;return{helper:n.helper,placeholder:n.placeholder||e([]),position:n.position,originalPosition:n.originalPosition,offset:n.positionAbs,item:n.currentItem,sender:t?t.element:null}}})})(jQuery);(function(e){function t(e){return function(){var t=this.element.val();e.apply(this,arguments),this._refresh(),t!==this.element.val()&&this._trigger("change")}}e.widget("ui.spinner",{version:"1.9.1",defaultElement:"<input>",widgetEventPrefix:"spin",options:{culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var t={},n=this.element;return e.each(["min","max","step"],function(e,r){var i=n.attr(r);i!==undefined&&i.length&&(t[r]=i)}),t},_events:{keydown:function(e){this._start(e)&&this._keydown(e)&&e.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(e){if(this.cancelBlur){delete this.cancelBlur;return}this._refresh(),this.previous!==this.element.val()&&this._trigger("change",e)},mousewheel:function(e,t){if(!t)return;if(!this.spinning&&!this._start(e))return!1;this._spin((t>0?1:-1)*this.options.step,e),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(e)},100),e.preventDefault()},"mousedown .ui-spinner-button":function(t){function r(){var e=this.element[0]===this.document[0].activeElement;e||(this.element.focus(),this.previous=n,this._delay(function(){this.previous=n}))}var n;n=this.element[0]===this.document[0].activeElement?this.previous:this.element.val(),t.preventDefault(),r.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,r.call(this)});if(this._start(t)===!1)return;this._repeat(null,e(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(t){if(!e(t.currentTarget).hasClass("ui-state-active"))return;if(this._start(t)===!1)return!1;this._repeat(null,e(t.currentTarget).hasClass("ui-spinner-up")?1:-1,t)},"mouseleave .ui-spinner-button":"_stop"},_draw:function(){var e=this.uiSpinner=this.element.addClass("ui-spinner-input").attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());this.element.attr("role","spinbutton"),this.buttons=e.find(".ui-spinner-button").attr("tabIndex",-1).button().removeClass("ui-corner-all"),this.buttons.height()>Math.ceil(e.height()*.5)&&e.height()>0&&e.height(e.height()),this.options.disabled&&this.disable()},_keydown:function(t){var n=this.options,r=e.ui.keyCode;switch(t.keyCode){case r.UP:return this._repeat(null,1,t),!0;case r.DOWN:return this._repeat(null,-1,t),!0;case r.PAGE_UP:return this._repeat(null,n.page,t),!0;case r.PAGE_DOWN:return this._repeat(null,-n.page,t),!0}return!1},_uiSpinnerHtml:function(){return"<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>"},_buttonHtml:function(){return"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'><span class='ui-icon "+this.options.icons.up+"'>&#9650;</span>"+"</a>"+"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>"+"<span class='ui-icon "+this.options.icons.down+"'>&#9660;</span>"+"</a>"},_start:function(e){return!this.spinning&&this._trigger("start",e)===!1?!1:(this.counter||(this.counter=1),this.spinning=!0,!0)},_repeat:function(e,t,n){e=e||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,t,n)},e),this._spin(t*this.options.step,n)},_spin:function(e,t){var n=this.value()||0;this.counter||(this.counter=1),n=this._adjustValue(n+e*this._increment(this.counter));if(!this.spinning||this._trigger("spin",t,{value:n})!==!1)this._value(n),this.counter++},_increment:function(t){var n=this.options.incremental;return n?e.isFunction(n)?n(t):Math.floor(t*t*t/5e4-t*t/500+17*t/200+1):1},_precision:function(){var e=this._precisionOf(this.options.step);return this.options.min!==null&&(e=Math.max(e,this._precisionOf(this.options.min))),e},_precisionOf:function(e){var t=e.toString(),n=t.indexOf(".");return n===-1?0:t.length-n-1},_adjustValue:function(e){var t,n,r=this.options;return t=r.min!==null?r.min:0,n=e-t,n=Math.round(n/r.step)*r.step,e=t+n,e=parseFloat(e.toFixed(this._precision())),r.max!==null&&e>r.max?r.max:r.min!==null&&e<r.min?r.min:e},_stop:function(e){if(!this.spinning)return;clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",e)},_setOption:function(e,t){if(e==="culture"||e==="numberFormat"){var n=this._parse(this.element.val());this.options[e]=t,this.element.val(this._format(n));return}(e==="max"||e==="min"||e==="step")&&typeof t=="string"&&(t=this._parse(t)),this._super(e,t),e==="disabled"&&(t?(this.element.prop("disabled",!0),this.buttons.button("disable")):(this.element.prop("disabled",!1),this.buttons.button("enable")))},_setOptions:t(function(e){this._super(e),this._value(this.element.val())}),_parse:function(e){return typeof e=="string"&&e!==""&&(e=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(e,10,this.options.culture):+e),e===""||isNaN(e)?null:e},_format:function(e){return e===""?"":window.Globalize&&this.options.numberFormat?Globalize.format(e,this.options.numberFormat,this.options.culture):e},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},_value:function(e,t){var n;e!==""&&(n=this._parse(e),n!==null&&(t||(n=this._adjustValue(n)),e=this._format(n))),this.element.val(e),this._refresh()},_destroy:function(){this.element.removeClass("ui-spinner-input").prop("disabled",!1).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:t(function(e){this._stepUp(e)}),_stepUp:function(e){this._spin((e||1)*this.options.step)},stepDown:t(function(e){this._stepDown(e)}),_stepDown:function(e){this._spin((e||1)*-this.options.step)},pageUp:t(function(e){this._stepUp((e||1)*this.options.page)}),pageDown:t(function(e){this._stepDown((e||1)*this.options.page)}),value:function(e){if(!arguments.length)return this._parse(this.element.val());t(this._value).call(this,e)},widget:function(){return this.uiSpinner}})})(jQuery);(function(e,t){function i(){return++n}function s(e){return e.hash.length>1&&e.href.replace(r,"")===location.href.replace(r,"")}var n=0,r=/#.*$/;e.widget("ui.tabs",{version:"1.9.1",delay:300,options:{active:null,collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_create:function(){var t=this,n=this.options,r=n.active,i=location.hash.substring(1);this.running=!1,this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible",n.collapsible).delegate(".ui-tabs-nav > li","mousedown"+this.eventNamespace,function(t){e(this).is(".ui-state-disabled")&&t.preventDefault()}).delegate(".ui-tabs-anchor","focus"+this.eventNamespace,function(){e(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this._processTabs();if(r===null){i&&this.tabs.each(function(t,n){if(e(n).attr("aria-controls")===i)return r=t,!1}),r===null&&(r=this.tabs.index(this.tabs.filter(".ui-tabs-active")));if(r===null||r===-1)r=this.tabs.length?0:!1}r!==!1&&(r=this.tabs.index(this.tabs.eq(r)),r===-1&&(r=n.collapsible?!1:0)),n.active=r,!n.collapsible&&n.active===!1&&this.anchors.length&&(n.active=0),e.isArray(n.disabled)&&(n.disabled=e.unique(n.disabled.concat(e.map(this.tabs.filter(".ui-state-disabled"),function(e){return t.tabs.index(e)}))).sort()),this.options.active!==!1&&this.anchors.length?this.active=this._findActive(this.options.active):this.active=e(),this._refresh(),this.active.length&&this.load(n.active)},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):e()}},_tabKeydown:function(t){var n=e(this.document[0].activeElement).closest("li"),r=this.tabs.index(n),i=!0;if(this._handlePageNav(t))return;switch(t.keyCode){case e.ui.keyCode.RIGHT:case e.ui.keyCode.DOWN:r++;break;case e.ui.keyCode.UP:case e.ui.keyCode.LEFT:i=!1,r--;break;case e.ui.keyCode.END:r=this.anchors.length-1;break;case e.ui.keyCode.HOME:r=0;break;case e.ui.keyCode.SPACE:t.preventDefault(),clearTimeout(this.activating),this._activate(r);return;case e.ui.keyCode.ENTER:t.preventDefault(),clearTimeout(this.activating),this._activate(r===this.options.active?!1:r);return;default:return}t.preventDefault(),clearTimeout(this.activating),r=this._focusNextTab(r,i),t.ctrlKey||(n.attr("aria-selected","false"),this.tabs.eq(r).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",r)},this.delay))},_panelKeydown:function(t){if(this._handlePageNav(t))return;t.ctrlKey&&t.keyCode===e.ui.keyCode.UP&&(t.preventDefault(),this.active.focus())},_handlePageNav:function(t){if(t.altKey&&t.keyCode===e.ui.keyCode.PAGE_UP)return this._activate(this._focusNextTab(this.options.active-1,!1)),!0;if(t.altKey&&t.keyCode===e.ui.keyCode.PAGE_DOWN)return this._activate(this._focusNextTab(this.options.active+1,!0)),!0},_findNextTab:function(t,n){function i(){return t>r&&(t=0),t<0&&(t=r),t}var r=this.tabs.length-1;while(e.inArray(i(),this.options.disabled)!==-1)t=n?t+1:t-1;return t},_focusNextTab:function(e,t){return e=this._findNextTab(e,t),this.tabs.eq(e).focus(),e},_setOption:function(e,t){if(e==="active"){this._activate(t);return}if(e==="disabled"){this._setupDisabled(t);return}this._super(e,t),e==="collapsible"&&(this.element.toggleClass("ui-tabs-collapsible",t),!t&&this.options.active===!1&&this._activate(0)),e==="event"&&this._setupEvents(t),e==="heightStyle"&&this._setupHeightStyle(t)},_tabId:function(e){return e.attr("aria-controls")||"ui-tabs-"+i()},_sanitizeSelector:function(e){return e?e.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var t=this.options,n=this.tablist.children(":has(a[href])");t.disabled=e.map(n.filter(".ui-state-disabled"),function(e){return n.index(e)}),this._processTabs(),t.active===!1||!this.anchors.length?(t.active=!1,this.active=e()):this.active.length&&!e.contains(this.tablist[0],this.active[0])?this.tabs.length===t.disabled.length?(t.active=!1,this.active=e()):this._activate(this._findNextTab(Math.max(0,t.active-1),!1)):t.active=this.tabs.index(this.active),this._refresh()},_refresh:function(){this._setupDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-expanded":"false","aria-hidden":"true"}),this.active.length?(this.active.addClass("ui-tabs-active ui-state-active").attr({"aria-selected":"true",tabIndex:0}),this._getPanelForTab(this.active).show().attr({"aria-expanded":"true","aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var t=this;this.tablist=this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role","tablist"),this.tabs=this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({role:"tab",tabIndex:-1}),this.anchors=this.tabs.map(function(){return e("a",this)[0]}).addClass("ui-tabs-anchor").attr({role:"presentation",tabIndex:-1}),this.panels=e(),this.anchors.each(function(n,r){var i,o,u,a=e(r).uniqueId().attr("id"),f=e(r).closest("li"),l=f.attr("aria-controls");s(r)?(i=r.hash,o=t.element.find(t._sanitizeSelector(i))):(u=t._tabId(f),i="#"+u,o=t.element.find(i),o.length||(o=t._createPanel(u),o.insertAfter(t.panels[n-1]||t.tablist)),o.attr("aria-live","polite")),o.length&&(t.panels=t.panels.add(o)),l&&f.data("ui-tabs-aria-controls",l),f.attr({"aria-controls":i.substring(1),"aria-labelledby":a}),o.attr("aria-labelledby",a)}),this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role","tabpanel")},_getList:function(){return this.element.find("ol,ul").eq(0)},_createPanel:function(t){return e("<div>").attr("id",t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy",!0)},_setupDisabled:function(t){e.isArray(t)&&(t.length?t.length===this.anchors.length&&(t=!0):t=!1);for(var n=0,r;r=this.tabs[n];n++)t===!0||e.inArray(n,t)!==-1?e(r).addClass("ui-state-disabled").attr("aria-disabled","true"):e(r).removeClass("ui-state-disabled").removeAttr("aria-disabled");this.options.disabled=t},_setupEvents:function(t){var n={click:function(e){e.preventDefault()}};t&&e.each(t.split(" "),function(e,t){n[t]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(this.anchors,n),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(t){var n,r,i=this.element.parent();t==="fill"?(e.support.minHeight||(r=i.css("overflow"),i.css("overflow","hidden")),n=i.height(),this.element.siblings(":visible").each(function(){var t=e(this),r=t.css("position");if(r==="absolute"||r==="fixed")return;n-=t.outerHeight(!0)}),r&&i.css("overflow",r),this.element.children().not(this.panels).each(function(){n-=e(this).outerHeight(!0)}),this.panels.each(function(){e(this).height(Math.max(0,n-e(this).innerHeight()+e(this).height()))}).css("overflow","auto")):t==="auto"&&(n=0,this.panels.each(function(){n=Math.max(n,e(this).height("").height())}).height(n))},_eventHandler:function(t){var n=this.options,r=this.active,i=e(t.currentTarget),s=i.closest("li"),o=s[0]===r[0],u=o&&n.collapsible,a=u?e():this._getPanelForTab(s),f=r.length?this._getPanelForTab(r):e(),l={oldTab:r,oldPanel:f,newTab:u?e():s,newPanel:a};t.preventDefault();if(s.hasClass("ui-state-disabled")||s.hasClass("ui-tabs-loading")||this.running||o&&!n.collapsible||this._trigger("beforeActivate",t,l)===!1)return;n.active=u?!1:this.tabs.index(s),this.active=o?e():s,this.xhr&&this.xhr.abort(),!f.length&&!a.length&&e.error("jQuery UI Tabs: Mismatching fragment identifier."),a.length&&this.load(this.tabs.index(s),t),this._toggle(t,l)},_toggle:function(t,n){function o(){r.running=!1,r._trigger("activate",t,n)}function u(){n.newTab.closest("li").addClass("ui-tabs-active ui-state-active"),i.length&&r.options.show?r._show(i,r.options.show,o):(i.show(),o())}var r=this,i=n.newPanel,s=n.oldPanel;this.running=!0,s.length&&this.options.hide?this._hide(s,this.options.hide,function(){n.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),u()}):(n.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),s.hide(),u()),s.attr({"aria-expanded":"false","aria-hidden":"true"}),n.oldTab.attr("aria-selected","false"),i.length&&s.length?n.oldTab.attr("tabIndex",-1):i.length&&this.tabs.filter(function(){return e(this).attr("tabIndex")===0}).attr("tabIndex",-1),i.attr({"aria-expanded":"true","aria-hidden":"false"}),n.newTab.attr({"aria-selected":"true",tabIndex:0})},_activate:function(t){var n,r=this._findActive(t);if(r[0]===this.active[0])return;r.length||(r=this.active),n=r.find(".ui-tabs-anchor")[0],this._eventHandler({target:n,currentTarget:n,preventDefault:e.noop})},_findActive:function(t){return t===!1?e():this.tabs.eq(t)},_getIndex:function(e){return typeof e=="string"&&(e=this.anchors.index(this.anchors.filter("[href$='"+e+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible"),this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role"),this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeData("href.tabs").removeData("load.tabs").removeUniqueId(),this.tabs.add(this.panels).each(function(){e.data(this,"ui-tabs-destroy")?e(this).remove():e(this).removeClass("ui-state-default ui-state-active ui-state-disabled ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role")}),this.tabs.each(function(){var t=e(this),n=t.data("ui-tabs-aria-controls");n?t.attr("aria-controls",n):t.removeAttr("aria-controls")}),this.options.heightStyle!=="content"&&this.panels.css("height","")},enable:function(n){var r=this.options.disabled;if(r===!1)return;n===t?r=!1:(n=this._getIndex(n),e.isArray(r)?r=e.map(r,function(e){return e!==n?e:null}):r=e.map(this.tabs,function(e,t){return t!==n?t:null})),this._setupDisabled(r)},disable:function(n){var r=this.options.disabled;if(r===!0)return;if(n===t)r=!0;else{n=this._getIndex(n);if(e.inArray(n,r)!==-1)return;e.isArray(r)?r=e.merge([n],r).sort():r=[n]}this._setupDisabled(r)},load:function(t,n){t=this._getIndex(t);var r=this,i=this.tabs.eq(t),o=i.find(".ui-tabs-anchor"),u=this._getPanelForTab(i),a={tab:i,panel:u};if(s(o[0]))return;this.xhr=e.ajax(this._ajaxSettings(o,n,a)),this.xhr&&this.xhr.statusText!=="canceled"&&(i.addClass("ui-tabs-loading"),u.attr("aria-busy","true"),this.xhr.success(function(e){setTimeout(function(){u.html(e),r._trigger("load",n,a)},1)}).complete(function(e,t){setTimeout(function(){t==="abort"&&r.panels.stop(!1,!0),i.removeClass("ui-tabs-loading"),u.removeAttr("aria-busy"),e===r.xhr&&delete r.xhr},1)}))},_ajaxSettings:function(t,n,r){var i=this;return{url:t.attr("href"),beforeSend:function(t,s){return i._trigger("beforeLoad",n,e.extend({jqXHR:t,ajaxSettings:s},r))}}},_getPanelForTab:function(t){var n=e(t).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+n))}}),e.uiBackCompat!==!1&&(e.ui.tabs.prototype._ui=function(e,t){return{tab:e,panel:t,index:this.anchors.index(e)}},e.widget("ui.tabs",e.ui.tabs,{url:function(e,t){this.anchors.eq(e).attr("href",t)}}),e.widget("ui.tabs",e.ui.tabs,{options:{ajaxOptions:null,cache:!1},_create:function(){this._super();var t=this;this._on({tabsbeforeload:function(n,r){if(e.data(r.tab[0],"cache.tabs")){n.preventDefault();return}r.jqXHR.success(function(){t.options.cache&&e.data(r.tab[0],"cache.tabs",!0)})}})},_ajaxSettings:function(t,n,r){var i=this.options.ajaxOptions;return e.extend({},i,{error:function(e,t){try{i.error(e,t,r.tab.closest("li").index(),r.tab[0])}catch(n){}}},this._superApply(arguments))},_setOption:function(e,t){e==="cache"&&t===!1&&this.anchors.removeData("cache.tabs"),this._super(e,t)},_destroy:function(){this.anchors.removeData("cache.tabs"),this._super()},url:function(e){this.anchors.eq(e).removeData("cache.tabs"),this._superApply(arguments)}}),e.widget("ui.tabs",e.ui.tabs,{abort:function(){this.xhr&&this.xhr.abort()}}),e.widget("ui.tabs",e.ui.tabs,{options:{spinner:"<em>Loading&#8230;</em>"},_create:function(){this._super(),this._on({tabsbeforeload:function(e,t){if(e.target!==this.element[0]||!this.options.spinner)return;var n=t.tab.find("span"),r=n.html();n.html(this.options.spinner),t.jqXHR.complete(function(){n.html(r)})}})}}),e.widget("ui.tabs",e.ui.tabs,{options:{enable:null,disable:null},enable:function(t){var n=this.options,r;if(t&&n.disabled===!0||e.isArray(n.disabled)&&e.inArray(t,n.disabled)!==-1)r=!0;this._superApply(arguments),r&&this._trigger("enable",null,this._ui(this.anchors[t],this.panels[t]))},disable:function(t){var n=this.options,r;if(t&&n.disabled===!1||e.isArray(n.disabled)&&e.inArray(t,n.disabled)===-1)r=!0;this._superApply(arguments),r&&this._trigger("disable",null,this._ui(this.anchors[t],this.panels[t]))}}),e.widget("ui.tabs",e.ui.tabs,{options:{add:null,remove:null,tabTemplate:"<li><a href='#{href}'><span>#{label}</span></a></li>"},add:function(n,r,i){i===t&&(i=this.anchors.length);var s,o,u=this.options,a=e(u.tabTemplate.replace(/#\{href\}/g,n).replace(/#\{label\}/g,r)),f=n.indexOf("#")?this._tabId(a):n.replace("#","");return a.addClass("ui-state-default ui-corner-top").data("ui-tabs-destroy",!0),a.attr("aria-controls",f),s=i>=this.tabs.length,o=this.element.find("#"+f),o.length||(o=this._createPanel(f),s?i>0?o.insertAfter(this.panels.eq(-1)):o.appendTo(this.element):o.insertBefore(this.panels[i])),o.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").hide(),s?a.appendTo(this.tablist):a.insertBefore(this.tabs[i]),u.disabled=e.map(u.disabled,function(e){return e>=i?++e:e}),this.refresh(),this.tabs.length===1&&u.active===!1&&this.option("active",0),this._trigger("add",null,this._ui(this.anchors[i],this.panels[i])),this},remove:function(t){t=this._getIndex(t);var n=this.options,r=this.tabs.eq(t).remove(),i=this._getPanelForTab(r).remove();return r.hasClass("ui-tabs-active")&&this.anchors.length>2&&this._activate(t+(t+1<this.anchors.length?1:-1)),n.disabled=e.map(e.grep(n.disabled,function(e){return e!==t}),function(e){return e>=t?--e:e}),this.refresh(),this._trigger("remove",null,this._ui(r.find("a")[0],i[0])),this}}),e.widget("ui.tabs",e.ui.tabs,{length:function(){return this.anchors.length}}),e.widget("ui.tabs",e.ui.tabs,{options:{idPrefix:"ui-tabs-"},_tabId:function(t){var n=t.is("li")?t.find("a[href]"):t;return n=n[0],e(n).closest("li").attr("aria-controls")||n.title&&n.title.replace(/\s/g,"_").replace(/[^\w\u00c0-\uFFFF\-]/g,"")||this.options.idPrefix+i()}}),e.widget("ui.tabs",e.ui.tabs,{options:{panelTemplate:"<div></div>"},_createPanel:function(t){return e(this.options.panelTemplate).attr("id",t).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy",!0)}}),e.widget("ui.tabs",e.ui.tabs,{_create:function(){var e=this.options;e.active===null&&e.selected!==t&&(e.active=e.selected===-1?!1:e.selected),this._super(),e.selected=e.active,e.selected===!1&&(e.selected=-1)},_setOption:function(e,t){if(e!=="selected")return this._super(e,t);var n=this.options;this._super("active",t===-1?!1:t),n.selected=n.active,n.selected===!1&&(n.selected=-1)},_eventHandler:function(){this._superApply(arguments),this.options.selected=this.options.active,this.options.selected===!1&&(this.options.selected=-1)}}),e.widget("ui.tabs",e.ui.tabs,{options:{show:null,select:null},_create:function(){this._super(),this.options.active!==!1&&this._trigger("show",null,this._ui(this.active.find(".ui-tabs-anchor")[0],this._getPanelForTab(this.active)[0]))},_trigger:function(e,t,n){var r=this._superApply(arguments);return r?(e==="beforeActivate"&&n.newTab.length?r=this._super("select",t,{tab:n.newTab.find(".ui-tabs-anchor")[0],panel:n.newPanel[0],index:n.newTab.closest("li").index()}):e==="activate"&&n.newTab.length&&(r=this._super("show",t,{tab:n.newTab.find(".ui-tabs-anchor")[0],panel:n.newPanel[0],index:n.newTab.closest("li").index()})),r):!1}}),e.widget("ui.tabs",e.ui.tabs,{select:function(e){e=this._getIndex(e);if(e===-1){if(!this.options.collapsible||this.options.selected===-1)return;e=this.options.selected}this.anchors.eq(e).trigger(this.options.event+this.eventNamespace)}}),function(){var t=0;e.widget("ui.tabs",e.ui.tabs,{options:{cookie:null},_create:function(){var e=this.options,t;e.active==null&&e.cookie&&(t=parseInt(this._cookie(),10),t===-1&&(t=!1),e.active=t),this._super()},_cookie:function(n){var r=[this.cookie||(this.cookie=this.options.cookie.name||"ui-tabs-"+ ++t)];return arguments.length&&(r.push(n===!1?-1:n),r.push(this.options.cookie)),e.cookie.apply(null,r)},_refresh:function(){this._super(),this.options.cookie&&this._cookie(this.options.active,this.options.cookie)},_eventHandler:function(){this._superApply(arguments),this.options.cookie&&this._cookie(this.options.active,this.options.cookie)},_destroy:function(){this._super(),this.options.cookie&&this._cookie(null,this.options.cookie)}})}(),e.widget("ui.tabs",e.ui.tabs,{_trigger:function(t,n,r){var i=e.extend({},r);return t==="load"&&(i.panel=i.panel[0],i.tab=i.tab.find(".ui-tabs-anchor")[0]),this._super(t,n,i)}}),e.widget("ui.tabs",e.ui.tabs,{options:{fx:null},_getFx:function(){var t,n,r=this.options.fx;return r&&(e.isArray(r)?(t=r[0],n=r[1]):t=n=r),r?{show:n,hide:t}:null},_toggle:function(e,t){function o(){n.running=!1,n._trigger("activate",e,t)}function u(){t.newTab.closest("li").addClass("ui-tabs-active ui-state-active"),r.length&&s.show?r.animate(s.show,s.show.duration,function(){o()}):(r.show(),o())}var n=this,r=t.newPanel,i=t.oldPanel,s=this._getFx();if(!s)return this._super(e,t);n.running=!0,i.length&&s.hide?i.animate(s.hide,s.hide.duration,function(){t.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),u()}):(t.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active"),i.hide(),u())}}))})(jQuery);(function(e){function n(t,n){var r=(t.attr("aria-describedby")||"").split(/\s+/);r.push(n),t.data("ui-tooltip-id",n).attr("aria-describedby",e.trim(r.join(" ")))}function r(t){var n=t.data("ui-tooltip-id"),r=(t.attr("aria-describedby")||"").split(/\s+/),i=e.inArray(n,r);i!==-1&&r.splice(i,1),t.removeData("ui-tooltip-id"),r=e.trim(r.join(" ")),r?t.attr("aria-describedby",r):t.removeAttr("aria-describedby")}var t=0;e.widget("ui.tooltip",{version:"1.9.1",options:{content:function(){return e(this).attr("title")},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flipfit"},show:!0,tooltipClass:null,track:!1,close:null,open:null},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.options.disabled&&this._disable()},_setOption:function(t,n){var r=this;if(t==="disabled"){this[n?"_disable":"_enable"](),this.options[t]=n;return}this._super(t,n),t==="content"&&e.each(this.tooltips,function(e,t){r._updateContent(t)})},_disable:function(){var t=this;e.each(this.tooltips,function(n,r){var i=e.Event("blur");i.target=i.currentTarget=r[0],t.close(i,!0)}),this.element.find(this.options.items).andSelf().each(function(){var t=e(this);t.is("[title]")&&t.data("ui-tooltip-title",t.attr("title")).attr("title","")})},_enable:function(){this.element.find(this.options.items).andSelf().each(function(){var t=e(this);t.data("ui-tooltip-title")&&t.attr("title",t.data("ui-tooltip-title"))})},open:function(t){var n=this,r=e(t?t.target:this.element).closest(this.options.items);if(!r.length)return;if(this.options.track&&r.data("ui-tooltip-id")){this._find(r).position(e.extend({of:r},this.options.position)),this._off(this.document,"mousemove");return}r.attr("title")&&r.data("ui-tooltip-title",r.attr("title")),r.data("tooltip-open",!0),t&&t.type==="mouseover"&&r.parents().each(function(){var t;e(this).data("tooltip-open")&&(t=e.Event("blur"),t.target=t.currentTarget=this,n.close(t,!0)),this.title&&(e(this).uniqueId(),n.parents[this.id]={element:this,title:this.title},this.title="")}),this._updateContent(r,t)},_updateContent:function(e,t){var n,r=this.options.content,i=this;if(typeof r=="string")return this._open(t,e,r);n=r.call(e[0],function(n){if(!e.data("tooltip-open"))return;i._delay(function(){this._open(t,e,n)})}),n&&this._open(t,e,n)},_open:function(t,r,i){function f(e){a.of=e;if(s.is(":hidden"))return;s.position(a)}var s,o,u,a=e.extend({},this.options.position);if(!i)return;s=this._find(r);if(s.length){s.find(".ui-tooltip-content").html(i);return}r.is("[title]")&&(t&&t.type==="mouseover"?r.attr("title",""):r.removeAttr("title")),s=this._tooltip(r),n(r,s.attr("id")),s.find(".ui-tooltip-content").html(i),this.options.track&&t&&/^mouse/.test(t.originalEvent.type)?(this._on(this.document,{mousemove:f}),f(t)):s.position(e.extend({of:r},this.options.position)),s.hide(),this._show(s,this.options.show),this.options.show&&this.options.show.delay&&(u=setInterval(function(){s.is(":visible")&&(f(a.of),clearInterval(u))},e.fx.interval)),this._trigger("open",t,{tooltip:s}),o={keyup:function(t){if(t.keyCode===e.ui.keyCode.ESCAPE){var n=e.Event(t);n.currentTarget=r[0],this.close(n,!0)}},remove:function(){this._removeTooltip(s)}};if(!t||t.type==="mouseover")o.mouseleave="close";if(!t||t.type==="focusin")o.focusout="close";this._on(r,o)},close:function(t){var n=this,i=e(t?t.currentTarget:this.element),s=this._find(i);if(this.closing)return;i.data("ui-tooltip-title")&&i.attr("title",i.data("ui-tooltip-title")),r(i),s.stop(!0),this._hide(s,this.options.hide,function(){n._removeTooltip(e(this))}),i.removeData("tooltip-open"),this._off(i,"mouseleave focusout keyup"),i[0]!==this.element[0]&&this._off(i,"remove"),this._off(this.document,"mousemove"),t&&t.type==="mouseleave"&&e.each(this.parents,function(e,t){t.element.title=t.title,delete n.parents[e]}),this.closing=!0,this._trigger("close",t,{tooltip:s}),this.closing=!1},_tooltip:function(n){var r="ui-tooltip-"+t++,i=e("<div>").attr({id:r,role:"tooltip"}).addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content "+(this.options.tooltipClass||""));return e("<div>").addClass("ui-tooltip-content").appendTo(i),i.appendTo(this.document[0].body),e.fn.bgiframe&&i.bgiframe(),this.tooltips[r]=n,i},_find:function(t){var n=t.data("ui-tooltip-id");return n?e("#"+n):e()},_removeTooltip:function(e){e.remove(),delete this.tooltips[e.attr("id")]},_destroy:function(){var t=this;e.each(this.tooltips,function(n,r){var i=e.Event("blur");i.target=i.currentTarget=r[0],t.close(i,!0),e("#"+n).remove(),r.data("ui-tooltip-title")&&(r.attr("title",r.data("ui-tooltip-title")),r.removeData("ui-tooltip-title"))})}})})(jQuery);/**
 * jQuery UI versions between 1.7 and above changes the getters management.
 */
var fixJQueryGetters = function($) {

	if ($.ui.version != '1.7') return;
		
	$.each(['listview', 'treeview', 'searchpanel'], function(index, widget) {
		var w = $.ui[widget];
		if (typeof w === undefined) return;
		w.getter = w.prototype.getter;
	});
};$.extend({
    parseJSON: function( data ) {
        if ( typeof data !== "string" || !data ) {
            return null;
        }    
        data = jQuery.trim( data );    
        if ( /^[\],:{}\s]*$/.test(data.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, "@")
            .replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]")
            .replace(/(?:^|:|,)(?:\s*\[)+/g, "")) ) {    
            return window.JSON && window.JSON.parse ?
                window.JSON.parse( data ) :
                (new Function("return " + data))();    
        } else {
            jQuery.error( _("Invalid JSON: ") + data );
        }
    }
});


(function($){$.toJSON=function(o)
{if(typeof(JSON)=='object'&&JSON.stringify)
return JSON.stringify(o);var type=typeof(o);if(o===null)
return"null";if(type=="undefined")
return undefined;if(type=="number"||type=="boolean")
return o+"";if(type=="string")
return $.quoteString(o);if(type=='object')
{if(typeof o.toJSON=="function")
return $.toJSON(o.toJSON());if(o.constructor===Date)
{var month=o.getUTCMonth()+1;if(month<10)month='0'+month;var day=o.getUTCDate();if(day<10)day='0'+day;var year=o.getUTCFullYear();var hours=o.getUTCHours();if(hours<10)hours='0'+hours;var minutes=o.getUTCMinutes();if(minutes<10)minutes='0'+minutes;var seconds=o.getUTCSeconds();if(seconds<10)seconds='0'+seconds;var milli=o.getUTCMilliseconds();if(milli<100)milli='0'+milli;if(milli<10)milli='0'+milli;return'"'+year+'-'+month+'-'+day+'T'+
hours+':'+minutes+':'+seconds+'.'+milli+'Z"';}
if(o.constructor===Array)
{var ret=[];for(var i=0;i<o.length;i++)
ret.push($.toJSON(o[i])||"null");return"["+ret.join(",")+"]";}
var pairs=[];for(var k in o){var name;var type=typeof k;if(type=="number")
name='"'+k+'"';else if(type=="string")
name=$.quoteString(k);else
continue;if(typeof o[k]=="function")
continue;var val=$.toJSON(o[k]);pairs.push(name+":"+val);}
return"{"+pairs.join(", ")+"}";}};$.evalJSON=function(src)
{if(typeof(JSON)=='object'&&JSON.parse)
return JSON.parse(src);return eval("("+src+")");};$.secureEvalJSON=function(src)
{if(typeof(JSON)=='object'&&JSON.parse)
return JSON.parse(src);var filtered=src;filtered=filtered.replace(/\\["\\\/bfnrtu]/g,'@');filtered=filtered.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,']');filtered=filtered.replace(/(?:^|:|,)(?:\s*\[)+/g,'');if(/^[\],:{}\s]*$/.test(filtered))
return eval("("+src+")");else
throw new SyntaxError("Error parsing JSON, source is not valid.");};$.quoteString=function(string)
{if(string.match(_escapeable))
{return'"'+string.replace(_escapeable,function(a)
{var c=_meta[a];if(typeof c==='string')return c;c=a.charCodeAt();return'\\u00'+Math.floor(c/16).toString(16)+(c%16).toString(16);})+'"';}
return'"'+string+'"';};var _escapeable=/["\\\x00-\x1f\x7f-\x9f]/g;var _meta={'\b':'\\b','\t':'\\t','\n':'\\n','\f':'\\f','\r':'\\r','"':'\\"','\\':'\\\\'};})(jQuery);/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


(function() {

	function namespace() {

		// Creates the ximdex namespace
		if (!window.com) window.com = {};
		window.com.ximdex = {};
		window.X = window.com.ximdex;

		var baseUrl = '##BASE_URL##';

		X = Object.extend(X, {
			XMLNS_XIM: 'http://ximdex.com/schema/1.0',
			baseUrl: baseUrl,
			restUrl: baseUrl + '/xmd/loadaction.php',
			iconsUrl: baseUrl + '/xmd/images/icons',
			tourInstance: null,
			getUID: function() {
				return Object.rand(10000000, 99999999);
			}
		});

		X.getTourInstance = function() {
			if (X.tourInstance === null) {
				X.tourInstance = new X.Tour();
			}
			return X.tourInstance;
		};

		X.checkSession = function(status) {
			var redirect = false;
			status = parseInt(status);
			switch (status) {
				case 401:
					location = X.baseUrl;
					redirect = true;
					break;
			}
			return redirect;
		}
	}



	if (typeof(Object.extend) != 'function') {
		Object.extend = function(subclass, superclass) {
			for (var o in superclass) {
				//if (!subclass[o]) {
					subclass[o] = superclass[o];
				//}
			}
			return subclass;
		}
	}

	Object.extend(Object, {
		isArray: function(object) {
			object = Object.isUndefined(object) ? null : object;
			return (
				object !== null &&
				typeof(object) == 'object' &&
				'splice' in object &&
				'join' in object
			);
		},
		isFunction: function(object) {
			object = Object.isUndefined(object) ? null : object;
			return typeof(object) == 'function';
		},
		isObject: function(object) {
			object = Object.isUndefined(object) ? null : object;
			return (
				object !== null &&
				typeof(object) == 'object' &&
				!Object.isArray(object)
			);
		},
		isString: function(object) {
			object = Object.isUndefined(object) ? null : object;
			return typeof(object) == 'string';
		},
		isNumber: function(object) {
			object = parseInt(Object.isUndefined(object) ? null : object);
			return !isNaN(object);
		},
		isUndefined: function(object) {
			return typeof(object) == 'undefined';
		},
		isBoolean: function(object) {
			object = Object.isUndefined(object) ? 0 : object;
			return typeof(object.valueOf()) == 'boolean';
		},
		isEmpty: function(object) {
			var empty = (
				object === null ||
				Object.isUndefined(object) ||
				(Object.isString(object) && object.length == 0)
			);
			return empty;
		},
		clone: function(object) {
			return Object.extend({}, object);
		}
	});

	if (!Object.isFunction(window.$A)) {
		window.$A = function(array) {
			return Array.prototype.slice.call(array);
		}
	}

	if (!Object.isFunction(Object.iface)) {
		Object.iface = function(/* methods */) {
			var methods = $A(arguments);
			var F = function() {
				throw new Error('This class must be implemented!');
			}
			for (var i=0, l=methods.length; i<l; i++) {
				F.prototype[methods[i]] = (function() {
					var method = methods[i];
					return function() {
						throw new Error('Method %s must be implemented!'.printf(method));
					}
				})();
			}
			return F;
		}
	}

	if (!Object.isFunction(Object.xo_create)) {
		Object.xo_create = function(/* superclass [, superclass, ...] */) {

			var args = $A(arguments);
			var superclass = args.shift() || Object.xo_create({});
			superclass = superclass.prototype || superclass;

			var fn = function() {
				if (Object.isFunction(this._init)) {
					this._init.apply(this, arguments);
				}
			};

			Object.extend(fn.prototype, superclass);
			for (var i=0; i<args.length; i++) {
				Object.extend(fn.prototype, (args[i].prototype || args[i]));
			}

			fn.prototype.constructor = fn;

			if (!fn.prototype._init) {
				fn.prototype._init = function() {};
			}

			fn.superclass = superclass;
			fn._super = function(/* scope, method, arguments */) {
				var args = $A(arguments);
				var scope = args.shift();
				var method = args.shift();
				try {
					if (Object.isFunction(this.superclass[method])) {
						return this.superclass[method].apply(scope, args);
					}
				} catch(e) {
					throw e;
				}
			}
			fn._construct = function(/* scope, arguments */) {
				var args = $A(arguments);
				var scope = args.shift();
				try {
					return this.superclass._init.apply(scope, args);
				} catch(e) {
					throw e;
				}
			}

			return fn;
		}
	}

	if (!Object.isFunction(Object.rand)) {
		Object.rand = function(lower, upper) {
			lower = lower || 0;
			upper = upper || 1;
			var n = Math.floor((upper-(lower-1)) * Math.random()) + lower;
			return n;
		}
	}

	if (!Object.isFunction(Function.prototype.bind)) {
		Function.prototype.bind = function(/* scope, arguments */) {
			var args = $A(arguments);
			var scope = args.shift();
			var method = this;
			return function() {
				var a = $A(arguments).concat(args);
				return method.apply(scope, a);
			}
		}
	}

	if (!Object.isFunction(Array.prototype.contains)) {
		Array.prototype.contains = function(value) {
			var l = this.length;
			while (--l >= 0) {
				if (this[l] === value) return true;
			}
			return false;
		}
	}

	if (!Object.isFunction(Array.prototype.clone)) {
		Array.prototype.clone = function() {
//			console.group();
//			console.log(this)
			var ret = [].concat(this);
//			console.log(ret);
//			console.groupEnd();
			return ret;
		}
	}

	if (!Object.isFunction(Array.prototype.each)) {
		Array.prototype.each = function(callback) {
			if (!Object.isFunction(callback)) return;
			for (var i=0, l=this.length; i<l; i++) {
				callback(i, this[i]);
			}
		}
	}

	if (!Object.isFunction(Array.prototype.unique)) {
		Array.prototype.unique = function() {
			var arr = [];
			for (var i=0, l=this.length; i<l; i++) {
				if (!arr.contains(this[i])) {
					arr.push(this[i]);
				}
			}
			return arr;
		}
	}

	function printf(string, values) {
		var c = 0;
		return string.replace(/%[sd]/g, function(match, position, string) {
			var value = values[c];
			switch (match) {
				case '%s':
					value = new String(value).valueOf();
					break;
				case '%d':
					value = new Number(value).valueOf();
					break;
			}
			c++;
			return value;
		});
	}
	if (!Object.isFunction(String.prototype.printf)) {
		String.prototype.printf = function() {
			return printf(this.valueOf(), $A(arguments));
		}
	}
	if (!Object.isFunction(Array.prototype.printf)) {
		Array.prototype.printf = function(string) {
			return printf(string, this);
		}
	}

	// Characters to substitute:: TAB, SPACE, LINE FEED, CARRIAGE RETURN
	var chars = ['\u0009', '\u0020', '\u000A', '\u000D'];

	if (!Object.isFunction(String.prototype.ltrim)) {
		String.prototype.ltrim = function() {
			var str = this.valueOf();
			for (var i=0, l=str.length; i<l; i++) {
				if (chars.contains(str.charAt(0))) {
					str = str.substring(1);
				} else {
					break;
				}
			}
			return str;
		}
	}
	if (!Object.isFunction(String.prototype.rtrim)) {
		String.prototype.rtrim = function() {
			var str = this.valueOf();
			for (var i=str.length-1; i>=0; i=str.length-1) {
				if (chars.contains(str.charAt(str.length-1))) {
					str = str.substring(0, str.length-1);
				} else {
					break;
				}
			}
			return str;
		}
	}
	if (!Object.isFunction(String.prototype.trim)) {
		String.prototype.trim = function() {
			return this.valueOf().ltrim().rtrim();
		}
	}

	// Loads a script
	if (!Object.isFunction(Object.loadScript)) {
		Object.loadScript = function() {

			var args = $A(arguments);
			if (args.length == 0) return;

			// Triggered when all the scripts are loaded
			var onComplete = null;
			// Triggered when one script is loaded
			var onLoad = null;

			if (Object.isArray(args[0])) args = args[0];

			if (Object.isFunction(args[0])) {
				onComplete = args.splice(0, 1)[0];
			}

			if (Object.isObject(args[0])) {
				onComplete = args[0].onComplete || null;
				onLoad = args[0].onLoad || null;
				args = args[0].js || [];
			}

			var count = args.length;
			var head = document.getElementsByTagName('head')[0];
			args.each(function(index, item) {

				Object.ajax(item, {
					onComplete: function(data, xhr) {
						var script = document.createElement('script');
						script.setAttribute('type', 'text/javascript');
						script.setAttribute('src', item);
						script.onload = (function(script, data, xhr) {
							return function() {
								// Handle memory leak in IE
								script.onload = null;
								head.removeChild(script);
								count--;
								if (Object.isFunction(onLoad)) {
									onLoad(data);
								}
								if (Object.isFunction(onComplete) && count == 0) {
									onComplete();
								}
							};

						})(script, data, xhr);
						head.appendChild(script);
					}
				});
			}.bind(this));
		}
	}

	// Loads a css stylesheet
	if (!Object.isFunction(Object.loadCss)) {
		Object.loadCss = function() {
			var args = $A(arguments);
			if (args.length == 0) return;
			if (Object.isArray(args[0])) args = args[0];
			var head = document.getElementsByTagName('head')[0];
			args.each(function(index, item) {
				var css = document.createElement('link');
				css.setAttribute('type', 'text/css');
				css.setAttribute('href', item);
				css.setAttribute('rel', 'stylesheet');
				head.appendChild(css);
//				console.log(item);
			}.bind(this));
		}
	}

	// Loads css stylesheets and scripts, css always goes first
	if (!Object.isFunction(Object.loadAssets)) {
		Object.loadAssets = function() {
			var args = $A(arguments);
			if (args.length == 0) return;

			var jsExp = /\.js$/i;
			var cssExp = /\.css$/i;
			var assets = {
				script: [],
				css: []
			};
			args.each(function(index, item) {
				// NOTE: Functions will be callbacks on Object.loadScript()
				if (jsExp.test(item) || Object.isFunction(item)) {
					assets.script.push(item);
				} else if (cssExp.test(item)) {
					assets.css.push(item);
				}
			}.bind(this));
			Object.loadCss.apply(Object, assets.css);
			Object.loadScript.apply(Object, assets.script);
		}
	}


	/**
	 *  The AJAX Request object!
	 */
	if (!Object.isFunction(Object.ajax)) {
		Object.ajax = function(url, options) {

			this.send = function(url, options) {

				// TODO: Parse and work with options.params!

				options = options || {};
				options.async = options.async || true;
				options.method = options.method || 'GET';
				options.method = options.method.toUpperCase();
				options.params = this._parseParams(options.params || {});
				options.type = options.type || 'text';
				options.type = options.type.toLowerCase();
				options.content = options.content || '';

				var req = new XMLHttpRequest();
				req.options = options;

				req.onreadystatechange = function() {

					this.req = req;
					this.options = options;

					try {

						if (req.readyState != 4) return;

						/**
						 * There is a known bug in MSIE, when the server response is 204
						 * the status code in IE is 1223.
						 *
						 * http://webbugtrack.blogspot.com/2008/05/bug-122-in-ie-http-204-status-may.html
						 * http://prototype.lighthouseapp.com/projects/8886/tickets/207-ajax-request-considers-http-204-a-failure-under-ie-only
						 * http://www.mail-archive.com/jquery-en@googlegroups.com/msg13093.html
						 */
						var status = (req.status != 1223) ? req.status : 204;
						if (status >= 400) {
							if (options.onError) options.onError(req);
							return;
						}

					} catch(e) {
						return;
					}

					var data = null;
					switch (options.type) {
						case 'text':
							data = req.responseText;
							break;
						case 'xml':
							// TODO: Create XML object?
							data = req.responseText;
							break;
						case 'json':
							try {
								data = eval('new function() {return '+req.responseText+';}');
							} catch(e) {
								data = {};
							}
							break;
					}

					if (options.onComplete) {
						options.onComplete(data, req);
					}
				};


				if (options.method == 'GET' && options.params.length > 0) {
					url = '%s?%s'.printf(url, options.params);
					options.params = null;
				}
				req.open(options.method, url, options.async);
				if (options.method == 'POST') {
					req.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
				}
				req.send(options.params);
			};

			this._parseParams = function(params) {
				if (Object.isString(params)) return params;
				var ret = [];
				for (var o in params) {
					ret.push('%s=%s'.printf(o, params[o]));
				}
				ret = ret.join('&');
				return ret;
			}

			this.send(url, options);

		}
	}

	if (!Object.isFunction(Object.get)) {
		Object.get = function(url, options) {
			options.method = 'get';
			Object.ajax(url, options);
		}
	}

	if (!Object.isFunction(Object.getJSON)) {
		Object.getJSON = function(url, options) {
			options.method = 'get';
			options.type = 'json';
			Object.ajax(url, options);
		}
	}

	if (!Object.isFunction(Object.post)) {
		Object.post = function(url, options) {
			options.method = 'post';
			Object.ajax(url, options);
		}
	}

	/**
	 * @param string wn Widget name
	 * @param string wi Widget ID
	 * @param string a Action name
	 * @param string m Module name
	 */
	Object.getWidgetConf = function(params) {
		/*Object.getJSON(X.restUrl, {
			params: {
				method: 'wconf',
				wn: params.wn || '',
				wi: params.wi || '',
				a: params.a || '',
				m: params.m || ''
			},
			onComplete: params.onComplete || null
		});*/
		$.get(
			X.restUrl,
			{
				method: 'wconf',
				wn: params.wn || '',
				wi: params.wi || '',
				a: params.a || '',
				m: params.m || ''
			},
			function(data, status) {
				data = eval(data);
				if (Object.isFunction(params.onComplete)) params.onComplete(data);
			}
		);
	}

	if (!Object.isFunction(Object.urldecode)) {
		Object.urldecode = function(str) {
			// Decodes URL-encoded string
			//
			// version: 905.3122
			// discuss at: http://phpjs.org/functions/urldecode
			// +   original by: Philip Peterson
			// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
			// +      input by: AJ
			// +   improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
			// +   improved by: Brett Zamir (http://brett-zamir.me)
			// +      input by: travc
			// +      input by: Brett Zamir (http://brett-zamir.me)
			// +   bugfixed by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
			// +   improved by: Lars Fischer
			// %          note 1: info on what encoding functions to use from: http://xkr.us/articles/javascript/encode-compare/
			// *     example 1: urldecode('Kevin+van+Zonneveld%21');
			// *     returns 1: 'Kevin van Zonneveld!'
			// *     example 2: urldecode('http%3A%2F%2Fkevin.vanzonneveld.net%2F');
			// *     returns 2: 'http://kevin.vanzonneveld.net/'
			// *     example 3: urldecode('http%3A%2F%2Fwww.google.nl%2Fsearch%3Fq%3Dphp.js%26ie%3Dutf-8%26oe%3Dutf-8%26aq%3Dt%26rls%3Dcom.ubuntu%3Aen-US%3Aunofficial%26client%3Dfirefox-a');
			// *     returns 3: 'http://www.google.nl/search?q=php.js&ie=utf-8&oe=utf-8&aq=t&rls=com.ubuntu:en-US:unofficial&client=firefox-a'

			var histogram = {}, ret = str.toString(), unicodeStr='', hexEscStr='';

			var replacer = function(search, replace, str) {
			    var tmp_arr = [];
			    tmp_arr = str.split(search);
			    return tmp_arr.join(replace);
			};

			// The histogram is identical to the one in urlencode.
			histogram["'"]   = '%27';
			histogram['(']   = '%28';
			histogram[')']   = '%29';
			histogram['*']   = '%2A';
			histogram['~']   = '%7E';
			histogram['!']   = '%21';
			histogram['%20'] = '+';
			histogram['\u00DC'] = '%DC';
			histogram['\u00FC'] = '%FC';
			histogram['\u00C4'] = '%D4';
			histogram['\u00E4'] = '%E4';
			histogram['\u00D6'] = '%D6';
			histogram['\u00F6'] = '%F6';
			histogram['\u00DF'] = '%DF';
			histogram['\u20AC'] = '%80';
			histogram['\u0081'] = '%81';
			histogram['\u201A'] = '%82';
			histogram['\u0192'] = '%83';
			histogram['\u201E'] = '%84';
			histogram['\u2026'] = '%85';
			histogram['\u2020'] = '%86';
			histogram['\u2021'] = '%87';
			histogram['\u02C6'] = '%88';
			histogram['\u2030'] = '%89';
			histogram['\u0160'] = '%8A';
			histogram['\u2039'] = '%8B';
			histogram['\u0152'] = '%8C';
			histogram['\u008D'] = '%8D';
			histogram['\u017D'] = '%8E';
			histogram['\u008F'] = '%8F';
			histogram['\u0090'] = '%90';
			histogram['\u2018'] = '%91';
			histogram['\u2019'] = '%92';
			histogram['\u201C'] = '%93';
			histogram['\u201D'] = '%94';
			histogram['\u2022'] = '%95';
			histogram['\u2013'] = '%96';
			histogram['\u2014'] = '%97';
			histogram['\u02DC'] = '%98';
			histogram['\u2122'] = '%99';
			histogram['\u0161'] = '%9A';
			histogram['\u203A'] = '%9B';
			histogram['\u0153'] = '%9C';
			histogram['\u009D'] = '%9D';
			histogram['\u017E'] = '%9E';
			histogram['\u0178'] = '%9F';

			for (unicodeStr in histogram) {
			    hexEscStr = histogram[unicodeStr]; // Switch order when decoding
			    ret = replacer(hexEscStr, unicodeStr, ret); // Custom replace. No regexing
			}

			// End with decodeURIComponent, which most resembles PHP's encoding functions
			ret = decodeURIComponent(ret);

			return ret;
		}
	}

	namespace();


	X.ximModules = {
		modules: null,
		getAll: function() {
				if(X.ximModules.modules == null) return 0;
				return X.ximModules.modules;
			},
			get: function(module) {
				if(X.ximModules.modules == null) return 0;
				return X.ximModules.modules[module];
			},
			isEnabled: function(module) {
				if(X.ximModules.modules == null) return 0;
				return X.ximModules.modules[module]["enable"];
			},
			init: function()  {
				if(X.ximModules.modules != null) return null;

			$.getJSON(
				X.restUrl + '?method=modules&ajax=json',
				function(data) {
					X.ximModules.modules = data;
				}
			)
		}
	}




	X.widgetsVars = {
		widgets: null,
		parseValue: function(value) {
			var ret = undefined;
			try {
				if (['true', 'false', 'null', 'undefined', ''].contains(value)) {
					ret = eval(value);
				} else if (Object.isNumber(value)) {
					ret = parseInt(value, 10);
				} else if ( Object.isFunction(eval(value)) ) {
					ret = eval(value);
				} else {
					ret = value;
				}
			} catch(e) {
				ret = value;
			}
			return ret;
		},
		triggerLoaded: function(wname, widget) {
			var _object =  X.widgetsVars[wname];
			$(X.browser.actionEventSelector).trigger("widgetLoaded",  [{object: _object,  widget: widget}]);
		},

		getWidget: function(widget) {
			return X.widgetsVars[widget] || null;
		},

		getWidgetOfType: function(type) {
			return X.widgetsVars.widgets[type];
		},

		getLastWidgetOfType: function(wtype) {
			if(null == X.widgetsVars.widgets || null == X.widgetsVars.widgets[wtype])
				return null;

			var last = X.widgetsVars.widgets[wtype].length;
			return X.widgetsVars.widgets[wtype][last];
		},

		setWidgetType: function(widget,wtype) {

			if ( null == X.widgetsVars.widgets ) {
				X.widgetsVars.widgets = {};
			}

			if(null ==  X.widgetsVars.widgets[wtype] ) {
				X.widgetsVars.widgets[wtype] = [];
			}

			X.widgetsVars.widgets[wtype].push(widget);
		},

		getValue: function(widget, param) {
			var w = X.widgetsVars.getWidget(widget);
			var ret = (w && w[param] !== undefined) ? w[param] : null;
			return ret;
		},

		getValues: function(widget) {
			return X.widgetsVars[widget] || {};
		},
		setValue: function(widget, param, value) {
			var w = X.widgetsVars.getWidget(widget);
			if (w) w[param] = X.widgetsVars.parseValue(value);
		},
		setJSONString: function(widget, jsonString) {
			var json = $.parseJSON(jsonString);

			var w = X.widgetsVars[widget] = json;
			w["wid"] = widget;


			for (var o in w) {
				w[o] = X.widgetsVars.parseValue(w[o]);
			}


			try {
				w[o] = X.widgetsVars.setWidgetType(w, w["wtype"]);
			}catch(e) {
				//console.log("Widget "+widget+" without type");
			}

		}
	};

})();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


(function(X) {

	X.session = {
		
		options: {
			semicolon: '%3B'
		},
		
		get: function(name) {
			var value = null;
			var nameEQ = name + '=';
			var ca = document.cookie.split(';');
			for (var i=0, l=ca.length; i<l; i++) {
				var c = ca[i].trim();
				if (c.indexOf(nameEQ) == 0) {
					value = c.substring(nameEQ.length, c.length);
					break;
				}
			}
			var decoded = X.session.decodeValue(value);
			return decoded;
		},
		
		timeToMs: function(time) {
		
			// time can be expressed in milliseconds, hours (h),
			// days (d), months (m) and years (y).
			
			var reg = /^(\d+)([hdmy])?$/;
			if (!reg.test(time)) return null;
			
			var r = reg.exec(time);
			var value = r[1];
			var unit = r[2] === undefined ? null : r[2].toUpperCase();
			
			switch (unit) {
				case 'H':
					// hours
					value = value * 60 * 60;
					break;
				case 'D':
					value = value * 24 * 60 * 60;
					// days
					break;
				case 'M':
					value = value * 30 * 24 * 60 * 60;
					// months
					break;
				case 'Y':
					// years
					value = value * 365 * 24 * 60 * 60;
					break;
			}
			
			// to milliseconds
			return value * 1000;
		},
		
		set: function(name, value, expires) {
		
			expires = X.session.timeToMs(expires);
			expires = isNaN(expires) || Object.isEmpty(expires)
				? 31536000000	// one year
				: expires;
			
			var date = new Date();
			date.setTime(date.getTime() + expires);
			expires = date.toGMTString();
			
			var encoded = X.session.encodeValue(value);
			document.cookie = '%s=%s; expires=%s; path=/'.printf(name, encoded, expires);
		},
		
		encodeValue: function(value) {
			var encoded = $.toJSON(value);
			encoded = encoded.replace(/;/g, X.session.options.semicolon);
			return encoded;
		},
		
		decodeValue: function(value) {
			var re = new RegExp(X.session.options.semicolon, 'g');
			// NOTE: Lazy function definition
			X.session.decodeValue = function(value) {
				if (!Object.isString(value)) return value;
				var decoded = $.secureEvalJSON(value.replace(re, ';'));
				return decoded;
			}
			return X.session.decodeValue(value);
		}
	};

	/**
	 * <p>SessionTimer class</p>
	 * <p>Utility class to obtain minutes or miliseconds
	 *    until a given timestamp from the timestamp set 
	 * 	  in the object creation
	 * </p>
	 */
	X.SessionTimer = Object.xo_create({

	 _init: function(options) {
	
		this.inactivityLength = options.inactivityLength || 15;
		this.sessionLength = options.sessionLength || 10;
		this.gapToRefresh = options.gapToRefresh || 5;
		
		/* Inactivity dialog to show when inactivity limit is reached */
		this.inactivityDialog = new X.dialogs.MessageDialog({
								id: 'messageDialog',
								title: _('Inactivity period reached'),
								onclose: function(event,params) {
									window.location.href='##BASE_URL##/xmd/loadaction.php?action=logout';
								}.bind(this),
								message: [{type: 'STRING', message: _('You have reached the limit of inactivity period. Please, re-authenticate again in order to continue working. ')}],
								buttons: [{text: 'Login', value: 6, onPress: function() {window.location.href='##BASE_URL##/xmd/loadaction.php?action=logout'; this.close();} }]
							});
							
		/* Function to execute in the timeout timer */	
		var timeoutFn = function() {this.inactivityDialog.open();}.bind(this);
		
		/* Timer to show the inactivity dialog */
		this.inactivityTimer = setTimeout(function(){timeoutFn();}, this.inactivityLength*1000);
		
		
		// Refreshing the session 2 seconds before the session expires
		setInterval(function() {
					console.log("Refreshing session");
					jQuery.ajax({ url: '##BASE_URL##/xmd/loadaction.php?action=browser3&method=refreshSession',
  								  success: function(data) {
    							  	console.log("Session refreshed");
      							  },
      							  error: function(jqXhr, textStatus, error) {
      							  	console.log("Error refreshing session. Show dialog to re-authenticate?");
      							  }
      				});
      							},this.sessionLength*1000-this.gapToRefresh*1000); 
	
		// Clear and set again the inactivity timer when any event occurs in the document
		var registeredEvents = jQuery.event.global;
		for(event in registeredEvents) {
			jQuery(document).bind(event+"", function() { 
												clearTimeout(this.inactivityTimer);
												this.inactivityTimer = setTimeout(function(){timeoutFn();}, this.inactivityLength*1000);
														}.bind(this));
		}
		
	
					
	},
	
	getSessionDuration: function() {
		return this.sessionDuration;
	}
	
	});
})(com.ximdex);/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


(function(X) {

	X.Collection = Object.xo_create({
	
		collection: null,
		
		_init: function(options) {
			this.options = options || {unique: false};
			this.options.unique = Object.isBoolean(this.options.unique) ? this.options.unique : false;
			// NOTE: You can overwrite the comparation method to your needs
			this.contains = (Object.isFunction(this.options.contains) ? this.options.contains.bind(this) : null) || this.contains;
			this.collection = [];
		},
		
		add: function(item) {
			if (this.options.unique && this.collection.contains(item) !== false) {
				return this;
			}
			this.collection.push(item);
			return this;
		},
		
		remove: function(item) {
			var index = this.collection.contains(item);
			if (index !== false) {
				this.collection.splice(index, 1);
			}
			return this;
		},
		
		clear: function() {
			this.collection = [];
			return this;
		},
		
		contains: function(item) {
			return this.collection.contains(item);
		},
		
		size: function() {
			return this.collection.length;
		},
		
		get: function(index) {
			if (isNaN(index)) {
				return this.asArray();
			} else {
				return this.collection[index] || null;
			}
		},
		
		asArray: function() {
			return this.collection.clone();
		},
		
		setArray: function(selection) {
			this.collection = selection.clone();
			return this;
		}
	});

})(com.ximdex);/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


window.com.ximdex = Object.extend(window.com.ximdex, {
	responses: {
		YES: 1,
		NO: 2,
		OK: 3,
		CANCEL: 4,
		CLOSE: 5,
	}
});

window.com.ximdex = Object.extend(window.com.ximdex, {
	buttons: {
		BTN_YES: {text: 'Yes', value: com.ximdex.responses.YES, onPress: null},
		BTN_NO: {text: 'No', value: com.ximdex.responses.NO, onPress: null},
		BTN_OK: {text: 'Ok', value: com.ximdex.responses.OK, onPress: null},
		BTN_CANCEL: {text: 'Cancel', value: com.ximdex.responses.CANCEL, onPress: null},
		BTN_CLOSE: {text: 'Close', value: com.ximdex.responses.CLOSE, onPress: null}
	},
	dialogs: {}
});


X.dialogs.XimdexDialog = Object.xo_create({
	
	_init: function(options) {
	
		this._pressedButton = X.responses.CANCEL;
		
		var _b = options.buttons || [X.buttons.BTN_OK];
		var buttons = {};
		
		$.each(_b, function(index, item) {
			buttons[item.text] = (function(item, context) {
				var cb = null;
				if (Object.isFunction(item.onPress)) {
					cb = item.onPress;
				} else {
					cb = function() {
						this._pressedButton = item.value;
						this.close();
					};
				}
				return cb.bind(context);
			})(item, this);
		}.bind(this));
		
		options.buttons = buttons;
	
		this.options = Object.extend({
			id: 'ximdexdialog',
			owner: window,
			container: 'body',
			title: 'Browser dialog',
			width: 400,
			height: 200,
			close: function(event, ui) {
				//$(this).trigger('onclose', [{value: this.getValue(), dialog: this}]);
				if (Object.isFunction(this.options.onclose)) {
					this.options.onclose(event, {value: this.getValue(), dialog: this});
				}
			}.bind(this),
			bgiframe: true,
			autoOpen: false,
			modal: true,
			draggable: false,
			// Buttons callbacks
			onYes: null,
			onNo: null,
			onOk: null,
			onCancel: null,
			onClose: null,
			onError: null
		},
		options);
	
		this.dialog = $('<div/>')
						.addClass(this.options.id)
						.append(
							$('<div/>').addClass('dialog-content')
						)
						.appendTo(this.options.container)
						.dialog(this.options);
		
	},
	
	bind: function(eventType, eventData, handler) {
		$(this.dialog).bind(eventType, eventData, handler);
		return this;
	},
	
	trigger: function(eventType, params) {
		if (Object.isFunction(this.options[eventType])) {
			this.options[eventType](this, params);
		}
	},
	
	setContent: function(content) {
		$('.dialog-content', this.dialog).unbind().empty().append(content);
	},
	
	getValue: function() {
		return this._pressedButton;
	},
	
	open: function() {
		$(this.dialog).dialog('open');
	},
	
	close: function() {
		this.clear();
		$(this.dialog).dialog('close');
	},
	
	clear: function() {
		// Overwrite me!
	},
	
	destroy: function() {
		$(this.dialog).dialog('destroy').unbind().remove();
	}
});

X.dialogs.MessageDialog = Object.xo_create(X.dialogs.XimdexDialog, {

	_init: function(options) {
	
		options.message = options.message || '';
		
		X.dialogs.MessageDialog._construct(this, Object.extend({
			id: 'messagedialog',
			title: 'Message dialog'
		}, options));
		
		var content = $('.dialog-content', this.dialog);
		
		if (Object.isString(this.options.message)) {
		
			$(content).html(this.options.message);
		} else if (Object.isObject(this.options.message)) {

			$(content).append(this.options.message);
		} else if (Object.isArray(this.options.message)) {

			// message is an array of objects in the form [{type: INT, message: STRING} [, ...]]

			$.each(this.options.message, function(index, item) {
				$(content).append(
					$('<div/>')
						.addClass('dialog-message')
						.html(item.message)
					// TODO: Show an icon depending on item.type ??????
				);
			}.bind(this));
		}
		
		if (this.options.icon) {
			// Do something with the icon...
		}
	}
	
});

X.dialogs.InputDialog = Object.xo_create(X.dialogs.MessageDialog, {

	_init: function(options) {
	
		X.dialogs.InputDialog._construct(this, Object.extend({
			id: 'inputdialog',
			title: 'Input dialog',
			keypress: function(event) {this.close();}
		}, options));
		
		this.input = $('<input/>')
						.attr({
							type: 'text'
						})
						.addClass('dialog-input')
						.keypress(function(event) {
							if (event.keyCode == 13) {
								this._pressedButton = X.responses.OK;
								if (Object.isFunction(this.options.keypress)) {
									this.options.keypress(event);
								}
								
							}
						}.bind(this));
		
		$(this.dialog)
			.append(
				$('<div/>')
					.addClass('dialog-input-container')
					.append(
						this.input
					)
			);
	},
	
	getInput: function() {
		return $(this.input).val();
	},
	
	open: function() {
		X.dialogs.InputDialog._super(this, 'open');
		$(this.input).focus();
	},
	
	close: function() {
		X.dialogs.InputDialog._super(this, 'close');
	}
	
});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */

var XimTimer = function(interval) {

	this.timeHandler = null;
	this.observers = null;
	this.interval = null;

	this._init = function(interval) {
		this.observers = [];
		this.interval = interval || 20;
	};

	this.getObserver = function(observer) {
		var index = isNaN(observer) ? null : observer;
		var i = 0;
		while (i<this.observers.length && index === null) {
			var obs = this.observers[i];
			if (obs.observer == observer) {
				index = i;
			}
			i++;
		}
		// return index or null
		return index;
	};

	this.addObserver = function(observer, interval) {
		if (!interval) return null;
		var index = this.getObserver(observer);
		if (index) return index;
		this.observers.push({
			interval: interval,
			lastExecuted: null,
			observer: observer
		});
		return (this.observers.length - 1);
	};

	this.removeObserver = function(observer) {
		var index = this.getObserver(observer);
		if (index !== null) this.observers.splice(index, 1);
	};
	
	this.removeAllObservers = function() {
		for (var i=0,l=this.observers.length; i<l; i++) {
			this.removeObserver(this.observers[i]);
		}
		this.observers = [];
	};

	this.start = function() {
		if (this.timeHandler !== null) return;
		this._timeEvent();
	};

	this.stop = function() {
		if (this.timeHandler === null) return;
		clearTimeout(this.timeHandler);
		this.timeHandler = null;
	};

	this._timeEvent = function() {
		var now = new Date().getTime();
		for (var i=0; i<this.observers.length; i++) {
			var obs = this.observers[i];
			if (obs.lastExecuted === null) {
				obs.lastExecuted = new Date().getTime();
			}
			if ((now - obs.lastExecuted) >= obs.interval) {
				obs.lastExecuted = new Date().getTime();
				obs.observer();
			}
		}
		this.timeHandler = setTimeout(function() {this._timeEvent();}.bind(this), this.interval);
	};

	this._init(interval);
};


XimTimer.instance = null;

XimTimer.getInstance = function() {
	if (XimTimer.instance === null) {
		XimTimer.instance = new XimTimer();
	}
	return XimTimer.instance;
};
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */

(function() {

	/**
	 * Basic implementation of Firebug API,
	 * just for obtain some compatibility with IE.
	 */

	// -- DEBUG --
//	k = {};
//	var window = k;

	if (!Object.isObject(window.console)) {
		window.console = {
		
			LEVEL_DEBUG: 'DEBUG',
			LEVEL_LOG: 'LOG',
			LEVEL_INFO: 'INFO',
			LEVEL_WARN: 'WARN',
			LEVEL_ERROR: 'ERROR',
			
			_getConsole: function() {
				var container = document.getElementById('console');
				var area = document.getElementById('console-area');
				if (!area) {
					container = document.createElement('div');
					var button = document.createElement('button');
					button.appendChild(document.createTextNode('Hide'));
					button.onclick = function() {
						container.style.display = 'none';
					}
					container.appendChild(button);
					button = document.createElement('button');
					button.appendChild(document.createTextNode('Clear'));
					button.onclick = function() {
						var area = document.getElementById('console-area');
						while (area.childNodes.length > 0) {
							area.removeChild(area.childNodes[0]);
						}
					}
					container.appendChild(button);
					container.id = 'console';
					container.style.border = '1px solid #444444';
					container.style.backgroundColor = '#FFF8B1';
					container.style.position = 'absolute';
					container.style.width = '100%';
					container.style.height = '200px';
					container.style.top = '0px';
					container.style.overflow = 'hidden';
					container.style.padding = '8px';
					var body = document.getElementsByTagName('body')[0];
					body.appendChild(container);
					area = document.createElement('div');
					area.id = 'console-area';
					area.style.border = '1px solid #444444';
					area.style.backgroundColor = '#FFFFFF';
					area.style.position = 'absolute';
					area.style.width = '96%';
					area.style.top = '35px';
					area.style.bottom = '8px';
					area.style.left = 'auto';
					area.style.right = 'auto';
					area.style.overflow = 'auto';
					area.style.padding = '8px';
					container.appendChild(area);
				}
				container.style.display = '';
				return area;
			},
			
			_createLine: function(level, message) {
				
				// TODO: images?
				var imgContainer = document.createElement('div');
				imgContainer.style.width = '22px';
				imgContainer.style.height = '22px';
				imgContainer.style.position = 'relative';
				var float = !Object.isUndefined(imgContainer.style.cssFloat) ? 'cssFloat' : 'styleFloat';
				imgContainer.style[float] = 'left';
				var img = document.createElement('img');
				
				switch (level) {
					case this.LEVEL_DEBUG:
						break;
					case this.LEVEL_LOG:
						break;
					case this.LEVEL_INFO:
						img.src = 'icons/dialog-information.png';
						imgContainer.appendChild(img);
						break;
					case this.LEVEL_WARN:
						img.src = 'icons/emblem-important.png';
						imgContainer.appendChild(img);
						break;
					case this.LEVEL_ERROR:
						img.src = 'icons/dialog-error.png';
						imgContainer.appendChild(img);
						break;
				}
				
				var line = document.createElement('div');
				line.style.borderBottom = '1px solid #cccccc';
				line.style.paddingTop = '5px';
				line.style.fontFamily = 'Sans';
				line.style.fontSize = '11pt';
				line.style.position = 'relative';
				line.style.clear = 'both';
				line.style.width = '99%';
				if (float == 'styleFloat') line.style.height = '24px';
				line.appendChild(imgContainer);
				
				for (var i=0, l=message.length; i<l; i++) {
					
					var _content = document.createElement('div');
					_content.innerHTML = message[i];
					_content._originalContent = message[i]._originalContent;
					_content.className = "console-content";
					_content.style.marginLeft = '30px';
					_content.style.cursor = 'default';
					_content.style.position = 'relative';
					_content.style[float] = 'left';
					line.appendChild(_content);
					
					if (Object.isObject(_content._originalContent) || Object.isArray(_content._originalContent)) {
						if (_content.attachEvent) {
							_content.attachEvent('onclick', this._onClickCb.bind(this));
						} else if (_content.addEventListener) {
							_content.addEventListener('click', this._onClickCb.bind(this), false);
						}
					}
				}
				
				return line;
			},
			
			_onClickCb: function(event) {
				var target = event.target || event.srcElement;
				// TODO: show object attributes...
//				var msg = '';
//				for (var o in target) {
//					msg += 'object.%s\t%s\n'.printf(o, typeof(target));
//				}
//				alert(msg);
			},
			
			_write: function() {
				return;
				var args = $A(arguments);
				var level = args.shift();
				var k = this._getConsole();
				var message = [];
				for (var i=0, l=args.length; i<l; i++) {
					var originalContent = args[i];
					var parsedContent = new String(this._parseContent(originalContent));
					parsedContent._originalContent = originalContent;
					message.push(parsedContent);
				};
				k.appendChild(this._createLine(level, message));
				k.scrollTop = k.scrollHeight; 
			},
			
			_parseContent: function(content) {
				if (Object.isFunction(content)) {
					return 'function()';
				} else if (Object.isObject(content)) {
					return content.toString();
				} else if (Object.isArray(content)) {
					return '[%s]'.printf(content.toString());
				} else if (Object.isUndefined(content)) {
					return 'undefined';
				} else if (content === null) {
					return 'null';
				}
				return content;
			},
			
			debug: function() {
				var args = $A(arguments);
				args.splice(0, 0, this.LEVEL_DEBUG);
				this._write.apply(this, args);
			},
			log: function() {
				var args = $A(arguments);
				args.splice(0, 0, this.LEVEL_LOG);
				this._write.apply(this, args);
			},
			info: function() {
				var args = $A(arguments);
				args.splice(0, 0, this.LEVEL_INFO);
				this._write.apply(this, args);
			},
			warn: function() {
				var args = $A(arguments);
				args.splice(0, 0, this.LEVEL_WARN);
				this._write.apply(this, args);
			},
			error: function() {
				var args = $A(arguments);
				args.splice(0, 0, this.LEVEL_ERROR);
				this._write.apply(this, args);
			},
			assert: function() {
		
			},
			time: function() {
			},
			timeEnd: function() {
			}
		}
	}

})();
$(function() {
    // the widget definition, where "custom" is the namespace,
    // "colorize" the widget name
    $.widget( "ximdex.inputSelect", {
      // default options
      options:{
        direction:"vertical",
        collapsable: true,
        change: null,
        showOptionText:false
      },


      // the constructor function
      _create: function() {

	this.selectedValue = null;
        this.options.collapsable = this.element.hasClass("collapsable")? true : false;
        this.options.direction = this.element.hasClass("horizontal")? "horizontal" : "vertical";

        //Creating divElements from select input
        this.xOptionElements = [];
        this.showOptions = {
                            expand:{},
                            collapse:{}
        };
        this._createNewElements();
        this.inputName = this.element.attr("name");
        this._createShowOptions();

        if (this.options.collapsable){
         /* this._on(this.xInput.parent(),{
            mouseenter:"_hover",
            mouseleave:"_hover"
          });*/
        } else{
          this.xInput.hide();
          this.xInput.parent().css(this.showOptions.expand);

        }
      },

      _setOption: function(key,value){
        this.options[key]=value;
        if (key==="direction"){
          this._createShowOptions();
        }
      },

      _createShowOptions: function(){

          //if collapsable, show all options, even the current one (extraSize = 1).
          var extraSize=0;
          if (this.options.collapsable)
            extraSize = 1;


          var expandDimension;
          var collapseDimension;
          switch(this.options.direction){

            case "horizontal":

              this.showOptions.expand = {width:expandDimension};
              collapseDimension = this.xInput.width();
              this.showOptions.collapse = {width:collapseDimension};
              this.xInput.parent().removeClass("vertical");
              this.xInput.parent().addClass("horizontal");
              break;
            case "vertical":
              expandDimension = this.xInput.height()*(this.xOptionElements.length+extraSize);
              this.showOptions.expand = {height:expandDimension};
              collapseDimension = this.xInput.height();
              this.showOptions.collapse = {height:collapseDimension};
              this.xInput.parent().removeClass("horizontal");
              this.xInput.parent().addClass("vertical");
              break;
            default: break;
          }

      },

      //Called from create function to create div elements from select input
      _createNewElements : function(){
          $divContainer = this._buildContainer();

          //Creating main div
          this.xInput = $("<div/>");
          this.xInput.attr("name",this.element.attr("name"));
          this.xInput.attr("id",this.element.attr("id"));
          this.xInput.attr("style",this.element.attr("style"));
          this.xInput.removeClass("hidden");
          this.xInput.addClass("selection icon");
          $divContainer.append(this.xInput);
          $divOptionContainer = $("<div/>").addClass("options");

          var $options = this.element.children();

          for (var i=0; i < $options.length; i++){

            $newOption = this._addOption($options[i]);
            $divOptionContainer.append($newOption);
          }

          $divContainer.append($divOptionContainer);
          this.element.before($divContainer);
          this.element.hide();
      },

      _addOption: function(option){

        var i = this.xOptionElements.length;

        var $auxOption = $(option);
        var $newOption = $("<div/>")
                        .addClass(this.element.attr("name")+"-"+$auxOption.attr("value"))
                        .addClass("option icon")
                        .attr("data-option",i)
                        .attr("title",$auxOption.attr("value"))
                        .text($auxOption.text());

        this._on($newOption,{
          click: "select"
        });



        //Creating option object
        var optionObject = {
          element: $newOption,
          value: $auxOption.attr("value"),
          text:  $auxOption.text(),
          index: i
        };
        this.xOptionElements.push(optionObject);

        if ($auxOption.is(":selected"))
          this._changeOptionSelected(i);

        return $newOption;
      },

      _buildContainer: function(){

          $divContainer = $("<div/>")
                      .addClass(this.element.attr("class"));
          $divContainer.removeClass('hidden');
          return $divContainer;
      },

      //Show changes in form input
      select: function(e){
        var type = typeof e;
        if (type == "string"){
            var $divSelected = this.xInput.parent().find("div[title='"+e+"']");
            $option = $divSelected.length? $divSelected: false;
        }else if (type == "object"){
            $option = $(e.currentTarget);
        }

        if ($option){
          var pos = $option.attr("data-option");
          this._changeOptionSelected(pos);
          this._trigger("change",e,{value:$option.val()});
        }

        return false;
      },

     /* _hover: function(e, ui) {

          console.log(this.xOptionElements);
          console.log(this.showOptions.collapse);
          if (e.originalEvent.type === "mouseenter" || e.originalEvent.type === "mouseover") {
              var height = this.xInput.height()*(this.xOptionElements.length+1);
              this.xInput.parent().stop(true,true).animate(this.showOptions.expand,200);

          } else {
            this.xInput.parent().stop(true,true).animate(this.showOptions.collapse,200);

          }
      },*/

      _changeOptionSelected: function(index){

          this.xInput.removeClass(this.xInput.attr("name")+"-"+this.xInput.attr("data-value"));
          this.xInput.addClass(this.xInput.attr("name")+"-"+this.xOptionElements[index].value);
          this.xInput.attr("data-value",this.xOptionElements[index].value);
	  this.selectedValue = this.xOptionElements[index].value;


          if (!this.options.collapsable){
            this.xInput.siblings().removeClass("selection");
            this.xOptionElements[index].element.addClass("selection");
          }
      }


    });


});
/*****************************************************************************
 *
 * Sarissa XML library version 0.9.6
 * Copyright (c) 2003 Manos Batsis, 
 * mailto: mbatsis at users full stop sourceforge full stop net
 * This software is distributed under the Kupu License. See
 * LICENSE.txt for license text. See the Sarissa homepage at
 * http://sarissa.sourceforge.net for more information.
 *
 *****************************************************************************

 * ====================================================================
 * About
 * ====================================================================
 * Sarissa cross browser XML library 
 * @version 0.9.6
 * @author: Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 *
 * Sarissa is an ECMAScript library acting as a cross-browser wrapper for native XML APIs.
 * The library supports Gecko based browsers like Mozilla and Firefox,
 * Internet Explorer (5.5+ with MSXML3.0+) and, last but not least, KHTML based browsers like
 * Konqueror and Safari.
 *
 */
/**
 * <p>Sarissa is a utility class. Provides static methods for DOMDocument and 
 * XMLHTTP objects, DOM Node serializatrion to XML strings and other goodies.</p>
 * @constructor
 */
function Sarissa(){};
/** @private */
Sarissa.PARSED_OK = "Document contains no parsing errors";
/**
 * Tells you whether transformNode and transformNodeToObject are available. This functionality
 * is contained in sarissa_ieemu_xslt.js and is deprecated. If you want to control XSLT transformations
 * use the XSLTProcessor
 * @deprecated
 * @type boolean
 */
Sarissa.IS_ENABLED_TRANSFORM_NODE = false;
/**
 * tells you whether XMLHttpRequest (or equivalent) is available
 * @type boolean
 */
Sarissa.IS_ENABLED_XMLHTTP = false;
/**
 * tells you whether selectNodes/selectSingleNode is available
 * @type boolean
 */
Sarissa.IS_ENABLED_SELECT_NODES = false;
var _sarissa_iNsCounter = 0;
var _SARISSA_IEPREFIX4XSLPARAM = "";
var _SARISSA_HAS_DOM_IMPLEMENTATION = document.implementation && true;
var _SARISSA_HAS_DOM_CREATE_DOCUMENT = _SARISSA_HAS_DOM_IMPLEMENTATION && document.implementation.createDocument;
var _SARISSA_HAS_DOM_FEATURE = _SARISSA_HAS_DOM_IMPLEMENTATION && document.implementation.hasFeature;
var _SARISSA_IS_MOZ = _SARISSA_HAS_DOM_CREATE_DOCUMENT && _SARISSA_HAS_DOM_FEATURE;
var _SARISSA_IS_SAFARI = navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1;
var _SARISSA_IS_IE = document.all && window.ActiveXObject && navigator.userAgent.toLowerCase().indexOf("msie") > -1  && navigator.userAgent.toLowerCase().indexOf("opera") == -1;

if(!window.Node || !window.Node.ELEMENT_NODE){
    var Node = {ELEMENT_NODE: 1, ATTRIBUTE_NODE: 2, TEXT_NODE: 3, CDATA_SECTION_NODE: 4, ENTITY_REFERENCE_NODE: 5,  ENTITY_NODE: 6, PROCESSING_INSTRUCTION_NODE: 7, COMMENT_NODE: 8, DOCUMENT_NODE: 9, DOCUMENT_TYPE_NODE: 10, DOCUMENT_FRAGMENT_NODE: 11, NOTATION_NODE: 12};
};

// IE initialization
if(_SARISSA_IS_IE){
    // for XSLT parameter names, prefix needed by IE
    _SARISSA_IEPREFIX4XSLPARAM = "xsl:";
    // used to store the most recent ProgID available out of the above
    var _SARISSA_DOM_PROGID = "";
    var _SARISSA_XMLHTTP_PROGID = "";
    /**
     * Called when the Sarissa_xx.js file is parsed, to pick most recent
     * ProgIDs for IE, then gets destroyed.
     * @param idList an array of MSXML PROGIDs from which the most recent will be picked for a given object
     * @param enabledList an array of arrays where each array has two items; the index of the PROGID for which a certain feature is enabled
     */
    pickRecentProgID = function (idList, enabledList){
        // found progID flag
        var bFound = false;
        for(var i=0; i < idList.length && !bFound; i++){
            try{
                var oDoc = new ActiveXObject(idList[i]);
                o2Store = idList[i];
                bFound = true;
                for(var j=0;j<enabledList.length;j++)
                    if(i <= enabledList[j][1])
                        Sarissa["IS_ENABLED_"+enabledList[j][0]] = true;
            }catch (objException){
                // trap; try next progID
            };
        };
        if (!bFound)
            throw "Could not retreive a valid progID of Class: " + idList[idList.length-1]+". (original exception: "+e+")";
        idList = null;
        return o2Store;
    };
    // pick best available MSXML progIDs
    _SARISSA_DOM_PROGID = pickRecentProgID(["Msxml2.DOMDocument.5.0", "Msxml2.DOMDocument.4.0", "Msxml2.DOMDocument.3.0", "MSXML2.DOMDocument", "MSXML.DOMDocument", "Microsoft.XMLDOM"], [["SELECT_NODES", 2],["TRANSFORM_NODE", 2]]);
    _SARISSA_XMLHTTP_PROGID = pickRecentProgID(["Msxml2.XMLHTTP.5.0", "Msxml2.XMLHTTP.4.0", "MSXML2.XMLHTTP.3.0", "MSXML2.XMLHTTP", "Microsoft.XMLHTTP"], [["XMLHTTP", 4]]);
    _SARISSA_THREADEDDOM_PROGID = pickRecentProgID(["Msxml2.FreeThreadedDOMDocument.5.0", "MSXML2.FreeThreadedDOMDocument.4.0", "MSXML2.FreeThreadedDOMDocument.3.0"]);
    _SARISSA_XSLTEMPLATE_PROGID = pickRecentProgID(["Msxml2.XSLTemplate.5.0", "Msxml2.XSLTemplate.4.0", "MSXML2.XSLTemplate.3.0"], [["XSLTPROC", 2]]);
    // we dont need this anymore
    pickRecentProgID = null;
    //============================================
    // Factory methods (IE)
    //============================================
    // see non-IE version
    Sarissa.getDomDocument = function(sUri, sName){
        var oDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
        // if a root tag name was provided, we need to load it in the DOM
        // object
        if (sName){
            // if needed, create an artifical namespace prefix the way Moz
            // does
            if (sUri){
                oDoc.loadXML("<a" + _sarissa_iNsCounter + ":" + sName + " xmlns:a" + _sarissa_iNsCounter + "=\"" + sUri + "\" />");
                // don't use the same prefix again
                ++_sarissa_iNsCounter;
            }
            else
                oDoc.loadXML("<" + sName + "/>");
        };
        return oDoc;
    };
    // see non-IE version   
    Sarissa.getParseErrorText = function (oDoc) {
        var parseErrorText = Sarissa.PARSED_OK;
        if(oDoc.parseError != 0){
            parseErrorText = "XML Parsing Error: " + oDoc.parseError.reason + 
                "\nLocation: " + oDoc.parseError.url + 
                "\nLine Number " + oDoc.parseError.line + ", Column " + 
                oDoc.parseError.linepos + 
                ":\n" + oDoc.parseError.srcText +
                "\n";
            for(var i = 0;  i < oDoc.parseError.linepos;i++){
                parseErrorText += "-";
            };
            parseErrorText +=  "^\n";
        };
        return parseErrorText;
    };
    // see non-IE version
    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
        oDoc.setProperty("SelectionLanguage", "XPath");
        oDoc.setProperty("SelectionNamespaces", sNsSet);
    };   
    /**
     * Basic implementation of Mozilla's XSLTProcessor for IE. 
     * Reuses the same XSLT stylesheet for multiple transforms
     * @constructor
     */
    XSLTProcessor = function(){
        this.template = new ActiveXObject(_SARISSA_XSLTEMPLATE_PROGID);
        this.processor = null;
    };
    /**
     * Impoprts the given XSLT DOM and compiles it to a reusable transform
     * @argument xslDoc The XSLT DOMDocument to import
     */
    XSLTProcessor.prototype.importStylesheet = function(xslDoc){
        // convert stylesheet to free threaded
        var converted = new ActiveXObject(_SARISSA_THREADEDDOM_PROGID); 
        converted.loadXML(xslDoc.xml);
        this.template.stylesheet = converted;
        this.processor = this.template.createProcessor();
        // (re)set default param values
        this.paramsSet = new Array();
    };
    /**
     * Transform the given XML DOM
     * @argument sourceDoc The XML DOMDocument to transform
     * @return The transformation result as a DOM Document
     */
    XSLTProcessor.prototype.transformToDocument = function(sourceDoc){
        this.processor.input = sourceDoc;
        var outDoc = new ActiveXObject(_SARISSA_DOM_PROGID);
        this.processor.output = outDoc; 
        this.processor.transform();
        return outDoc;
    };
    /**
     * Not sure if this works in IE. Maybe this will allow non-well-formed
     * transformation results (i.e. with no single root element)
     * @argument sourceDoc The XML DOMDocument to transform
     * @return The transformation result as a DOM Fragment
     */
    XSLTProcessor.prototype.transformToFragment = function(sourceDoc, ownerDocument){
        return this.transformToDocument(sourceDoc);
    };
    /**
     * Set global XSLT parameter of the imported stylesheet
     * @argument nsURI The parameter namespace URI
     * @argument name The parameter base name
     * @argument value The new parameter value
     */
    XSLTProcessor.prototype.setParameter = function(nsURI, name, value){
        /* nsURI is optional but cannot be null */
        if(nsURI){
            this.processor.addParameter(name, value, nsURI);
        }else{
            this.processor.addParameter(name, value);
        };
        /* update updated params for getParameter */
        if(!this.paramsSet[""+nsURI]){
            this.paramsSet[""+nsURI] = new Array();
        };
        this.paramsSet[""+nsURI][name] = value;
    };
    /**
     * Gets a parameter if previously set by setParameter. Returns null
     * otherwise
     * @argument name The parameter base name
     * @argument value The new parameter value
     * @return The parameter value if reviously set by setParameter, null otherwise
     */
    XSLTProcessor.prototype.getParameter = function(nsURI, name){
        if(this.paramsSet[""+nsURI] && this.paramsSet[""+nsURI][name])
            return this.paramsSet[""+nsURI][name];
        else
            return null;
    };
}
else{ /* end IE initialization, try to deal with real browsers now ;-) */
   if(_SARISSA_HAS_DOM_CREATE_DOCUMENT){
        if(window.XMLDocument){
            /**
            * <p>Emulate IE's onreadystatechange attribute</p>
            */
            XMLDocument.prototype.onreadystatechange = null;
            /**
            * <p>Emulates IE's readyState property, which always gives an integer from 0 to 4:</p>
            * <ul><li>1 == LOADING,</li>
            * <li>2 == LOADED,</li>
            * <li>3 == INTERACTIVE,</li>
            * <li>4 == COMPLETED</li></ul>
            */
            try {
                XMLDocument.prototype.readyState = 0;
            } catch(e) {
                // XXX on some browsers (Firefox 3.6 at least) this fails,
                // however I think this is rarely a problem so we just
                // ignore it here...
            };
            /**
            * <p>Emulate IE's parseError attribute</p>
            */
            XMLDocument.prototype.parseError = 0;

            // NOTE: setting async to false will only work with documents
            // called over HTTP (meaning a server), not the local file system,
            // unless you are using Moz 1.4+.
            // BTW the try>catch block is for 1.4; I haven't found a way to check if
            // the property is implemented without
            // causing an error and I dont want to use user agent stuff for that...
            var _SARISSA_SYNC_NON_IMPLEMENTED = false;
            try{
                /**
                * <p>Emulates IE's async property for Moz versions prior to 1.4.
                * It controls whether loading of remote XML files works
                * synchronously or asynchronously.</p>
                */
                //XMLDocument.prototype.async = true;
                _SARISSA_SYNC_NON_IMPLEMENTED = true;
            }catch(e){/* trap */};
            /**
            * <p>Keeps a handle to the original load() method. Internal use and only
            * if Mozilla version is lower than 1.4</p>
            * @private
            */
            XMLDocument.prototype._sarissa_load = XMLDocument.prototype.load;

            /**
            * <p>Overrides the original load method to provide synchronous loading for
            * Mozilla versions prior to 1.4, using an XMLHttpRequest object (if
            * async is set to false)</p>
            * @returns the DOM Object as it was before the load() call (may be  empty)
            */
            XMLDocument.prototype.load = function(sURI) {
                var oDoc = document.implementation.createDocument("", "", null);
                Sarissa.copyChildNodes(this, oDoc);
                this.parseError = 0;
                Sarissa.__setReadyState__(this, 1);
                try {
                    if(this.async == false && _SARISSA_SYNC_NON_IMPLEMENTED) {
                        var tmp = new XMLHttpRequest();
                        tmp.open("GET", sURI, false);
                        tmp.send(null);
                        Sarissa.__setReadyState__(this, 2);
                        Sarissa.copyChildNodes(tmp.responseXML, this);
                        Sarissa.__setReadyState__(this, 3);
                    }
                    else {
                        this._sarissa_load(sURI);
                    };
                }
                catch (objException) {
                    this.parseError = -1;
                }
                finally {
                    if(this.async == false){
                        Sarissa.__handleLoad__(this);
                    };
                };
                return oDoc;
            };
        };//if(window.XMLDocument)

        /**
         * <p>Ensures the document was loaded correctly, otherwise sets the
         * parseError to -1 to indicate something went wrong. Internal use</p>
         * @private
         */
        Sarissa.__handleLoad__ = function(oDoc){
            if (!oDoc.documentElement || oDoc.documentElement.tagName == "parsererror")
                oDoc.parseError = -1;
            Sarissa.__setReadyState__(oDoc, 4);
        };
        
        /**
        * <p>Attached by an event handler to the load event. Internal use.</p>
        * @private
        */
        _sarissa_XMLDocument_onload = function(){
            Sarissa.__handleLoad__(this);
        };
        
        /**
         * <p>Sets the readyState property of the given DOM Document object.
         * Internal use.</p>
         * @private
         * @argument oDoc the DOM Document object to fire the
         *          readystatechange event
         * @argument iReadyState the number to change the readystate property to
         */
        Sarissa.__setReadyState__ = function(oDoc, iReadyState){
            oDoc.readyState = iReadyState;
            if (oDoc.onreadystatechange != null && typeof oDoc.onreadystatechange == "function")
                oDoc.onreadystatechange();
        };
        /**
        * <p>Factory method to obtain a new DOM Document object</p>
        * @argument sUri the namespace of the root node (if any)
        * @argument sUri the local name of the root node (if any)
        * @returns a new DOM Document
        */
        Sarissa.getDomDocument = function(sUri, sName){
            var oDoc = document.implementation.createDocument(sUri?sUri:"", sName?sName:"", null);
            oDoc.addEventListener("load", _sarissa_XMLDocument_onload, false);
            return oDoc;
        };        
    };//if(_SARISSA_HAS_DOM_CREATE_DOCUMENT)
};
//==========================================
// Common stuff
//==========================================
if(!window.DOMParser){
    /** 
    * DOMParser is a utility class, used to construct DOMDocuments from XML strings
    * @constructor
    */
    DOMParser = function() {
    };
    /** 
    * Construct a new DOM Document from the given XMLstring
    * @param sXml the given XML string
    * @param contentType the content type of the document the given string represents (one of text/xml, application/xml, application/xhtml+xml). 
    * @return a new DOM Document from the given XML string
    */
    DOMParser.prototype.parseFromString = function(sXml, contentType){
        var doc = Sarissa.getDomDocument();
        doc.loadXML(sXml);
        return doc;
    };
    
};

if(window.XMLHttpRequest){
    Sarissa.IS_ENABLED_XMLHTTP = true;
}
else if(_SARISSA_IS_IE){
    /**
     * Emulate XMLHttpRequest
     * @constructor
     */
    XMLHttpRequest = function() {
        return new ActiveXObject(_SARISSA_XMLHTTP_PROGID);
    };
    Sarissa.IS_ENABLED_XMLHTTP = true;
};

if(!window.document.importNode && _SARISSA_IS_IE){
    try{
        /**
        * Implements importNode for the current window document in IE using innerHTML.
        * Testing showed that DOM was multiple times slower than innerHTML for this,
        * sorry folks. If you encounter trouble (who knows what IE does behind innerHTML)
        * please gimme a call.
        * @param oNode the Node to import
        * @param bChildren whether to include the children of oNode
        * @returns the imported node for further use
        */
        window.document.importNode = function(oNode, bChildren){
            var importNode = document.createElement("div");
            if(bChildren)
                importNode.innerHTML = Sarissa.serialize(oNode);
            else
                importNode.innerHTML = Sarissa.serialize(oNode.cloneNode(false));
            return importNode.firstChild;
        };
        }catch(e){};
};
if(!Sarissa.getParseErrorText){
    /**
     * <p>Returns a human readable description of the parsing error. Usefull
     * for debugging. Tip: append the returned error string in a &lt;pre&gt;
     * element if you want to render it.</p>
     * <p>Many thanks to Christian Stocker for the initial patch.</p>
     * @argument oDoc The target DOM document
     * @returns The parsing error description of the target Document in
     *          human readable form (preformated text)
     */
    Sarissa.getParseErrorText = function (oDoc){
        var parseErrorText = Sarissa.PARSED_OK;
        if(oDoc.parseError != 0){
            /*moz*/
            if(oDoc.documentElement.tagName == "parsererror"){
                parseErrorText = oDoc.documentElement.firstChild.data;
                parseErrorText += "\n" +  oDoc.documentElement.firstChild.nextSibling.firstChild.data;
            }/*konq*/
            else if(oDoc.documentElement.tagName == "html"){
                parseErrorText = Sarissa.getText(oDoc.documentElement.getElementsByTagName("h1")[0], false) + "\n";
                parseErrorText += Sarissa.getText(oDoc.documentElement.getElementsByTagName("body")[0], false) + "\n";
                parseErrorText += Sarissa.getText(oDoc.documentElement.getElementsByTagName("pre")[0], false);
            };
        };
        return parseErrorText;
    };
};
Sarissa.getText = function(oNode, deep){
    var s = "";
    var nodes = oNode.childNodes;
    for(var i=0; i < nodes.length; i++){
        var node = nodes[i];
        var nodeType = node.nodeType;
        if(nodeType == Node.TEXT_NODE || nodeType == Node.CDATA_SECTION_NODE){
            s += node.data;
        }
        else if(deep == true
                    && (nodeType == Node.ELEMENT_NODE
                        || nodeType == Node.DOCUMENT_NODE
                        || nodeType == Node.DOCUMENT_FRAGMENT_NODE)){
            s += Sarissa.getText(node, true);
        };
    };
    return s;
};
if(window.XMLSerializer){
    /**
     * <p>Factory method to obtain the serialization of a DOM Node</p>
     * @returns the serialized Node as an XML string
     */
    Sarissa.serialize = function(oDoc){
        return (new XMLSerializer()).serializeToString(oDoc);
    };
}else{
    if((Sarissa.getDomDocument("","foo", null)).xml){
        // see non-IE version
        Sarissa.serialize = function(oDoc) {
            // TODO: check for HTML document and return innerHTML instead
            return oDoc.xml;
        };
        /**
         * Utility class to serialize DOM Node objects to XML strings
         * @constructor
         */
        XMLSerializer = function(){};
        /**
         * Serialize the given DOM Node to an XML string
         * @param oNode the DOM Node to serialize
         */
        XMLSerializer.prototype.serializeToString = function(oNode) {
            return oNode.xml;
        };
    };
};

/**
 * strips tags from a markup string
 */
Sarissa.stripTags = function (s) {
    return s.replace(/<[^>]+>/g,"");
};
/**
 * <p>Deletes all child nodes of the given node</p>
 * @argument oNode the Node to empty
 */
Sarissa.clearChildNodes = function(oNode) {
    while(oNode.hasChildNodes()){
        oNode.removeChild(oNode.firstChild);
    };
};
/**
 * <p> Copies the childNodes of nodeFrom to nodeTo</p>
 * <p> <b>Note:</b> The second object's original content is deleted before 
 * the copy operation, unless you supply a true third parameter</p>
 * @argument nodeFrom the Node to copy the childNodes from
 * @argument nodeTo the Node to copy the childNodes to
 * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is false
 */
Sarissa.copyChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
    if(!bPreserveExisting){
        Sarissa.clearChildNodes(nodeTo);
    };
    var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
    var nodes = nodeFrom.childNodes;
    if(ownerDoc.importNode && (!_SARISSA_IS_IE)) {
        for(var i=0;i < nodes.length;i++) {
            nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
        };
    }
    else{
        for(var i=0;i < nodes.length;i++) {
            nodeTo.appendChild(nodes[i].cloneNode(true));
        };
    };
};

/**
 * <p> Moves the childNodes of nodeFrom to nodeTo</p>
 * <p> <b>Note:</b> The second object's original content is deleted before 
 * the move operation, unless you supply a true third parameter</p>
 * @argument nodeFrom the Node to copy the childNodes from
 * @argument nodeTo the Node to copy the childNodes to
 * @argument bPreserveExisting whether to preserve the original content of nodeTo, default is false
 */
Sarissa.moveChildNodes = function(nodeFrom, nodeTo, bPreserveExisting) {
    if(!bPreserveExisting){
        Sarissa.clearChildNodes(nodeTo);
    };
    
    var nodes = nodeFrom.childNodes;
    // if within the same doc, just move, else copy and delete
    if(nodeFrom.ownerDocument == nodeTo.ownerDocument){
        nodeTo.appendChild(nodes[i]);
    }else{
        var ownerDoc = nodeTo.nodeType == Node.DOCUMENT_NODE ? nodeTo : nodeTo.ownerDocument;
         if(ownerDoc.importNode && (!_SARISSA_IS_IE)) {
            for(var i=0;i < nodes.length;i++) {
                nodeTo.appendChild(ownerDoc.importNode(nodes[i], true));
            };
        }
        else{
            for(var i=0;i < nodes.length;i++) {
                nodeTo.appendChild(nodes[i].cloneNode(true));
            };
        };
        Sarissa.clearChildNodes(nodeFrom);
    };
    
};

/** 
 * <p>Serialize any object to an XML string. All properties are serialized using the property name
 * as the XML element name. Array elements are rendered as <code>array-item</code> elements, 
 * using their index/key as the value of the <code>key</code> attribute.</p>
 * @argument anyObject the object to serialize
 * @argument objectName a name for that object
 * @return the XML serializationj of the given object as a string
 */
Sarissa.xmlize = function(anyObject, objectName, indentSpace){
    indentSpace = indentSpace?indentSpace:'';
    var s = indentSpace  + '<' + objectName + '>';
    var isLeaf = false;
    if(!(anyObject instanceof Object) || anyObject instanceof Number || anyObject instanceof String 
        || anyObject instanceof Boolean || anyObject instanceof Date){
        s += Sarissa.escape(""+anyObject);
        isLeaf = true;
    }else{
        s += "\n";
        var itemKey = '';
        var isArrayItem = anyObject instanceof Array;
        for(var name in anyObject){
            s += Sarissa.xmlize(anyObject[name], (isArrayItem?"array-item key=\""+name+"\"":name), indentSpace + "   ");
        };
        s += indentSpace;
    };
    return s += (objectName.indexOf(' ')!=-1?"</array-item>\n":"</" + objectName + ">\n");
};

/** 
 * Escape the given string chacters that correspond to the five predefined XML entities
 * @param sXml the string to escape
 */
Sarissa.escape = function(sXml){
    return sXml.replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&apos;");
};

/** 
 * Unescape the given string. This turns the occurences of the predefined XML 
 * entities to become the characters they represent correspond to the five predefined XML entities
 * @param sXml the string to unescape
 */
Sarissa.unescape = function(sXml){
    return sXml.replace(/&apos;/g,"'")
        .replace(/&quot;/g,"\"")
        .replace(/&gt;/g,">")
        .replace(/&lt;/g,"<")
        .replace(/&amp;/g,"&");
};
//   EOF
/*****************************************************************************
 *
 * Sarissa XML library version 0.9.6
 * Copyright (c) 2003 Manos Batsis, 
 * mailto: mbatsis at users full stop sourceforge full stop net
 * This software is distributed under the Kupu License. See
 * LICENSE.txt for license text. See the Sarissa homepage at
 * http://sarissa.sourceforge.net for more information.
 *
 *****************************************************************************

 * ====================================================================
 * About
 * ====================================================================
 * Sarissa cross browser XML library - IE XPath Emulation 
 * @version 0.9.6
 * @author: Manos Batsis, mailto: mbatsis at users full stop sourceforge full stop net
 *
 * This script emulates Internet Explorer's selectNodes and selectSingleNode
 * for Mozilla. Associating namespace prefixes with URIs for your XPath queries
 * is easy with IE's setProperty. 
 * USers may also map a namespace prefix to a default (unprefixed) namespace in the
 * source document with Sarissa.setXpathNamespaces
 *
 */
if(_SARISSA_HAS_DOM_FEATURE && document.implementation.hasFeature("XPath", "3.0")){
    /**
    * <p>SarissaNodeList behaves as a NodeList but is only used as a result to <code>selectNodes</code>,
    * so it also has some properties IEs proprietery object features.</p>
    * @private
    * @constructor
    * @argument i the (initial) list size
    */
    function SarissaNodeList(i){
        this.length = i;
    };
    /** <p>Set an Array as the prototype object</p> */
    SarissaNodeList.prototype = new Array(0);
    /** <p>Inherit the Array constructor </p> */
    SarissaNodeList.prototype.constructor = Array;
    /**
    * <p>Returns the node at the specified index or null if the given index
    * is greater than the list size or less than zero </p>
    * <p><b>Note</b> that in ECMAScript you can also use the square-bracket
    * array notation instead of calling <code>item</code>
    * @argument i the index of the member to return
    * @returns the member corresponding to the given index
    */
    SarissaNodeList.prototype.item = function(i) {
        return (i < 0 || i >= this.length)?null:this[i];
    };
    /**
    * <p>Emulate IE's expr property
    * (Here the SarissaNodeList object is given as the result of selectNodes).</p>
    * @returns the XPath expression passed to selectNodes that resulted in
    *          this SarissaNodeList
    */
    SarissaNodeList.prototype.expr = "";
    /** dummy, used to accept IE's stuff without throwing errors */
    XMLDocument.prototype.setProperty  = function(x,y){};
    /**
    * <p>Programmatically control namespace URI/prefix mappings for XPath
    * queries.</p>
    * <p>This method comes especially handy when used to apply XPath queries
    * on XML documents with a default namespace, as there is no other way
    * of mapping that to a prefix.</p>
    * <p>Using no namespace prefix in DOM Level 3 XPath queries, implies you
    * are looking for elements in the null namespace. If you need to look
    * for nodes in the default namespace, you need to map a prefix to it
    * first like:</p>
    * <pre>Sarissa.setXpathNamespaces(oDoc, &quot;xmlns:myprefix=&amp;aposhttp://mynsURI&amp;apos&quot;);</pre>
    * <p><b>Note 1 </b>: Use this method only if the source document features
    * a default namespace (without a prefix), otherwise just use IE's setProperty
    * (moz will rezolve non-default namespaces by itself). You will need to map that
    * namespace to a prefix for queries to work.</p>
    * <p><b>Note 2 </b>: This method calls IE's setProperty method to set the
    * appropriate namespace-prefix mappings, so you dont have to do that.</p>
    * @param oDoc The target XMLDocument to set the namespace mappings for.
    * @param sNsSet A whilespace-seperated list of namespace declarations as
    *            those would appear in an XML document. E.g.:
    *            <code>&quot;xmlns:xhtml=&apos;http://www.w3.org/1999/xhtml&apos;
    * xmlns:&apos;http://www.w3.org/1999/XSL/Transform&apos;&quot;</code>
    * @throws An error if the format of the given namespace declarations is bad.
    */
    Sarissa.setXpathNamespaces = function(oDoc, sNsSet) {
        //oDoc._sarissa_setXpathNamespaces(sNsSet);
        oDoc._sarissa_useCustomResolver = true;
        var namespaces = sNsSet.indexOf(" ")>-1?sNsSet.split(" "):new Array(sNsSet);
        oDoc._sarissa_xpathNamespaces = new Array(namespaces.length);
        for(var i=0;i < namespaces.length;i++){
            var ns = namespaces[i];
            var colonPos = ns.indexOf(":");
            var assignPos = ns.indexOf("=");
            if(colonPos == 5 && assignPos > colonPos+2){
                var prefix = ns.substring(colonPos+1, assignPos);
                var uri = ns.substring(assignPos+2, ns.length-1);
                oDoc._sarissa_xpathNamespaces[prefix] = uri;
            }else{
                throw "Bad format on namespace declaration(s) given";
            };
        };
    };
    /**
    * @private Flag to control whether a custom namespace resolver should
    *          be used, set to true by Sarissa.setXpathNamespaces
    */
    XMLDocument.prototype._sarissa_useCustomResolver = false;
    /** @private */
    XMLDocument.prototype._sarissa_xpathNamespaces = new Array();
    /**
    * <p>Extends the XMLDocument to emulate IE's selectNodes.</p>
    * @argument sExpr the XPath expression to use
    * @argument contextNode this is for internal use only by the same
    *           method when called on Elements
    * @returns the result of the XPath search as a SarissaNodeList
    * @throws An error if no namespace URI is found for the given prefix.
    */
    XMLDocument.prototype.selectNodes = function(sExpr, contextNode){
        var nsDoc = this;
        var nsresolver = this._sarissa_useCustomResolver
        ? function(prefix){
            var s = nsDoc._sarissa_xpathNamespaces[prefix];
            if(s)return s;
            else throw "No namespace URI found for prefix: '" + prefix+"'";
            }
        : this.createNSResolver(this.documentElement);
            var oResult = this.evaluate(sExpr,
                    (contextNode?contextNode:this),
                    nsresolver,
                    XPathResult.ORDERED_NODE_SNAPSHOT_TYPE, null);
        var nodeList = new SarissaNodeList(oResult.snapshotLength);
        nodeList.expr = sExpr;
        for(var i=0;i<nodeList.length;i++)
            nodeList[i] = oResult.snapshotItem(i);
        return nodeList;
    };
    /**
    * <p>Extends the Element to emulate IE's selectNodes</p>
    * @argument sExpr the XPath expression to use
    * @returns the result of the XPath search as an (Sarissa)NodeList
    * @throws An
    *             error if invoked on an HTML Element as this is only be
    *             available to XML Elements.
    */
    Element.prototype.selectNodes = function(sExpr){
        var doc = this.ownerDocument;
        if(doc.selectNodes)
            return doc.selectNodes(sExpr, this);
        else
            throw "Method selectNodes is only supported by XML Elements";
    };
    /**
    * <p>Extends the XMLDocument to emulate IE's selectSingleNodes.</p>
    * @argument sExpr the XPath expression to use
    * @argument contextNode this is for internal use only by the same
    *           method when called on Elements
    * @returns the result of the XPath search as an (Sarissa)NodeList
    */
    XMLDocument.prototype.selectSingleNode = function(sExpr, contextNode){
        var ctx = contextNode?contextNode:null;
        sExpr = "("+sExpr+")[1]";
        var nodeList = this.selectNodes(sExpr, ctx);
        if(nodeList.length > 0)
            return nodeList.item(0);
        else
            return null;
    };
    /**
    * <p>Extends the Element to emulate IE's selectNodes.</p>
    * @argument sExpr the XPath expression to use
    * @returns the result of the XPath search as an (Sarissa)NodeList
    * @throws An error if invoked on an HTML Element as this is only be
    *             available to XML Elements.
    */
    Element.prototype.selectSingleNode = function(sExpr){
        var doc = this.ownerDocument;
        if(doc.selectSingleNode)
            return doc.selectSingleNode(sExpr, this);
        else
            throw "Method selectNodes is only supported by XML Elements";
    };
    Sarissa.IS_ENABLED_SELECT_NODES = true;
};
/*****************************************************************************
 *
 * Copyright (c) 2003-2005 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id: kupuhelpers.js 21722 2006-01-05 17:27:50Z guido $

/*

Some notes about the scripts:

- Problem with bound event handlers:

    When a method on an object is used as an event handler, the method uses
    its reference to the object it is defined on. The 'this' keyword no longer
    points to the class, but instead refers to the element on which the event
    is bound. To overcome this problem, you can wrap the method in a class that
    holds a reference to the object and have a method on the wrapper that calls
    the input method in the input object's context. This wrapped method can be
    used as the event handler. An example:

    class Foo() {
        this.foo = function() {
            // the method used as an event handler
            // using this here wouldn't work if the method
            // was passed to addEventListener directly
            this.baz();
        };
        this.baz = function() {
            // some method on the same object
        };
    };

    f = new Foo();

    // create the wrapper for the function, args are func, context
    wrapper = new ContextFixer(f.foo, f);

    // the wrapper can be passed to addEventListener, 'this' in the method
    // will be pointing to the right context.
    some_element.addEventListener("click", wrapper.execute, false);

- Problem with window.setTimeout:

    The window.setTimeout function has a couple of problems in usage, all
    caused by the fact that it expects a *string* argument that will be
    evalled in the global namespace rather than a function reference with
    plain variables as arguments. This makes that the methods on 'this' can
    not be called (the 'this' variable doesn't exist in the global namespace)
    and references to variables in the argument list aren't allowed (since
    they don't exist in the global namespace). To overcome these problems,
    there's now a singleton instance of a class called Timer, which has one
    public method called registerFunction. This can be called with a function
    reference and a variable number of extra arguments to pass on to the
    function.

    Usage:

        timer_instance.registerFunction(this, this.myFunc, 10, 'foo', bar);

        will call this.myFunc('foo', bar); in 10 milliseconds (with 'this'
        as its context).

*/

//----------------------------------------------------------------------------
// Helper classes and functions
//----------------------------------------------------------------------------

function addEventHandler(element, event, method, context) {
    /* method to add an event handler for both IE and Mozilla */
    var wrappedmethod = new ContextFixer(method, context);
    var args = new Array(null, null);
    for (var i=4; i < arguments.length; i++) {
        args.push(arguments[i]);
    };
    wrappedmethod.args = args;
    try {
        if (_SARISSA_IS_MOZ) {
            element.addEventListener(event, wrappedmethod.execute, false);
        } else if (_SARISSA_IS_IE) {
            element.attachEvent("on" + event, wrappedmethod.execute);
        } else {
            throw _("Unsupported browser!");
        };
        return wrappedmethod.execute;
    } catch(e) {
        alert(_('exception ${message} while registering an event handler ' +
                'for element ${element}, event ${event}, method ${method}',
                {'message': e.message, 'element': element,
                    'event': event,
                    'method': method}));
    };
};

function removeEventHandler(element, event, method) {
    /* method to remove an event handler for both IE and Mozilla */
    if (_SARISSA_IS_MOZ) {
        window.removeEventListener(event, method, false);
    } else if (_SARISSA_IS_IE) {
        element.detachEvent("on" + event, method);
    } else {
        throw _("Unsupported browser!");
    };
};

/* Replacement for window.document.getElementById()
 * selector can be an Id (so we maintain backwards compatability)
 * but is intended to be a subset of valid CSS selectors.
 * For now we only support the format: "#id tag.class"
 */
function getFromSelector(selector) {
    var match = /#(\S+)\s*([^ .]+)\.(\S+)/.exec(selector);
    if (!match) {
        return window.document.getElementById(selector);
    }
    var id=match[1], tag=match[2], className=match[3];
    var base = window.document.getElementById(id);
    return getBaseTagClass(base, tag, className);
}

function getBaseTagClass(base, tag, className) {
    var classPat = new RegExp('\\b'+className+'\\b');

    var nodes = base.getElementsByTagName(tag);
    for (var i = 0; i < nodes.length; i++) {
        if (classPat.test(nodes[i].className)) {
            return nodes[i];
        }
    }
    return null;
}

function openPopup(url, width, height) {
    /* open and center a popup window */
    var sw = screen.width;
    var sh = screen.height;
    var left = sw / 2 - width / 2;
    var top = sh / 2 - height / 2;
    var win = window.open(url, 'someWindow',
                'width=' + width + ',height=' + height + ',left=' + left + ',top=' + top);
    return win;
};

function selectSelectItem(select, item) {
    /* select a certain item from a select */
    for (var i=0; i < select.options.length; i++) {
        var option = select.options[i];
        if (option.value == item) {
            select.selectedIndex = i;
            return;
        }
    }
    select.selectedIndex = 0;
};

function ParentWithStyleChecker(tagnames, style, stylevalue, command) {
    /* small wrapper that provides a generic function to check if a
       button should look pressed in */
    return function(selNode, button, editor, event) {
        /* check if the button needs to look pressed in */
        if (command) {
            var result = editor.getInnerDocument().queryCommandState(command)
            if (result || editor.getSelection().getContentLength() == 0) {
                return result;
            };
        };
        var currnode = selNode;
        while (currnode && currnode.style) {
            for (var i=0; i < tagnames.length; i++) {
                if (currnode.nodeName.toLowerCase() == tagnames[i].toLowerCase()) {
                    return true;
                };
            };
            if (style && currnode.style[style] == stylevalue) {
                return true;
            };
            currnode = currnode.parentNode;
        };
        return false;
    };
};

function _load_dict_helper(element) {
    /* walks through a set of XML nodes and builds a nested tree of objects */
    var dict = {};
    for (var i=0; i < element.childNodes.length; i++) {
        var child = element.childNodes[i];
        if (child.nodeType == 1) {
            var value = '';
            for (var j=0; j < child.childNodes.length; j++) {
                // test if we can recurse, if so ditch the string (probably
                // ignorable whitespace) and dive into the node
                if (child.childNodes[j].nodeType == 1) {
                    value = _load_dict_helper(child);
                    break;
                } else if (typeof(value) == typeof('')) {
                    value += child.childNodes[j].nodeValue;
                };
            };
            if (typeof(value) == typeof('') && !isNaN(parseInt(value)) &&
                    parseInt(value).toString().length == value.length) {
                value = parseInt(value);
            } else if (typeof(value) != typeof('')) {
                if (value.length == 1) {
                    value = value[0];
                };
            };
            var name = child.nodeName.toLowerCase();
            if (dict[name] != undefined) {
                if (!dict[name].push) {
                    dict[name] = new Array(dict[name], value);
                } else {
                    dict[name].push(value);
                };
            } else {
                dict[name] = value;
            };
        };
    };
    return dict;
};

function loadDictFromXML(document, islandid) {
    /* load configuration values from an XML chunk

        this is quite generic, it just reads data from a chunk of XML into
        an object, checking if the object is complete should be done in the
        calling context.
    */
    var dict = {};
    var confnode = getFromSelector(islandid);
    var root = null;
    for (var i=0; i < confnode.childNodes.length; i++) {
        if (confnode.childNodes[i].nodeType == 1) {
            root = confnode.childNodes[i];
            break;
        };
    };
    if (!root) {
        throw(_('No element found in the config island!'));
    };
    dict = _load_dict_helper(root);
    return dict;
};

function NodeIterator(node, continueatnextsibling) {
    /* simple node iterator

        can be used to recursively walk through all children of a node,
        the next() method will return the next node until either the next
        sibling of the startnode is reached (when continueatnextsibling is
        false, the default) or when there's no node left (when
        continueatnextsibling is true)

        returns false if no nodes are left
    */
    this.node = node;
    this.current = node;
    this.terminator = continueatnextsibling ? null : node;

    this.next = function() {
        /* return the next node */
        if (this.current === false) {
            // restart
            this.current = this.node;
        };
        var current = this.current;
        if (current.firstChild) {
            this.current = current.firstChild;
        } else {
            // walk up parents until we finish or find one with a nextSibling
            while (current != this.terminator && !current.nextSibling) {
                current = current.parentNode;
            };
            if (current == this.terminator) {
                this.current = false;
            } else {
                this.current = current.nextSibling;
            };
        };
        return this.current;
    };

    this.reset = function() {
        /* reset the iterator so it starts at the first node */
        this.current = this.node;
    };

    this.setCurrent = function(node) {
        /* change the current node

            can be really useful for specific hacks, the user must take
            care that the node is inside the iterator's scope or it will
            go wild
        */
        this.current = node;
    };
};

/* selection classes, these are wrappers around the browser-specific
    selection objects to provide a generic abstraction layer
*/
function BaseSelection() {
    /* superclass for the Selection objects

        this will contain higher level methods that don't contain
        browser-specific code
    */
    this.splitNodeAtSelection = function(node) {
        /* split the node at the current selection

            remove any selected text, then split the node on the location
            of the selection, thus creating a new node, this is attached to
            the node's parent after the node

            this will fail if the selection is not inside the node
        */
        if (!this.selectionInsideNode(node)) {
            throw(_('Selection not inside the node!'));
        };
        // a bit sneaky: what we'll do is insert a new br node to replace
        // the current selection, then we'll walk up to that node in both
        // the original and the cloned node, in the original we'll remove
        // the br node and everything that's behind it, on the cloned one
        // we'll remove the br and everything before it
        // anyway, we'll end up with 2 nodes, the first already in the
        // document (the original node) and the second we can just attach
        // to the doc after the first one
        var doc = this.document.getDocument();
        var br = doc.createElement('br');
        br.setAttribute('node_splitter', 'indeed');
        this.replaceWithNode(br);

        var clone = node.cloneNode(true);

        // now walk through the original node
        var iterator = new NodeIterator(node);
        var currnode = iterator.next();
        var remove = false;
        while (currnode) {
            if (currnode.nodeName.toLowerCase() == 'br' && currnode.getAttribute('node_splitter') == 'indeed') {
                // here's the point where we should start removing
                remove = true;
            };
            // we should fetch the next node before we remove the current one, else the iterator
            // will fail (since the current node is removed)
            var lastnode = currnode;
            currnode = iterator.next();
            // XXX this will leave nodes that *became* empty in place, since it doesn't visit it again,
            // perhaps we should do a second pass that removes the rest(?)
            if (remove && (lastnode.nodeType == 3 || !lastnode.hasChildNodes())) {
                lastnode.parentNode.removeChild(lastnode);
            };
        };

        // and through the clone
        var iterator = new NodeIterator(clone);
        var currnode = iterator.next();
        var remove = true;
        while (currnode) {
            var lastnode = currnode;
            currnode = iterator.next();
            if (lastnode.nodeName.toLowerCase() == 'br' && lastnode.getAttribute('node_splitter') == 'indeed') {
                // here's the point where we should stop removing
                lastnode.parentNode.removeChild(lastnode);
                remove = false;
            };
            if (remove && (lastnode.nodeType == 3 || !lastnode.hasChildNodes())) {
                lastnode.parentNode.removeChild(lastnode);
            };
        };

        // next we need to attach the node to the document
        if (node.nextSibling) {
            node.parentNode.insertBefore(clone, node.nextSibling);
        } else {
            node.parentNode.appendChild(clone);
        };

        // this will change the selection, so reselect
        this.reset();

        // return a reference to the clone
        return clone;
    };

    this.selectionInsideNode = function(node) {
        /* returns a Boolean to indicate if the selection is resided
            inside the node
        */
        var currnode = this.parentElement();
        while (currnode) {
            if (currnode == node) {
                return true;
            };
            currnode = currnode.parentNode;
        };
        return false;
    };
};

function MozillaSelection(document) {
    this.document = document;
    this.selection = document.getWindow().getSelection();

    this.selectNodeContents = function(node) {
        /* select the contents of a node */
        this.selection.removeAllRanges();
        this.selection.selectAllChildren(node);
    };

    this.collapse = function(collapseToEnd) {
        try {
            if (!collapseToEnd) {
                this.selection.collapseToStart();
            } else {
                this.selection.collapseToEnd();
            };
        } catch(e) {};
    };

    this.replaceWithNode = function(node, selectAfterPlace) {
        // XXX this should be on a range object
        /* replaces the current selection with a new node
            returns a reference to the inserted node

            newnode is the node to replace the content with, selectAfterPlace
            can either be a DOM node that should be selected after the new
            node was placed, or some value that resolves to true to select
            the placed node
        */
        // get the first range of the selection
        // (there's almost always only one range)
        var range = this.selection.getRangeAt(0);

        // deselect everything
        this.selection.removeAllRanges();

        // remove content of current selection from document
        range.deleteContents();

        // get location of current selection
        var container = range.startContainer;
        var pos = range.startOffset;

        // make a new range for the new selection
        var range = this.document.getDocument().createRange();

        if (container.nodeType == 3 && node.nodeType == 3) {
            // if we insert text in a textnode, do optimized insertion
            container.insertData(pos, node.nodeValue);

            // put cursor after inserted text
            range.setEnd(container, pos + node.length);
            range.setStart(container, pos + node.length);
        } else {
            var afterNode;
            if (container.nodeType == 3) {
                // when inserting into a textnode
                // we create 2 new textnodes
                // and put the node in between

                var textNode = container;
                var container = textNode.parentNode;
                var text = textNode.nodeValue;

                // text before the split
                var textBefore = text.substr(0,pos);
                // text after the split
                var textAfter = text.substr(pos);

                var beforeNode = this.document.getDocument().createTextNode(textBefore);
                afterNode = this.document.getDocument().createTextNode(textAfter);

                // insert the 3 new nodes before the old one
                container.insertBefore(afterNode, textNode);
                container.insertBefore(node, afterNode);
                container.insertBefore(beforeNode, node);

                // remove the old node
                container.removeChild(textNode);
            } else {
                // else simply insert the node
                afterNode = container.childNodes[pos];
                if (afterNode) {
                    container.insertBefore(node, afterNode);
                } else {
                    container.appendChild(node);
                };
            }

            range.setEnd(afterNode, 0);
            range.setStart(afterNode, 0);
        }

        if (selectAfterPlace) {
            // a bit implicit here, but I needed this to be backward
            // compatible and also I didn't want yet another argument,
            // JavaScript isn't as nice as Python in that respect (kwargs)
            // if selectAfterPlace is a DOM node, select all of that node's
            // contents, else select the newly added node's
            this.selection = this.document.getWindow().getSelection();
            this.selection.addRange(range);
            if (selectAfterPlace.nodeType == 1) {
                this.selection.selectAllChildren(selectAfterPlace);
            } else {
                if (node.hasChildNodes()) {
                    this.selection.selectAllChildren(node);
                } else {
                    var range = this.selection.getRangeAt(0).cloneRange();
                    this.selection.removeAllRanges();
                    range.selectNode(node);
                    this.selection.addRange(range);
                };
            };
            this.document.getWindow().focus();
        };
        return node;
    };

    this.startOffset = function() {
        // XXX this should be on a range object
        var startnode = this.startNode();
        var startnodeoffset = 0;
        if (startnode == this.selection.anchorNode) {
            startnodeoffset = this.selection.anchorOffset;
        } else {
            startnodeoffset = this.selection.focusOffset;
        };
        var parentnode = this.parentElement();
        if (startnode == parentnode) {
            return startnodeoffset;
        };
        var currnode = parentnode.firstChild;
        var offset = 0;
        if (!currnode) {
            // 'Control range', range consists of a single element, so startOffset is 0
            if (startnodeoffset != 0) {
                // just an assertion to see if my assumption about this case is right
                throw(_('Start node offset detected in a node without children!'));
            };
            return 0;
        };
        while (currnode != startnode) {
            if (currnode.nodeType == 3) {
                offset += currnode.nodeValue.length;
            };
            currnode = currnode.nextSibling;
        };
        return offset + startnodeoffset;
    };

    this.startNode = function() {
        // XXX this should be on a range object
        var anode = this.selection.anchorNode;
        var aoffset = this.selection.anchorOffset;
        var onode = this.selection.focusNode;
        var ooffset = this.selection.focusOffset;
        var arange = this.document.getDocument().createRange();
        arange.setStart(anode, aoffset);
        var orange = this.document.getDocument().createRange();
        orange.setStart(onode, ooffset);
        return arange.compareBoundaryPoints('START_TO_START', orange) <= 0 ? anode : onode;
    };

    this.endOffset = function() {
        // XXX this should be on a range object
        var endnode = this.endNode();
        var endnodeoffset = 0;
        if (endnode = this.selection.focusNode) {
            endnodeoffset = this.selection.focusOffset;
        } else {
            endnodeoffset = this.selection.anchorOffset;
        };
        var parentnode = this.parentElement();
        var currnode = parentnode.firstChild;
        var offset = 0;
        if (parentnode == endnode) {
            for (var i=0; i < parentnode.childNodes.length; i++) {
                var child = parentnode.childNodes[i];
                if (i == endnodeoffset) {
                    return offset;
                };
                if (child.nodeType == 3) {
                    offset += child.nodeValue.length;
                };
            };
        };
        if (!currnode) {
            // node doesn't have any content, so offset is always 0
            if (endnodeoffset != 0) {
                // just an assertion to see if my assumption about this case is right
                var msg = _('End node offset detected in a node without ' +
                            'children!');
                alert(msg);
                throw(msg);
            };
            return 0;
        };
        while (currnode != endnode) {
            if (currnode.nodeType == 3) { // should account for CDATA nodes as well
                offset += currnode.nodeValue.length;
            };
            currnode = currnode.nextSibling;
        };
        return offset + endnodeoffset;
    };

    this.endNode = function() {
        // XXX this should be on a range object
        var anode = this.selection.anchorNode;
        var aoffset = this.selection.anchorOffset;
        var onode = this.selection.focusNode;
        var ooffset = this.selection.focusOffset;
        var arange = this.document.getDocument().createRange();
        arange.setStart(anode, aoffset);
        var orange = this.document.getDocument().createRange();
        orange.setStart(onode, ooffset);
        return arange.compareBoundaryPoints('START_TO_START', orange) > 0 ? anode : onode;
    };

    this.getContentLength = function() {
        // XXX this should be on a range object
        return this.selection.toString().length;
    };

    this.cutChunk = function(startOffset, endOffset) {
        // XXX this should be on a range object
        var range = this.selection.getRangeAt(0);

        // set start point
        var offsetParent = this.parentElement();
        var currnode = offsetParent.firstChild;
        var curroffset = 0;

        var startparent = null;
        var startparentoffset = 0;

        while (currnode) {
            if (currnode.nodeType == 3) { // XXX need to add CDATA support
                var nodelength = currnode.nodeValue.length;
                if (curroffset + nodelength < startOffset) {
                    curroffset += nodelength;
                } else {
                    startparent = currnode;
                    startparentoffset = startOffset - curroffset;
                    break;
                };
            };
            currnode = currnode.nextSibling;
        };
        // set end point
        var currnode = offsetParent.firstChild;
        var curroffset = 0;

        var endparent = null;
        var endoffset = 0;

        while (currnode) {
            if (currnode.nodeType == 3) { // XXX need to add CDATA support
                var nodelength = currnode.nodeValue.length;
                if (curroffset + nodelength < endOffset) {
                    curroffset += nodelength;
                } else {
                    endparent = currnode;
                    endparentoffset = endOffset - curroffset;
                    break;
                };
            };
            currnode = currnode.nextSibling;
        };

        // now cut the chunk
        if (!startparent) {
            throw(_('Start offset out of range!'));
        };
        if (!endparent) {
            throw(_('End offset out of range!'));
        };

        var newrange = range.cloneRange();
        newrange.setStart(startparent, startparentoffset);
        newrange.setEnd(endparent, endparentoffset);
        return newrange.extractContents();
    };

    this.getElementLength = function(element) {
        // XXX this should be a helper function
        var length = 0;
        var currnode = element.firstChild;
        while (currnode) {
            if (currnode.nodeType == 3) { // XXX should support CDATA as well
                length += currnode.nodeValue.length;
            };
            currnode = currnode.nextSibling;
        };
        return length;
    };

    this.parentElement = function() {
        /* return the selected node (or the node containing the selection) */
        // XXX this should be on a range object
        if (this.selection.rangeCount == 0) {
            var parent = this.document.getDocument().body;
            while (parent.firstChild) {
                parent = parent.firstChild;
            };
        } else {
            var range = this.selection.getRangeAt(0);
            var parent = range.commonAncestorContainer;

			if (!range['intersectsNode']) range.intersectsNode = function(node) {
				// https://developer.mozilla.org/es/DOM/range.intersectsNode
				// "
				// This method has been removed from Gecko 1.9 and will not exist in future versions of Firefox;
				// you should switch to compareBoundaryPoints() as soon as possible.
				// "

				var nodeRange = node.ownerDocument.createRange();

				try {
					nodeRange.selectNode(node);
				} catch (e) {
					nodeRange.selectNodeContents(node);
				}

				var a = this.compareBoundaryPoints(Range.END_TO_START, nodeRange);
				var b = this.compareBoundaryPoints(Range.START_TO_END, nodeRange);
				var c = (a == -1) && (b == 1);
				return c;

			}.bind(range);

            // the following deals with cases where only a single child is
            // selected, e.g. after a click on an image
            var inv = range.compareBoundaryPoints(Range.START_TO_END, range) < 0;
            var startNode = inv ? range.endContainer : range.startContainer;
            var startOffset = inv ? range.endOffset : range.startOffset;
            var endNode = inv ? range.startContainer : range.endContainer;
            var endOffset = inv ? range.startOffset : range.endOffset;

            var selectedChild = null;
            var child = parent.firstChild;
            while (child) {
                // XXX the additional conditions catch some invisible
                // intersections, but still not all of them
                if (range.intersectsNode(child) &&
                    !(child == startNode && startOffset == child.length) &&
                    !(child == endNode && endOffset == 0)) {
                    if (selectedChild) {
                        // current child is the second selected child found
                        selectedChild = null;
                        break;
                    } else {
                        // current child is the first selected child found
                        selectedChild = child;
                    };
                } else if (selectedChild) {
                    // current child is after the selection
                    break;
                };
                child = child.nextSibling;
            };
            if (selectedChild) {
                parent = selectedChild;
            };
        };
        if (parent.nodeType == Node.TEXT_NODE) {
            parent = parent.parentNode;
        };
        return parent;
    };

    // deprecated alias of parentElement
    this.getSelectedNode = this.parentElement;

    this.moveStart = function(offset) {
        // XXX this should be on a range object
        var offsetparent = this.parentElement();
        // the offset within the offsetparent
        var startoffset = this.startOffset();
        var realoffset = offset + startoffset;
        if (realoffset >= 0) {
            var currnode = offsetparent.firstChild;
            var curroffset = 0;
            var startparent = null;
            var startoffset = 0;
            while (currnode) {
                if (currnode.nodeType == 3) { // XXX need to support CDATA sections
                    var nodelength = currnode.nodeValue.length;
                    if (curroffset + nodelength >= realoffset) {
                        var range = this.selection.getRangeAt(0);
                        //range.setEnd(this.endNode(), this.endOffset());
                        range.setStart(currnode, realoffset - curroffset);
                        return;
                        //this.selection.removeAllRanges();
                        //this.selection.addRange(range);
                    };
                };
                currnode = currnode.nextSibling;
            };
            // if we still haven't found the startparent we should walk to
            // all nodes following offsetparent as well
            var currnode = offsetparent.nextSibling;
            while (currnode) {
                if (currnode.nodeType == 3) {
                    var nodelength = currnode.nodeValue.length;
                    if (curroffset + nodelength >= realoffset) {
                        var range = this.selection.getRangeAt(0);
                        // XXX does IE switch the begin and end nodes here as well?
                        var endnode = this.endNode();
                        var endoffset = this.endOffset();
                        range.setEnd(currnode, realoffset - curroffset);
                        range.setStart(endnode, endoffset);
                        return;
                    };
                    curroffset += nodelength;
                };
                currnode = currnode.nextSibling;
            };
            throw(_('Offset out of document range'));
        } else if (realoffset < 0) {
            var currnode = offsetparent.prevSibling;
            var curroffset = 0;
            while (currnode) {
                if (currnode.nodeType == 3) { // XXX need to support CDATA sections
                    var currlength = currnode.nodeValue.length;
                    if (curroffset - currlength < realoffset) {
                        var range = this.selection.getRangeAt(0);
                        range.setStart(currnode, realoffset - curroffset);
                    };
                    curroffset -= currlength;
                };
                currnode = currnode.prevSibling;
            };
        } else {
            var range = this.selection.getRangeAt(0);
            range.setStart(offsetparent, 0);
            //this.selection.removeAllRanges();
            //this.selection.addRange(range);
        };
    };

    this.moveEnd = function(offset) {
        // XXX this should be on a range object
    };

    this.reset = function() {
        this.selection = this.document.getWindow().getSelection();
    };

    this.cloneContents = function() {
        /* returns a document fragment with a copy of the contents */
        var range = this.selection.getRangeAt(0);
        return range.cloneContents();
    };

    this.containsNode = function(node) {
        return this.selection.containsNode(node, true);
    }

    this.toString = function() {
        return this.selection.toString();
    };

    this.getRange = function() {
        return this.selection.getRangeAt(0);
    }
    this.restoreRange = function(range) {
        var selection = this.selection;
        selection.removeAllRanges();
        selection.addRange(range);
    }
};

MozillaSelection.prototype = new BaseSelection;

function IESelection(document) {
    this.document = document;
    this.selection = document.getDocument().selection;

    /* If no selection in editable document, IE returns selection from
     * main page, so force an inner selection. */
    var doc = document.getDocument();

    var range = this.selection.createRange()
    var parent = this.selection.type=="Text" ?
        range.parentElement() :
        this.selection.type=="Control" ?  range.parentElement : null;

    if(parent && parent.ownerDocument != doc) {
            var range = doc.body.createTextRange();
            range.collapse();
            range.select();
    }

    this.selectNodeContents = function(node) {
        /* select the contents of a node */
        // a bit nasty, when moveToElementText is called it will move the selection start
        // to just before the element instead of inside it, and since IE doesn't reserve
        // an index for the element itself as well the way to get it inside the element is
        // by moving the start one pos and then moving it back (yuck!)
        var range = this.selection.createRange().duplicate();
        range.moveToElementText(node);
        range.moveStart('character', 1);
        range.moveStart('character', -1);
        range.moveEnd('character', -1);
        range.moveEnd('character', 1);
        range.select();
        this.selection = this.document.getDocument().selection;
    };

    this.collapse = function(collapseToEnd) {
        var range = this.selection.createRange();
        range.collapse(!collapseToEnd);
        range.select();
        this.selection = document.getDocument().selection;
    };

    this.replaceWithNode = function(newnode, selectAfterPlace) {
        /* replaces the current selection with a new node
            returns a reference to the inserted node

            newnode is the node to replace the content with, selectAfterPlace
            can either be a DOM node that should be selected after the new
            node was placed, or some value that resolves to true to select
            the placed node
        */
        if (this.selection.type == 'Control') {
            var range = this.selection.createRange();
            range.item(0).parentNode.replaceChild(newnode, range.item(0));
            for (var i=1; i < range.length; i++) {
                range.item(i).parentNode.removeChild(range[i]);
            };
            if (selectAfterPlace) {
                var range = this.document.getDocument().body.createTextRange();
                range.moveToElementText(newnode);
                range.select();
            };
        } else {
            var document = this.document.getDocument();
            var range = this.selection.createRange();

            range.pasteHTML('<img id="kupu-tempnode">');
            tempnode = document.getElementById('kupu-tempnode');
            tempnode.replaceNode(newnode);

            if (selectAfterPlace) {
                // see MozillaSelection.replaceWithNode() for some comments about
                // selectAfterPlace
                if (selectAfterPlace.nodeType == Node.ELEMENT_NODE) {
                    range.moveToElementText(selectAfterPlace);
                } else {
                    range.moveToElementText(newnode);
                };
                range.select();
            };
        };
        this.reset();
        return newnode;
    };

    this.startOffset = function() {
        var startoffset = 0;
        var selrange = this.selection.createRange();
        var parent = selrange.parentElement();
        var elrange = selrange.duplicate();
        elrange.moveToElementText(parent);
        var tempstart = selrange.duplicate();
        while (elrange.compareEndPoints('StartToStart', tempstart) < 0) {
            startoffset++;
            tempstart.moveStart('character', -1);
        };

        return startoffset;
    };

    this.endOffset = function() {
        var endoffset = 0;
        var selrange = this.selection.createRange();
        var parent = selrange.parentElement();
        var elrange = selrange.duplicate();
        elrange.moveToElementText(parent);
        var tempend = selrange.duplicate();
        while (elrange.compareEndPoints('EndToEnd', tempend) > 0) {
            endoffset++;
            tempend.moveEnd('character', 1);
        };

        return endoffset;
    };

    this.getContentLength = function() {
        if (this.selection.type == 'Control') {
            return this.selection.createRange().length;
        };
        var contentlength = 0;
        var range = this.selection.createRange();
        var endrange = range.duplicate();
        while (range.compareEndPoints('StartToEnd', endrange) < 0) {
            range.move('character', 1);
            contentlength++;
        };
        return contentlength;
    };

    this.cutChunk = function(startOffset, endOffset) {
        /* cut a chunk of HTML from the selection

            this *should* return the chunk of HTML but doesn't yet
        */
        var range = this.selection.createRange().duplicate();
        range.moveStart('character', startOffset);
        range.moveEnd('character', -endOffset);
        range.pasteHTML('');
        // XXX here it should return the chunk
    };

    this.getElementLength = function(element) {
        /* returns the length of an element *including* 1 char for each child element

            this is defined on the selection since it returns results that can be used
            to work with selection offsets
        */
        var length = 0;
        var range = this.selection.createRange().duplicate();
        range.moveToElementText(element);
        range.moveStart('character', 1);
        range.moveEnd('character', -1);
        var endpoint = range.duplicate();
        endpoint.collapse(false);
        range.collapse();
        while (!range.isEqual(endpoint)) {
            range.moveEnd('character', 1);
            range.moveStart('character', 1);
            length++;
        };
        return length;
    };

    this.parentElement = function() {
        /* return the selected node (or the node containing the selection) */
        // XXX this should be on a range object
        if (this.selection.type == 'Control') {
            return this.selection.createRange().item(0);
        } else {
            return this.selection.createRange().parentElement();
        };
    };

    // deprecated alias of parentElement
    this.getSelectedNode = this.parentElement;

    this.moveStart = function(offset) {
        /* move the start of the selection */
        var range = this.selection.createRange();
        range.moveStart('character', offset);
        range.select();
    };

    this.moveEnd = function(offset) {
        /* moves the end of the selection */
        var range = this.selection.createRange();
        range.moveEnd('character', offset);
        range.select();
    };

    this.reset = function() {
       this.selection = this.document.getDocument().selection;
    };

    this.cloneContents = function() {
        /* returns a document fragment with a copy of the contents */
        var contents = this.selection.createRange().htmlText;
        var doc = this.document.getDocument();
        var docfrag = doc.createElement('span');
        docfrag.innerHTML = contents;
        return docfrag;
    };

    this.containsNode = function(node) {
        var selected = this.selection.createRange();

        if (this.selection.type.toLowerCase()=='text') {
            var range = doc.body.createTextRange();
            range.moveToElementText(node);

            if (selected.compareEndPoints('StartToEnd', range) >= 0 ||
                selected.compareEndPoints('EndToStart', range) <= 0) {
                return false;
            }
            return true;
        } else {
            for (var i = 0; i < selected.length; i++) {
                if (selected.item(i).contains(node)) {
                    return true;
                }
            }
            return false;
        }
    };

    this.getRange = function() {
        return this.selection.createRange();
    }

    this.restoreRange = function(range) {
        try {
            range.select();
        } catch(e) {
        };
    }

    this.toString = function() {
        return this.selection.createRange().text;
    };
};

IESelection.prototype = new BaseSelection;

/* ContextFixer, fixes a problem with the prototype based model

    When a method is called in certain particular ways, for instance
    when it is used as an event handler, the context for the method
    is changed, so 'this' inside the method doesn't refer to the object
    on which the method is defined (or to which it is attached), but for
    instance to the element on which the method was bound to as an event
    handler. This class can be used to wrap such a method, the wrapper
    has one method that can be used as the event handler instead. The
    constructor expects at least 2 arguments, first is a reference to the
    method, second the context (a reference to the object) and optionally
    it can cope with extra arguments, they will be passed to the method
    as arguments when it is called (which is a nice bonus of using
    this wrapper).
*/

function ContextFixer(func, context) {
    /* Make sure 'this' inside a method points to its class */
    this.func = func;
    this.context = context;
    this.args = arguments;
    var self = this;

    this.execute = function() {
        /* execute the method */
        var args = new Array();
        // the first arguments will be the extra ones of the class
        for (var i=0; i < self.args.length - 2; i++) {
            args.push(self.args[i + 2]);
        };
        // the last are the ones passed on to the execute method
        for (var i=0; i < arguments.length; i++) {
            args.push(arguments[i]);
        };
        return self.func.apply(self.context, args);
    };

};

/* Alternative implementation of window.setTimeout

    This is a singleton class, the name of the single instance of the
    object is 'timer_instance', which has one public method called
    registerFunction. This method takes at least 2 arguments: a
    reference to the function (or method) to be called and the timeout.
    Arguments to the function are optional arguments to the
    registerFunction method. Example:

    timer_instance.registerMethod(foo, 100, 'bar', 'baz');

    will call the function 'foo' with the arguments 'bar' and 'baz' with
    a timeout of 100 milliseconds.

    Since the method doesn't expect a string but a reference to a function
    and since it can handle arguments that are resolved within the current
    namespace rather then in the global namespace, the method can be used
    to call methods on objects from within the object (so this.foo calls
    this.foo instead of failing to find this inside the global namespace)
    and since the arguments aren't strings which are resolved in the global
    namespace the arguments work as expected even inside objects.

*/

function Timer() {
    /* class that has a method to replace window.setTimeout */
    this.lastid = 0;
    this.functions = {};

    this.registerFunction = function(object, func, timeout) {
        /* register a function to be called with a timeout

            args:
                func - the function
                timeout - timeout in millisecs

            all other args will be passed 1:1 to the function when called
        */
        var args = new Array();
        for (var i=0; i < arguments.length - 3; i++) {
            args.push(arguments[i + 3]);
        }
        var id = this._createUniqueId();
        this.functions[id] = new Array(object, func, args);
        setTimeout("timer_instance._handleFunction(" + id + ")", timeout);
    };

    this._handleFunction = function(id) {
        /* private method that does the actual function call */
        var obj = this.functions[id][0];
        var func = this.functions[id][1];
        var args = this.functions[id][2];
        this.functions[id] = null;
        func.apply(obj, args);
    };

    this._createUniqueId = function() {
        /* create a unique id to store the function by */
        while (this.lastid in this.functions && this.functions[this.lastid]) {
            this.lastid++;
            if (this.lastid > 100000) {
                this.lastid = 0;
            }
        }
        return this.lastid;
    };
};

// create a timer instance in the global namespace, obviously this does some
// polluting but I guess it's impossible to avoid...

// OBVIOUSLY THIS VARIABLE SHOULD NEVER BE OVERWRITTEN!!!
timer_instance = new \Ximdex\Utils\Timer();

// helper function on the Array object to test for containment
Array.prototype.contains = function(element, objectequality) {
    /* see if some value is in this */
    for (var i=0; i < this.length; i++) {
        if (objectequality) {
            if (element === this[i]) {
                return true;
            };
        } else {
            if (element == this[i]) {
                return true;
            };
        };
    };
    return false;
};

// return a copy of an array with doubles removed
Array.prototype.removeDoubles = function() {
    var ret = [];
    for (var i=0; i < this.length; i++) {
        if (!ret.contains(this[i])) {
            ret.push(this[i]);
        };
    };
    return ret;
};

Array.prototype.map = function(func) {
    /* apply 'func' to each element in the array */
    for (var i=0; i < this.length; i++) {
        this[i] = func(this[i]);
    };
};

Array.prototype.reversed = function() {
    var ret = [];
    for (var i = this.length; i > 0; i--) {
        ret.push(this[i - 1]);
    };
    return ret;
};

// JavaScript has a friggin' blink() function, but not for string stripping...
String.prototype.strip = function() {
    var stripspace = /^\s*([\s\S]*?)\s*$/;
    return stripspace.exec(this)[1];
};

String.prototype.reduceWhitespace = function() {
    /* returns a string in which all whitespace is reduced
        to a single, plain space */
    var spacereg = /(\s+)/g;
    var copy = this;
    while (true) {
        var match = spacereg.exec(copy);
        if (!match) {
            return copy;
        };
        copy = copy.replace(match[0], ' ');
    };
};

String.prototype.entitize = function() {
    var ret = this.replace(/&/g, '&amp;');
    ret = ret.replace(/"/g, '&quot;');
    ret = ret.replace(/'/g, '&apos;');
    ret = ret.replace(/</g, '&lt;');
    ret = ret.replace(/>/g, '&gt;');
    return ret;
};

String.prototype.deentitize = function() {
    var ret = this.replace(/&gt;/g, '>');
    ret = ret.replace(/&lt;/g, '<');
    ret = ret.replace(/&quot;/g, '"');
    ret = ret.replace(/&apos;/g, "'");
    ret = ret.replace(/&amp;/g, '&');
    return ret;
};

String.prototype.urldecode = function() {
    var reg = /%([a-fA-F0-9]{2})/g;
    var str = this;
    while (true) {
        var match = reg.exec(str);
        if (!match || !match.length) {
            break;
        };
        var repl = new RegExp(match[0], 'g');
        str = str.replace(repl, String.fromCharCode(parseInt(match[1], 16)));
    };
    return str;
};

String.prototype.centerTruncate = function(maxlength) {
    if (this.length <= maxlength) {
        return this;
    };
    var chunklength = maxlength / 2 - 3;
    var start = this.substr(0, chunklength);
    var end = this.substr(this.length - chunklength);
    return start + ' ... ' + end;
};

//----------------------------------------------------------------------------
// Exceptions
//----------------------------------------------------------------------------

function debug(str, win) {
    if (!win) {
        win = window;
    };
    var doc = win.document;
    var div = doc.createElement('div');
    div.appendChild(doc.createTextNode(str));
    doc.getElementsByTagName('body')[0].appendChild(div);
};

// XXX don't know if this is the regular way to define exceptions in JavaScript?
function Exception() {
    return;
};

// throw this as an exception inside an updateState handler to restart the
// update, may be required in situations where updateState changes the structure
// of the document (e.g. does a cleanup or so)
UpdateStateCancelBubble = new Exception();
/*****************************************************************************
 *
 * Copyright (c) 2003-2005 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id: kupubasetools.js 21219 2005-12-16 15:45:56Z duncan $


//----------------------------------------------------------------------------
//
// Toolboxes
//
//  These are addons for Kupu, simple plugins that implement a certain
//  interface to provide functionality and control view aspects.
//
//----------------------------------------------------------------------------

//----------------------------------------------------------------------------
// Superclasses
//----------------------------------------------------------------------------

function KupuTool() {
    /* Superclass (or actually more of an interface) for tools

        Tools must implement at least an initialize method and an
        updateState method, and can implement other methods to add
        certain extra functionality (e.g. createContextMenuElements).
    */

    this.toolboxes = {};

    // methods
    this.initialize = function(editor) {
        /* Initialize the tool.

            Obviously this can be overriden but it will do
            for the most simple cases
        */
        this.editor = editor;
    };

    this.registerToolBox = function(id, toolbox) {
        /* register a ui box

            Note that this needs to be called *after* the tool has been
            registered to the KupuEditor
        */
        this.toolboxes[id] = toolbox;
        toolbox.initialize(this, this.editor);
    };

    this.updateState = function(selNode, event) {
        /* Is called when user moves cursor to other element

            Calls the updateState for all toolboxes and may want perform
            some actions itself
        */
        for (id in this.toolboxes) {
            this.toolboxes[id].updateState(selNode, event);
        };
    };

    this.enable = function() {
        // Called when the tool is enabled after a form is dismissed.
    }

    this.disable = function() {
        // Called when the tool is disabled (e.g. for a modal form)
    }
    // private methods
    addEventHandler = addEventHandler;

    this._selectSelectItem = function(select, item) {
        this.editor.logMessage(_('Deprecation warning: KupuTool._selectSelectItem'));
    };
    this._fixTabIndex = function(element) {
        var tabIndex = this.editor.getDocument().getEditable().tabIndex-1;
        if (tabIndex && !element.tabIndex) {
            element.tabIndex = tabIndex;
        }
    }
}

function KupuToolBox() {
    /* Superclass for a user-interface object that controls a tool */

    this.initialize = function(tool, editor) {
        /* store a reference to the tool and the editor */
        this.tool = tool;
        this.editor = editor;
    };

    this.updateState = function(selNode, event) {
        /* update the toolbox according to the current iframe's situation */
    };

    this._selectSelectItem = function(select, item) {
        this.editor.logMessage(_('Deprecation warning: KupuToolBox._selectSelectItem'));
    };
};

function NoContextMenu(object) {
    /* Decorator for a tool to suppress the context menu */
    object.createContextMenuElements = function(selNode, event) {
        return [];
    }
    return object;
}

// Helper function for enabling/disabling tools
function KupuButtonDisable(button) {
    button = button || this.button;
    button.disabled = "disabled";
    button.className += ' disabled';
}
function KupuButtonEnable(button) {
    button = button || this.button;
    button.disabled = "";
    button.className = button.className.replace(/ *\bdisabled\b/g, '');
}


//----------------------------------------------------------------------------
// Implementations
//----------------------------------------------------------------------------

function KupuButton(buttonid, commandfunc, tool) {
    /* Base prototype for kupu button tools */
    this.buttonid = buttonid;
    this.button = getFromSelector(buttonid);
    this.commandfunc = commandfunc;
    this.tool = tool;

    this.initialize = function(editor) {
        this.editor = editor;
        this._fixTabIndex(this.button);
        addEventHandler(this.button, 'click', this.execCommand, this);
    };

    this.execCommand = function() {
        /* exec this button's command */
        this.commandfunc(this, this.editor, this.tool);
    };

    this.updateState = function(selNode, event) {
        /* override this in subclasses to determine whether a button should
            look 'pressed in' or not
        */
    };
    this.disable = KupuButtonDisable;
    this.enable = KupuButtonEnable;
};

KupuButton.prototype = new KupuTool;
function KupuStateButton(buttonid, commandfunc, checkfunc, offclass, onclass) {
    /* A button that can have two states (e.g. pressed and
       not-pressed) based on CSS classes */
    this.buttonid = buttonid;
    this.button = getFromSelector(buttonid);
    this.commandfunc = commandfunc;
    this.checkfunc = checkfunc;
    this.offclass = offclass;
    this.onclass = onclass;
    this.pressed = false;

    this.execCommand = function() {
        /* exec this button's command */
        this.button.className = (this.pressed ? this.offclass : this.onclass);
        this.pressed = !this.pressed;
        this.editor.focusDocument();
        this.commandfunc(this, this.editor);
    };

    this.updateState = function(selNode, event) {
        /* check if we need to be clicked or unclicked, and update accordingly

            if the state of the button should be changed, we set the class
        */
        var currclass = this.button.className;
        var newclass = null;
        if (this.checkfunc(selNode, this, this.editor, event)) {
            newclass = this.onclass;
            this.pressed = true;
        } else {
            newclass = this.offclass;
            this.pressed = false;
        };
        if (currclass != newclass) {
            this.button.className = newclass;
        };
    };
};

KupuStateButton.prototype = new KupuButton;

/* Same as the state button, but the focusDocument call is delayed.
 * Mozilla&Firefox have a bug on windows which can cause a crash if you
 * change CSS positioning styles on an element which has focus.
 */
function KupuLateFocusStateButton(buttonid, commandfunc, checkfunc, offclass, onclass) {
    KupuStateButton.apply(this, [buttonid, commandfunc, checkfunc, offclass, onclass]);
    this.execCommand = function() {
        /* exec this button's command */
        this.button.className = (this.pressed ? this.offclass : this.onclass);
        this.pressed = !this.pressed;
        this.commandfunc(this, this.editor);
        this.editor.focusDocument();
    };
}
KupuLateFocusStateButton.prototype = new KupuStateButton;

function KupuRemoveElementButton(buttonid, element_name, cssclass) {
    /* A button specialized in removing elements in the current node
       context. Typical usages include removing links, images, etc. */
    this.button = getFromSelector(buttonid);
    this.onclass = 'invisible';
    this.offclass = cssclass;
    this.pressed = false;

    this.commandfunc = function(button, editor) {
        editor.removeNearestParentOfType(editor.getSelectedNode(), element_name);
    };

    this.checkfunc = function(currnode, button, editor, event) {
        var element = editor.getNearestParentOfType(currnode, element_name);
        return (element ? false : true);
    };
};

KupuRemoveElementButton.prototype = new KupuStateButton;

function KupuUI(textstyleselectid) {
    /* View

        This is the main view, which controls most of the toolbar buttons.
        Even though this is probably never going to be removed from the view,
        it was easier to implement this as a plain tool (plugin) as well.
    */

    // attributes
    this.tsselect = getFromSelector(textstyleselectid);
    var paraoptions = [];
    var tableoptions = [];
    this.optionstate = -1;
    this.otherstyle = null;
    this.tablestyles = {};
    this.styles = {}; // use an object here so we can use the 'in' operator later on

    this.initialize = function(editor) {
        /* initialize the ui like tools */
        this.editor = editor;
        this.cleanStyles();
        this.enableOptions(false);
        this._fixTabIndex(this.tsselect);
        this._selectevent = addEventHandler(this.tsselect, 'change', this.setTextStyleHandler, this);
    };

    this.getStyles = function() {
        if (!paraoptions) {
            this.cleanStyles();
        }
        return [ paraoptions, tableoptions ];
    }

    this.setTextStyleHandler = function(event) {
        this.setTextStyle(this.tsselect.options[this.tsselect.selectedIndex].value);
    };

    // event handlers
    this.basicButtonHandler = function(action) {
        /* event handler for basic actions (toolbar buttons) */
        this.editor.execCommand(action);
        this.editor.updateState();
    };

    this.saveButtonHandler = function() {
        /* handler for the save button */
        this.editor.saveDocument();
    };

    this.saveAndExitButtonHandler = function(redirect_url) {
        /* save the document and, if successful, redirect */
        this.editor.saveDocument(redirect_url);
    };

    this.cutButtonHandler = function() {
        try {
            this.editor.execCommand('Cut');
        } catch (e) {
            if (this.editor.getBrowserName() == 'Mozilla') {
                alert(_('Cutting from JavaScript is disabled on your Mozilla due to security settings. For more information, read http://www.mozilla.org/editor/midasdemo/securityprefs.html'));
            } else {
                throw e;
            };
        };
        this.editor.updateState();
    };

    this.copyButtonHandler = function() {
        try {
            this.editor.execCommand('Copy');
        } catch (e) {
            if (this.editor.getBrowserName() == 'Mozilla') {
                alert(_('Copying from JavaScript is disabled on your Mozilla due to security settings. For more information, read http://www.mozilla.org/editor/midasdemo/securityprefs.html'));
            } else {
                throw e;
            };
        };
        this.editor.updateState();
    };

    this.pasteButtonHandler = function() {
        try {
            this.editor.execCommand('Paste');
        } catch (e) {
            if (this.editor.getBrowserName() == 'Mozilla') {
                alert(_('Pasting from JavaScript is disabled on your Mozilla due to security settings. For more information, read http://www.mozilla.org/editor/midasdemo/securityprefs.html'));
            } else {
                throw e;
            };
        };
        this.editor.updateState();
    };

    this.cleanStyles = function() {
        var options = this.tsselect.options;
        var parastyles = this.styles;
        var tablestyles = this.tablestyles;

        tableoptions.push([options[0].text, 'td|']);
        tablestyles['td'] = 0;
        paraoptions.push([options[0].text, 'p|']);
        parastyles['p'] = 0;
        while (options.length > 1) {
            opt = options[1];
            var v = opt.value;
            if (/^thead|tbody|table|t[rdh]\b/i.test(v)) {
                var otable = tableoptions;
                var styles = tablestyles;
            } else {
                var otable = paraoptions;
                var styles = parastyles;
            }
            if (v.indexOf('|') > -1) {
                var split = v.split('|');
                v = split[0].toLowerCase() + "|" + split[1];
            } else {
                v = v.toLowerCase()+"|";
            };
            otable.push([opt.text, v]);
            styles[v] = otable.length - 1;
            options[1] = null;
        }
        options[0] = null;
    }

    // Remove otherstyle and switch to appropriate style set.
    this.enableOptions = function(inTable) {
        var select = this.tsselect;
        var options = select.options;
        if (this.otherstyle) {
            options[options.length-1] = null;
            this.otherstyle = null;
        }
        if (this.optionstate == inTable) return; /* No change */

        var valid = inTable ? tableoptions : paraoptions;

        while (options.length) options[0] = null;
        this.otherstyle = null;

        for (var i = 0; i < valid.length; i++) {
            var opt = document.createElement('option');
            opt.text = valid[i][0];
            opt.value = valid[i][1];
            options.add(opt);
        }
        select.selectedIndex = 0;
        this.optionstate = inTable;
    }

    this.setIndex = function(currnode, tag, index, styles) {
        var className = currnode.className;
        this.styletag = tag;
        this.classname = className;
        var style = tag+'|'+className;

        if (style in styles) {
            return styles[style];
        } else if (!className && tag in styles) {
            return styles[tag];
        }
        return index;
    }

    this.nodeStyle = function(node) {
        var currnode = node;
        var index = -1;
        var options = this.tsselect.options;
        this.styletag = undefined;
        this.classname = '';
        this.intable = false;

        while (currnode) {
            var tag = currnode.nodeName.toLowerCase();

            if (/^body$/.test(tag)) {
                if (!this.styletag) {
                    // Force style setting
                    //this.setTextStyle(options[0].value, true);
                    // Forced style messes up in Firefox: return -1 to
                    // indicate no style
                    return -1;
                }
                break;
            }
            if (/^(p|div|h.|ul|ol|dl|menu|dir|pre|blockquote|address|center)$/.test(tag)) {
                index = this.setIndex(currnode, tag, index, this.styles);
            }
            if (/^thead|tbody|table|t[rdh]$/.test(tag)) {
                this.intable = true;
                index = this.setIndex(currnode, tag, index, this.tablestyles);

                if (index > 0 || tag=='table') {
                    return index; // Stop processing if in a table
                }
            }
            currnode = currnode.parentNode;
        }
        return index;
    }

    this.updateState = function(selNode) {
        /* set the text-style pulldown */

        // first get the nearest style
        // search the list of nodes like in the original one, break if we encounter a match,
        // this method does some more than the original one since it can handle commands in
        // the form of '<style>|<classname>' next to the plain
        // '<style>' commands
        var index = undefined;
        var mixed = false;
        var styletag, classname;

        var selection = this.editor.getSelection();

        for (var el=selNode.firstChild; el; el=el.nextSibling) {
            if (el.nodeType==1 && selection.containsNode(el)) {
                var i = this.nodeStyle(el);
                if (index===undefined) {
                    index = i;
                    styletag = this.styletag;
                    classname = this.classname;
                }
                if (index != i || styletag!=this.styletag || classname != this.classname) {
                    mixed = true;
                    break;
                }
            }
        };

        if (index===undefined) {
            index = this.nodeStyle(selNode);
        }

        this.enableOptions(this.intable);

        if (index < 0 || mixed) {
            if (mixed) {
                var caption = 'Mixed styles';
            } else if (this.styletag) {
                var caption = 'Other: ' + this.styletag + ' '+ this.classname;
            } else {
                var caption = '<no style>';
            }

            var opt = document.createElement('option');
            opt.text = caption;
            this.otherstyle = opt;
            this.tsselect.options.add(opt);

            index = this.tsselect.length-1;
        }
        this.tsselect.selectedIndex = Math.max(index,0);
    };

    this._cleanNode = function(node) {
                /* Clean up a block style node (e.g. P, DIV, Hn)
                 * Remove trailing whitespace, then also remove up to one
                 * trailing <br>
                 * If the node is now empty, remove the node itself.
                 */
        var len = node.childNodes.length;
        function stripspace() {
            var c;
            while ((c = node.lastChild) && c.nodeType==3 && /^\s*$/.test(c.data)) {
                node.removeChild(c);
            }
        }
        stripspace();
        var c = node.lastChild;
        if (c && c.nodeType==1 && c.tagName=='BR') {
            node.removeChild(c);
        }
        stripspace();
        if (node.childNodes.length==0) {
            node.parentNode.removeChild(node);
        };
    }

    this._cleanCell = function(eltype, classname) {
        var selNode = this.editor.getSelectedNode();
        var el = this.editor.getNearestParentOfType(selNode, eltype);
        if (!el) {
                // Maybe changing type
            el = this.editor.getNearestParentOfType(selNode, eltype=='TD'?'TH':'TD');
        }
        if (!el) return;

            // Remove formatted div or p from a cell
        var node, nxt, n;
        for (node = el.firstChild; node;) {
            if (/DIV|P/.test(node.nodeName)) {
                for (var n = node.firstChild; n;) {
                    var nxt = n.nextSibling;
                    el.insertBefore(n, node); // Move nodes out of div
                    n = nxt;
                }
                nxt = node.nextSibling;
                el.removeChild(node);
                node = nxt;
            } else {
                node = node.nextSibling;
            }
        }
        if (eltype != el.tagName) {
                // Change node type.
            var node = el.ownerDocument.createElement(eltype);
            var parent = el.parentNode;
            parent.insertBefore(node, el);
            while (el.firstChild) {
                node.appendChild(el.firstChild);
            }
            parent.removeChild(el);
            el = node;
        }
            // now set the classname
        if (classname) {
            el.className = classname;
        } else {
            el.removeAttribute("class");
            el.removeAttribute("className");
        }

    }

    this._setClass = function(el, classname) {
        var parent = el.parentNode;
        if (parent.tagName=='DIV') {
            // fixup buggy formatting
            var gp = parent.parentNode;
            if (el != parent.firstChild) {
                var previous = parent.cloneNode(false);
                while (el != parent.firstChild) {
                    previous.appendChild(parent.firstChild);
                }
                gp.insertBefore(previous, parent);
                this._cleanNode(previous);
            }
            gp.insertBefore(el, parent);
            this._cleanNode(el);
            this._cleanNode(parent);
        } else {
            this._cleanNode(el);
        }
        // now set the classname
        if (classname) {
            el.className = classname;
        } else {
            el.removeAttribute("class");
            el.removeAttribute("className");
        }
    }
    this.setTextStyle = function(style, noupdate) {
            /* parse the argument into a type and classname part
               generate a block element accordingly
            */
        var classname = '';
        var eltype = style.toUpperCase();
        if (style.indexOf('|') > -1) {
            style = style.split('|');
            eltype = style[0].toUpperCase();
            classname = style[1];
        };

        var command = eltype;
            // first create the element, then find it and set the classname
        if (this.editor.getBrowserName() == 'IE') {
            command = '<' + eltype + '>';
        };
        if (/T[RDH]/.test(eltype)) {
            this._cleanCell(eltype, classname);
        }
        else {
            this.editor.getDocument().execCommand('formatblock', command);

                // now get a reference to the element just added
            var selNode = this.editor.getSelectedNode();
            var el = this.editor.getNearestParentOfType(selNode, eltype);
            if (el) {
                this._setClass(el, classname);
            } else {
                var selection = this.editor.getSelection();
                var elements = selNode.getElementsByTagName(eltype);
                for (var i = 0; i < elements.length; i++) {
                    el = elements[i];
                    if (selection.containsNode(el)) {
                        this._setClass(el, classname);
                    }
                }
            }
        }
        if (el) {
            this.editor.getSelection().selectNodeContents(el);
        }
        if (!noupdate) {
            this.editor.updateState();
        }
    };

    this.createContextMenuElements = function(selNode, event) {
        var ret = new Array();
        ret.push(new ContextMenuElement(_('Cut'),
                    this.cutButtonHandler, this));
        ret.push(new ContextMenuElement(_('Copy'),
                    this.copyButtonHandler, this));
        ret.push(new ContextMenuElement(_('Paste'),
                    this.pasteButtonHandler, this));
        return ret;
    };
    this.disable = function() {
        this.tsselect.disabled = "disabled";
    }
    this.enable = function() {
        this.tsselect.disabled = "";
    }
}

KupuUI.prototype = new KupuTool;

function ColorchooserTool(fgcolorbuttonid, hlcolorbuttonid, colorchooserid) {
    /* the colorchooser */

    this.fgcolorbutton = getFromSelector(fgcolorbuttonid);
    this.hlcolorbutton = getFromSelector(hlcolorbuttonid);
    this.ccwindow = getFromSelector(colorchooserid);
    this.command = null;

    this.initialize = function(editor) {
        /* attach the event handlers */
        this.editor = editor;

        this.createColorchooser(this.ccwindow);

        addEventHandler(this.fgcolorbutton, "click", this.openFgColorChooser, this);
        addEventHandler(this.hlcolorbutton, "click", this.openHlColorChooser, this);
        addEventHandler(this.ccwindow, "click", this.chooseColor, this);

        this.hide();

        this.editor.logMessage(_('Colorchooser tool initialized'));
    };

    this.updateState = function(selNode) {
        /* update state of the colorchooser */
        this.hide();
    };

    this.openFgColorChooser = function() {
        /* event handler for opening the colorchooser */
        this.command = "forecolor";
        this.show();
    };

    this.openHlColorChooser = function() {
        /* event handler for closing the colorchooser */
        if (this.editor.getBrowserName() == "IE") {
            this.command = "backcolor";
        } else {
            this.command = "hilitecolor";
        }
        this.show();
    };

    this.chooseColor = function(event) {
        /* event handler for choosing the color */
        var target = _SARISSA_IS_MOZ ? event.target : event.srcElement;
        var cell = this.editor.getNearestParentOfType(target, 'td');
        this.editor.execCommand(this.command, cell.getAttribute('bgColor'));
        this.hide();

        this.editor.logMessage(_('Color chosen'));
    };

    this.show = function(command) {
        /* show the colorchooser */
        this.ccwindow.style.display = "block";
    };

    this.hide = function() {
        /* hide the colorchooser */
        this.command = null;
        this.ccwindow.style.display = "none";
    };

    this.createColorchooser = function(table) {
        /* create the colorchooser table */

        var chunks = new Array('00', '33', '66', '99', 'CC', 'FF');
        table.setAttribute('id', 'kupu-colorchooser-table');
        table.style.borderWidth = '2px';
        table.style.borderStyle = 'solid';
        table.style.position = 'absolute';
        table.style.cursor = 'default';
        table.style.display = 'none';

        var tbody = document.createElement('tbody');

        for (var i=0; i < 6; i++) {
            var tr = document.createElement('tr');
            var r = chunks[i];
            for (var j=0; j < 6; j++) {
                var g = chunks[j];
                for (var k=0; k < 6; k++) {
                    var b = chunks[k];
                    var color = '#' + r + g + b;
                    var td = document.createElement('td');
                    td.setAttribute('bgColor', color);
                    td.style.backgroundColor = color;
                    td.style.borderWidth = '1px';
                    td.style.borderStyle = 'solid';
                    td.style.fontSize = '1px';
                    td.style.width = '10px';
                    td.style.height = '10px';
                    var text = document.createTextNode('\u00a0');
                    td.appendChild(text);
                    tr.appendChild(td);
                }
            }
            tbody.appendChild(tr);
        }
        table.appendChild(tbody);

        return table;
    };
    this.enable = function() {
        KupuButtonEnable(this.fgcolorbutton);
        KupuButtonEnable(this.hlcolorbutton);
    }
    this.disable = function() {
        KupuButtonDisable(this.fgcolorbutton);
        KupuButtonDisable(this.hlcolorbutton);
    }
}

ColorchooserTool.prototype = new KupuTool;

function PropertyTool(titlefieldid, descfieldid) {
    /* The property tool */

    this.titlefield = getFromSelector(titlefieldid);
    this.descfield = getFromSelector(descfieldid);

    this.initialize = function(editor) {
        /* attach the event handlers and set the initial values */
        this.editor = editor;
        addEventHandler(this.titlefield, "change", this.updateProperties, this);
        addEventHandler(this.descfield, "change", this.updateProperties, this);

        // set the fields
        var heads = this.editor.getInnerDocument().getElementsByTagName('head');
        if (!heads[0]) {
            this.editor.logMessage(_('No head in document!'), 1);
        } else {
            var head = heads[0];
            var titles = head.getElementsByTagName('title');
            if (titles.length) {
                this.titlefield.value = titles[0].text;
            }
            var metas = head.getElementsByTagName('meta');
            if (metas.length) {
                for (var i=0; i < metas.length; i++) {
                    var meta = metas[i];
                    if (meta.getAttribute('name') &&
                            meta.getAttribute('name').toLowerCase() ==
                            'description') {
                        this.descfield.value = meta.getAttribute('content');
                        break;
                    }
                }
            }
        }

        this.editor.logMessage(_('Property tool initialized'));
    };

    this.updateProperties = function() {
        /* event handler for updating the properties form */
        var doc = this.editor.getInnerDocument();
        var heads = doc.getElementsByTagName('HEAD');
        if (!heads) {
            this.editor.logMessage(_('No head in document!'), 1);
            return;
        }

        var head = heads[0];

        // set the title
        var titles = head.getElementsByTagName('title');
        if (!titles) {
            var title = doc.createElement('title');
            var text = doc.createTextNode(this.titlefield.value);
            title.appendChild(text);
            head.appendChild(title);
        } else {
            var title = titles[0];
            // IE6 title has no children, and refuses appendChild.
            // Delete and recreate the title.
            if (title.childNodes.length == 0) {
                title.removeNode(true);
                title = doc.createElement('title');
                title.innerText = this.titlefield.value;
                head.appendChild(title);
            } else {
                title.childNodes[0].nodeValue = this.titlefield.value;
            }
        }
        document.title = this.titlefield.value;

        // let's just fulfill the usecase, not think about more properties
        // set the description
        var metas = doc.getElementsByTagName('meta');
        var descset = 0;
        for (var i=0; i < metas.length; i++) {
            var meta = metas[i];
            if (meta.getAttribute('name') &&
                    meta.getAttribute('name').toLowerCase() == 'description') {
                meta.setAttribute('content', this.descfield.value);
                descset = 1;
            }
        }

        if (!descset) {
            var meta = doc.createElement('meta');
            meta.setAttribute('name', 'description');
            meta.setAttribute('content', this.descfield.value);
            head.appendChild(meta);
        }

        this.editor.logMessage(_('Properties modified'));
    };
}

PropertyTool.prototype = new KupuTool;

function LinkTool() {
    /* Add and update hyperlinks */

    this.initialize = function(editor) {
        this.editor = editor;
        this.editor.logMessage(_('Link tool initialized'));
    };

    this.createLinkHandler = function(event) {
        /* create a link according to a url entered in a popup */
        var linkWindow = openPopup('kupupopups/link.html', 300, 200);
        linkWindow.linktool = this;
        linkWindow.focus();
    };

    this.updateLink = function (linkel, url, type, name, target, title) {
        if (type && type == 'anchor') {
            linkel.removeAttribute('href');
            linkel.setAttribute('name', name);
        } else {
            linkel.href = url;
            if (linkel.innerHTML == "") {
                var doc = this.editor.getInnerDocument();
                linkel.appendChild(doc.createTextNode(title || url));
            }
            if (title) {
                linkel.title = title;
            } else {
                linkel.removeAttribute('title');
            }
            if (target && target != '') {
                linkel.setAttribute('target', target);
            }
            else {
                linkel.removeAttribute('target');
            };
            linkel.style.color = this.linkcolor;
        };
    };

    this.formatSelectedLink = function(url, type, name, target, title) {
        var currnode = this.editor.getSelectedNode();

        // selection inside link
        var linkel = this.editor.getNearestParentOfType(currnode, 'A');
        if (linkel) {
            this.updateLink(linkel, url, type, name, target, title);
            return true;
        }

        if (currnode.nodeType!=1) return false;

        // selection contains links
        var linkelements = currnode.getElementsByTagName('A');
        var selection = this.editor.getSelection();
        var containsLink = false;
        for (var i = 0; i < linkelements.length; i++) {
            linkel = linkelements[i];
            if (selection.containsNode(linkel)) {
                this.updateLink(linkel, url, type, name, target, title);
                containsLink = true;
            }
        };
        return containsLink;
    }

    // Can create a link in the following circumstances:
    //   The selection is inside a link:
    //      just update the link attributes.
    //   The selection contains links:
    //      update the attributes of the contained links
    //   No links inside or outside the selection:
    //      create a link around the selection
    //   No selection:
    //      insert a link containing the title
    //
    // the order of the arguments is a bit odd here because of backward
    // compatibility
    this.createLink = function(url, type, name, target, title) {
        if (!this.formatSelectedLink(url, type, name, target, title)) {
            // No links inside or outside.
            this.editor.execCommand("CreateLink", url);
            if (!this.formatSelectedLink(url, type, name, target, title)) {
                // Insert link with no text selected, insert the title
                // or URI instead.
                var doc = this.editor.getInnerDocument();
                linkel = doc.createElement("a");
                linkel.setAttribute('href', url);
                linkel.setAttribute('class', 'generated');
                this.editor.getSelection().replaceWithNode(linkel, true);
                this.updateLink(linkel, url, type, name, target, title);
            };
        }
        this.editor.logMessage(_('Link added'));
        this.editor.updateState();
    };

    this.deleteLink = function() {
        /* delete the current link */
        var currnode = this.editor.getSelectedNode();
        var linkel = this.editor.getNearestParentOfType(currnode, 'a');
        if (!linkel) {
            this.editor.logMessage(_('Not inside link'));
            return;
        };
        while (linkel.childNodes.length) {
            linkel.parentNode.insertBefore(linkel.childNodes[0], linkel);
        };
        linkel.parentNode.removeChild(linkel);

        this.editor.logMessage(_('Link removed'));
        this.editor.updateState();
    };

    this.createContextMenuElements = function(selNode, event) {
        /* create the 'Create link' or 'Remove link' menu elements */
        var ret = new Array();
        var link = this.editor.getNearestParentOfType(selNode, 'a');
        if (link) {
            ret.push(new ContextMenuElement(_('Delete link'), this.deleteLink, this));
        } else {
            ret.push(new ContextMenuElement(_('Create link'), this.createLinkHandler, this));
        };
        return ret;
    };
}

LinkTool.prototype = new KupuTool;

function LinkToolBox(inputid, buttonid, toolboxid, plainclass, activeclass) {
    /* create and edit links */

    this.input = getFromSelector(inputid);
    this.button = getFromSelector(buttonid);
    this.toolboxel = getFromSelector(toolboxid);
    this.plainclass = plainclass;
    this.activeclass = activeclass;

    this.initialize = function(tool, editor) {
        /* attach the event handlers */
        this.tool = tool;
        this.editor = editor;
        addEventHandler(this.input, "blur", this.updateLink, this);
        addEventHandler(this.button, "click", this.addLink, this);
    };

    this.updateState = function(selNode) {
        /* if we're inside a link, update the input, else empty it */
        var linkel = this.editor.getNearestParentOfType(selNode, 'a');
        if (linkel) {
            // check first before setting a class for backward compatibility
            if (this.toolboxel) {
                this.toolboxel.className = this.activeclass;
            };
            this.input.value = linkel.getAttribute('href');
        } else {
            // check first before setting a class for backward compatibility
            if (this.toolboxel) {
                this.toolboxel.className = this.plainclass;
            };
            this.input.value = '';
        }
    };

    this.addLink = function(event) {
        /* add a link */
        var url = this.input.value;
        this.tool.createLink(url);
    };

    this.updateLink = function() {
        /* update the current link */
        var currnode = this.editor.getSelectedNode();
        var linkel = this.editor.getNearestParentOfType(currnode, 'A');
        if (!linkel) {
            return;
        }

        var url = this.input.value;
        linkel.setAttribute('href', url);

        this.editor.logMessage(_('Link modified'));
    };
};

LinkToolBox.prototype = new LinkToolBox;

function ImageTool() {
    /* Image tool to add images */

    this.initialize = function(editor) {
        /* attach the event handlers */
        this.editor = editor;
        this.editor.logMessage(_('Image tool initialized'));
    };

    this.createImageHandler = function(event) {
        /* create an image according to a url entered in a popup */
        var imageWindow = openPopup('kupupopups/image.html', 300, 200);
        imageWindow.imagetool = this;
        imageWindow.focus();
    };

    this.createImage = function(url, alttext, imgclass) {
        /* create an image */
        var img = this.editor.getInnerDocument().createElement('img');
        img.src = url;
        img.removeAttribute('height');
        img.removeAttribute('width');
        if (alttext) {
            img.alt = alttext;
        };
        if (imgclass) {
            img.className = imgclass;
        };
        img = this.editor.insertNodeAtSelection(img, 1);
        this.editor.logMessage(_('Image inserted'));
        this.editor.updateState();
        return img;
    };

    this.setImageClass = function(imgclass) {
        /* set the class of the selected image */
        var currnode = this.editor.getSelectedNode();
        var currimg = this.editor.getNearestParentOfType(currnode, 'IMG');
        if (currimg) {
            currimg.className = imgclass;
        };
    };

    this.createContextMenuElements = function(selNode, event) {
        return new Array(new ContextMenuElement(_('Create image'), this.createImageHandler, this));
    };
}

ImageTool.prototype = new KupuTool;

function ImageToolBox(inputfieldid, insertbuttonid, classselectid, toolboxid, plainclass, activeclass) {
    /* toolbox for adding images */

    this.inputfield = getFromSelector(inputfieldid);
    this.insertbutton = getFromSelector(insertbuttonid);
    this.classselect = getFromSelector(classselectid);
    this.toolboxel = getFromSelector(toolboxid);
    this.plainclass = plainclass;
    this.activeclass = activeclass;

    this.initialize = function(tool, editor) {
        this.tool = tool;
        this.editor = editor;
        addEventHandler(this.classselect, "change", this.setImageClass, this);
        addEventHandler(this.insertbutton, "click", this.addImage, this);
    };

    this.updateState = function(selNode, event) {
        /* update the state of the toolbox element */
        var imageel = this.editor.getNearestParentOfType(selNode, 'img');
        if (imageel) {
            // check first before setting a class for backward compatibility
            if (this.toolboxel) {
                this.toolboxel.className = this.activeclass;
                this.inputfield.value = imageel.getAttribute('src');
                var imgclass = imageel.className ? imageel.className : 'image-inline';
                selectSelectItem(this.classselect, imgclass);
            };
        } else {
            if (this.toolboxel) {
                this.toolboxel.className = this.plainclass;
            };
        };
    };

    this.addImage = function() {
        /* add an image */
        var url = this.inputfield.value;
        var sel_class = this.classselect.options[this.classselect.selectedIndex].value;
        this.tool.createImage(url, null, sel_class);
        this.editor.focusDocument();
    };

    this.setImageClass = function() {
        /* set the class for the current image */
        var sel_class = this.classselect.options[this.classselect.selectedIndex].value;
        this.tool.setImageClass(sel_class);
        this.editor.focusDocument();
    };
};

ImageToolBox.prototype = new KupuToolBox;

function TableTool() {
    /* The table tool */

    // XXX There are some awfully long methods in here!!
    this.createContextMenuElements = function(selNode, event) {
        var table =  this.editor.getNearestParentOfType(selNode, 'table');
        if (!table) {
            ret = new Array();
            var el = new ContextMenuElement(_('Add table'), this.addPlainTable, this);
            ret.push(el);
            return ret;
        } else {
            var ret = new Array();
            ret.push(new ContextMenuElement(_('Add row'), this.addTableRow, this));
            ret.push(new ContextMenuElement(_('Delete row'), this.delTableRow, this));
            ret.push(new ContextMenuElement(_('Add column'), this.addTableColumn, this));
            ret.push(new ContextMenuElement(_('Delete column'), this.delTableColumn, this));
            ret.push(new ContextMenuElement(_('Delete Table'), this.delTable, this));
            return ret;
        };
    };

    this.addPlainTable = function() {
        /* event handler for the context menu */
        this.createTable(2, 3, 1, 'plain');
    };

    this.createTable = function(rows, cols, makeHeader, tableclass) {
        /* add a table */
        if (rows < 1 || rows > 99 || cols < 1 || cols > 99) {
            this.editor.logMessage(_('Invalid table size'), 1);
            return;
        };

        var doc = this.editor.getInnerDocument();

        table = doc.createElement("table");
        table.className = tableclass;

        // TODO: La asociacin de una plantilla debe obtenerse de un fichero de
        // configuracin.
        table.setAttribute("uid","tabla");

        // If the user wants a row of headings, make them
        if (makeHeader) {
            var tr = doc.createElement("tr");
            var thead = doc.createElement("thead");
            for (i=0; i < cols; i++) {
                var th = doc.createElement("th");
                th.appendChild(doc.createTextNode("Col " + i+1));
                tr.appendChild(th);
            }
            thead.appendChild(tr);
            table.appendChild(thead);
        }

        tbody = doc.createElement("tbody");
        for (var i=0; i < rows; i++) {
            var tr = doc.createElement("tr");
            for (var j=0; j < cols; j++) {
                var td = doc.createElement("td");
                var content = doc.createTextNode('\u00a0');
                td.appendChild(content);
                tr.appendChild(td);
            }
            tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        this.editor.insertNodeAtSelection(table);

        this._setTableCellHandlers(table);

        this.editor.logMessage(_('Table added'));
        this.editor.updateState();
        return table;
    };

    this._setTableCellHandlers = function(table) {
        // make each cell select its full contents if it's clicked
        addEventHandler(table, 'click', this._selectContentIfEmpty, this);

        var cells = table.getElementsByTagName('td');
        for (var i=0; i < cells.length; i++) {
            addEventHandler(cells[i], 'click', this._selectContentIfEmpty, this);
        };

        // select the nbsp in the first cell
        var firstcell = cells[0];
        if (firstcell) {
            var children = firstcell.childNodes;
            if (children.length == 1 && children[0].nodeType == 3 &&
                    children[0].nodeValue == '\xa0') {
                var selection = this.editor.getSelection();
                selection.selectNodeContents(firstcell);
            };
        };
    };

    this._selectContentIfEmpty = function() {
        var selNode = this.editor.getSelectedNode();
        var cell = this.editor.getNearestParentOfType(selNode, 'td');
        if (!cell) {
            return;
        };
        var children = cell.childNodes;
        if (children.length == 1 && children[0].nodeType == 3 &&
                children[0].nodeValue == '\xa0') {
            var selection = this.editor.getSelection();
            selection.selectNodeContents(cell);
        };
    };

    this.addTableRow = function() {
        /* Find the current row and add a row after it */
        var currnode = this.editor.getSelectedNode();
        var currtbody = this.editor.getNearestParentOfType(currnode, "TBODY");
        var bodytype = "tbody";
        if (!currtbody) {
            currtbody = this.editor.getNearestParentOfType(currnode, "THEAD");
            bodytype = "thead";
        }
        var parentrow = this.editor.getNearestParentOfType(currnode, "TR");
        var nextrow = parentrow.nextSibling;

        // get the number of cells we should place
        var colcount = 0;
        for (var i=0; i < currtbody.childNodes.length; i++) {
            var el = currtbody.childNodes[i];
            if (el.nodeType != 1) {
                continue;
            }
            if (el.nodeName.toLowerCase() == 'tr') {
                var cols = 0;
                for (var j=0; j < el.childNodes.length; j++) {
                    if (el.childNodes[j].nodeType == 1) {
                        cols++;
                    }
                }
                if (cols > colcount) {
                    colcount = cols;
                }
            }
        }

        var newrow = this.editor.getInnerDocument().createElement("TR");

        for (var i = 0; i < colcount; i++) {
            var newcell;
            if (bodytype == 'tbody') {
                newcell = this.editor.getInnerDocument().createElement("TD");
            } else {
                newcell = this.editor.getInnerDocument().createElement("TH");
            }
            var newcellvalue = this.editor.getInnerDocument().createTextNode("\u00a0");
            newcell.appendChild(newcellvalue);
            newrow.appendChild(newcell);
        }

        if (!nextrow) {
            currtbody.appendChild(newrow);
        } else {
            currtbody.insertBefore(newrow, nextrow);
        }

        this.editor.focusDocument();
        this.editor.logMessage(_('Table row added'));
    };

    this.delTableRow = function() {
        /* Find the current row and delete it */
        var currnode = this.editor.getSelectedNode();
        var parentrow = this.editor.getNearestParentOfType(currnode, "TR");
        if (!parentrow) {
            this.editor.logMessage(_('No row to delete'), 1);
            return;
        }

        // move selection aside
        // XXX: doesn't work if parentrow is the only row of thead/tbody/tfoot
        // XXX: doesn't preserve the colindex
        var selection = this.editor.getSelection();
        if (parentrow.nextSibling) {
            selection.selectNodeContents(parentrow.nextSibling.firstChild);
        } else if (parentrow.previousSibling) {
            selection.selectNodeContents(parentrow.previousSibling.firstChild);
        };

        // remove the row
        parentrow.parentNode.removeChild(parentrow);

        this.editor.focusDocument();
        this.editor.logMessage(_('Table row removed'));
    };

    this.addTableColumn = function() {
        /* Add a new column after the current column */
        var currnode = this.editor.getSelectedNode();
        var currtd = this.editor.getNearestParentOfType(currnode, 'TD');
        if (!currtd) {
            currtd = this.editor.getNearestParentOfType(currnode, 'TH');
        }
        if (!currtd) {
            this.editor.logMessage(_('No parentcolumn found!'), 1);
            return;
        }
        var currtr = this.editor.getNearestParentOfType(currnode, 'TR');
        var currtable = this.editor.getNearestParentOfType(currnode, 'TABLE');

        // get the current index
        var tdindex = this._getColIndex(currtd);
        // XXX this looks like a debug message, remove
        this.editor.logMessage(_('tdindex: ${tdindex}'));

        // now add a column to all rows
        // first the thead
        var theads = currtable.getElementsByTagName('THEAD');
        if (theads) {
            for (var i=0; i < theads.length; i++) {
                // let's assume table heads only have ths
                var currthead = theads[i];
                for (var j=0; j < currthead.childNodes.length; j++) {
                    var tr = currthead.childNodes[j];
                    if (tr.nodeType != 1) {
                        continue;
                    }
                    var currindex = 0;
                    for (var k=0; k < tr.childNodes.length; k++) {
                        var th = tr.childNodes[k];
                        if (th.nodeType != 1) {
                            continue;
                        }
                        if (currindex == tdindex) {
                            var doc = this.editor.getInnerDocument();
                            var newth = doc.createElement('th');
                            var text = doc.createTextNode('\u00a0');
                            newth.appendChild(text);
                            if (tr.childNodes.length == k+1) {
                                // the column will be on the end of the row
                                tr.appendChild(newth);
                            } else {
                                tr.insertBefore(newth, tr.childNodes[k + 1]);
                            }
                            break;
                        }
                        currindex++;
                    }
                }
            }
        }

        // then the tbody
        var tbodies = currtable.getElementsByTagName('TBODY');
        if (tbodies) {
            for (var i=0; i < tbodies.length; i++) {
                // let's assume table heads only have ths
                var currtbody = tbodies[i];
                for (var j=0; j < currtbody.childNodes.length; j++) {
                    var tr = currtbody.childNodes[j];
                    if (tr.nodeType != 1) {
                        continue;
                    }
                    var currindex = 0;
                    for (var k=0; k < tr.childNodes.length; k++) {
                        var td = tr.childNodes[k];
                        if (td.nodeType != 1) {
                            continue;
                        }
                        if (currindex == tdindex) {
                            var doc = this.editor.getInnerDocument();
                            var newtd = doc.createElement('td');
                            var text = doc.createTextNode('\u00a0');
                            newtd.appendChild(text);
                            if (tr.childNodes.length == k+1) {
                                // the column will be on the end of the row
                                tr.appendChild(newtd);
                            } else {
                                tr.insertBefore(newtd, tr.childNodes[k + 1]);
                            }
                            break;
                        }
                        currindex++;
                    }
                }
            }
        }
        this.editor.focusDocument();
        this.editor.logMessage(_('Table column added'));
    };

    this.delTableColumn = function() {
        /* remove a column */
        var currnode = this.editor.getSelectedNode();
        var currtd = this.editor.getNearestParentOfType(currnode, 'TD');
        if (!currtd) {
            currtd = this.editor.getNearestParentOfType(currnode, 'TH');
        }
        var currcolindex = this._getColIndex(currtd);
        var currtable = this.editor.getNearestParentOfType(currnode, 'TABLE');

        // move selection aside
        var selection = this.editor.getSelection();
        if (currtd.nextSibling) {
            selection.selectNodeContents(currtd.nextSibling);
        } else if (currtd.previousSibling) {
            selection.selectNodeContents(currtd.previousSibling);
        };

        // remove the theaders
        var heads = currtable.getElementsByTagName('THEAD');
        if (heads.length) {
            for (var i=0; i < heads.length; i++) {
                var thead = heads[i];
                for (var j=0; j < thead.childNodes.length; j++) {
                    var tr = thead.childNodes[j];
                    if (tr.nodeType != 1) {
                        continue;
                    }
                    var currindex = 0;
                    for (var k=0; k < tr.childNodes.length; k++) {
                        var th = tr.childNodes[k];
                        if (th.nodeType != 1) {
                            continue;
                        }
                        if (currindex == currcolindex) {
                            tr.removeChild(th);
                            break;
                        }
                        currindex++;
                    }
                }
            }
        }

        // now we remove the column field, a bit harder since we need to take
        // colspan and rowspan into account XXX Not right, fix theads as well
        var bodies = currtable.getElementsByTagName('TBODY');
        for (var i=0; i < bodies.length; i++) {
            var currtbody = bodies[i];
            var relevant_rowspan = 0;
            for (var j=0; j < currtbody.childNodes.length; j++) {
                var tr = currtbody.childNodes[j];
                if (tr.nodeType != 1) {
                    continue;
                }
                var currindex = 0
                for (var k=0; k < tr.childNodes.length; k++) {
                    var cell = tr.childNodes[k];
                    if (cell.nodeType != 1) {
                        continue;
                    }
                    var colspan = cell.colSpan;
                    if (currindex == currcolindex) {
                        tr.removeChild(cell);
                        break;
                    }
                    currindex++;
                }
            }
        }
        this.editor.focusDocument();
        this.editor.logMessage(_('Table column deleted'));
    };

    this.delTable = function() {
        /* delete the current table */
        var currnode = this.editor.getSelectedNode();
        var table = this.editor.getNearestParentOfType(currnode, 'table');
        if (!table) {
            this.editor.logMessage(_('Not inside a table!'));
            return;
        };
        table.parentNode.removeChild(table);
        this.editor.logMessage(_('Table removed'));
    };

    this.setColumnAlign = function(newalign) {
        /* change the alignment of a full column */
        var currnode = this.editor.getSelectedNode();
        var currtd = this.editor.getNearestParentOfType(currnode, "TD");
        var bodytype = 'tbody';
        if (!currtd) {
            currtd = this.editor.getNearestParentOfType(currnode, "TH");
            bodytype = 'thead';
        }
        var currcolindex = this._getColIndex(currtd);
        var currtable = this.editor.getNearestParentOfType(currnode, "TABLE");

        // unfortunately this is not enough to make the browsers display
        // the align, we need to set it on individual cells as well and
        // mind the rowspan...
        for (var i=0; i < currtable.childNodes.length; i++) {
            var currtbody = currtable.childNodes[i];
            if (currtbody.nodeType != 1 ||
                    (currtbody.nodeName.toUpperCase() != "THEAD" &&
                        currtbody.nodeName.toUpperCase() != "TBODY")) {
                continue;
            }
            for (var j=0; j < currtbody.childNodes.length; j++) {
                var row = currtbody.childNodes[j];
                if (row.nodeType != 1) {
                    continue;
                }
                var index = 0;
                for (var k=0; k < row.childNodes.length; k++) {
                    var cell = row.childNodes[k];
                    if (cell.nodeType != 1) {
                        continue;
                    }
                    if (index == currcolindex) {
                        if (this.editor.config.use_css) {
                            cell.style.textAlign = newalign;
                        } else {
                            cell.setAttribute('align', newalign);
                        }
                        cell.className = 'align-' + newalign;
                    }
                    index++;
                }
            }
        }
    };

    this.setTableClass = function(sel_class) {
        /* set the class for the table */
        var currnode = this.editor.getSelectedNode();
        var currtable = this.editor.getNearestParentOfType(currnode, 'TABLE');

        if (currtable) {
            currtable.className = sel_class;
        }
    };

    this._getColIndex = function(currcell) {
        /* Given a node, return an integer for which column it is */
        var prevsib = currcell.previousSibling;
        var currcolindex = 0;
        while (prevsib) {
            if (prevsib.nodeType == 1 &&
                    (prevsib.tagName.toUpperCase() == "TD" ||
                        prevsib.tagName.toUpperCase() == "TH")) {
                var colspan = prevsib.colSpan;
                if (colspan) {
                    currcolindex += parseInt(colspan);
                } else {
                    currcolindex++;
                }
            }
            prevsib = prevsib.previousSibling;
            if (currcolindex > 30) {
                alert(_("Recursion detected when counting column position"));
                return;
            }
        }

        return currcolindex;
    };

    this._getColumnAlign = function(selNode) {
        /* return the alignment setting of the current column */
        var align;
        var td = this.editor.getNearestParentOfType(selNode, 'td');
        if (!td) {
            td = this.editor.getNearestParentOfType(selNode, 'th');
        };
        if (td) {
            align = td.getAttribute('align');
            if (this.editor.config.use_css) {
                align = td.style.textAlign;
            };
        };
        return align;
    };

    this.fixTable = function(event) {
        /* fix the table so it can be processed by Kupu */
        // since this can be quite a nasty creature we can't just use the
        // helper methods

        // first we create a new tbody element
        var currnode = this.editor.getSelectedNode();
        var table = this.editor.getNearestParentOfType(currnode, 'TABLE');
        if (!table) {
            this.editor.logMessage(_('Not inside a table!'));
            return;
        };
        this._fixTableHelper(table);
    };

    this._isBodyRow = function(row) {
        for (var node = row.firstChild; node; node=node.nextSibling) {
            if (/TD/.test(node.nodeName)) {
                return true;
            }
        }
        return false;
    }

    this._cleanCell = function(el) {
        dump('_cleanCell('+el.innerHTML+')\n');
        // Remove formatted div or p from a cell
        var node, nxt, n;
        for (node = el.firstChild; node;) {
            if (/DIV|P/.test(node.nodeName)) {
                for (var n = node.firstChild; n;) {
                    var nxt = n.nextSibling;
                    el.insertBefore(n, node); // Move nodes out of div
                    n = nxt;
                }
                nxt = node.nextSibling;
                el.removeChild(node);
                node = nxt;
            } else {
                node = node.nextSibling;
            }
        }
        var c;
        while (el.firstChild && (c = el.firstChild).nodeType==3 && /^\s+/.test(c.data)) {
            c.data = c.data.replace(/^\s+/, '');
            if (!c.data) {
                el.removeChild(c);
            } else {
                break;
            };
        };
        while (el.lastChild && (c = el.lastChild).nodeType==3 && /\s+$/.test(c.data)) {
            c.data = c.data.replace(/\s+$/, '');
            if (!c.data) {
                el.removeChild(c);
            } else {
                break;
            };
        };
        el.removeAttribute('colSpan');
        el.removeAttribute('rowSpan');
    }
    this._countCols = function(rows, numcols) {
        for (var i=0; i < rows.length; i++) {
            var row = rows[i];
            var currnumcols = 0;
            for (var node = row.firstChild; node; node=node.nextSibling) {
                if (/td|th/i.test(node.nodeName)) {
                    currnumcols += parseInt(node.getAttribute('colSpan') || '1');
                };
            };
            if (currnumcols > numcols) {
                numcols = currnumcols;
            };
        };
        return numcols;
    }

    this._cleanRows = function(rows, container, numcols) {
        // now walk through all rows to clean them up
        for (var i=0; i < rows.length; i++) {
            dump("row "+i+'\n');
            var row = rows[i];
            var doc = this.editor.getInnerDocument();
            var newrow = doc.createElement('tr');
            if (row.className) {
                newrow.className = row.className;
            }
            for (var node = row.firstChild; node;) {
                dump("child\n");
                var nxt = node.nextSibling;
                if (/TD|TH/.test(node.nodeName)) {
                    this._cleanCell(node);
                    newrow.appendChild(node);
                };
                node = nxt;
            };
            if (newrow.childNodes.length) {
                container.appendChild(newrow);
            };
        };
        // now make sure all rows have the correct length
        for (row = container.firstChild; row; row=row.nextSibling) {
            var cellname = row.lastChild.nodeName;
            while (row.childNodes.length < numcols) {
                var cell = doc.createElement(cellname);
                var nbsp = doc.createTextNode('\u00a0');
                cell.appendChild(nbsp);
                row.appendChild(cell);
            };
        };
    };

    this._fixTableHelper = function(table) {
        /* the code to actually fix tables */
        var doc = this.editor.getInnerDocument();
        var thead = doc.createElement('thead');
        var tbody = doc.createElement('tbody');
        var tfoot = doc.createElement('tfoot');

        var table_classes = this.editor.config.table_classes;
        function cleanClassName(name) {
            var allowed_classes = table_classes['class'];
            for (var i = 0; i < allowed_classes.length; i++) {
                var classname = allowed_classes[i];
                classname = classname.classname || classname;
                if (classname==name) return name;
            };
            return allowed_classes[0];
        }
        if (table_classes) {
            table.className = cleanClassName(table.className);
        } else {
            table.removeAttribute('class');
            table.removeAttribute('className');
        };
        table.removeAttribute('border');
        table.removeAttribute('cellpadding');
        table.removeAttribute('cellPadding');
        table.removeAttribute('cellspacing');
        table.removeAttribute('cellSpacing');

        // now get all the rows of the table, the rows can either be
        // direct descendants of the table or inside a 'tbody', 'thead'
        // or 'tfoot' element

        var hrows = [], brows = [], frows = [];
        for (var node = table.firstChild; node; node = node.nextSibling) {
            var nodeName = node.nodeName;
            if (/TR/.test(node.nodeName)) {
                brows.push(node);
            } else if (/THEAD|TBODY|TFOOT/.test(node.nodeName)) {
                var rows = nodeName=='THEAD' ? hrows : nodeName=='TFOOT' ? frows : brows;
                for (var inode = node.firstChild; inode; inode = inode.nextSibling) {
                    if (/TR/.test(inode.nodeName)) {
                        rows.push(inode);
                    };
                };
            };
        };
        /* Extract thead and tfoot from tbody */
        dump('extract head and foot\n');
        while (brows.length && !this._isBodyRow(brows[0])) {
            hrows.push(brows[0]);
            brows.shift();
        }
        while (brows.length && !this._isBodyRow(brows[brows.length-1])) {
            var last = brows[brows.length-1];
            brows.length -= 1;
            frows.unshift(last);
        }
        dump('count cols\n');
        // now find out how many cells our rows should have
        var numcols = this._countCols(hrows, 0);
        numcols = this._countCols(brows, numcols);
        numcols = this._countCols(frows, numcols);

        dump('clean rows\n');
        // now walk through all rows to clean them up
        this._cleanRows(hrows, thead);
        this._cleanRows(brows, tbody);
        this._cleanRows(frows, tfoot);

        // now remove all the old stuff from the table and add the new
        // tbody
        dump('remove old\n');
        while (table.firstChild) {
            table.removeChild(table.firstChild);
        }
        if (hrows.length)
            table.appendChild(thead);
        if (brows.length)
            table.appendChild(tbody);
        if (frows.length)
            table.appendChild(tfoot);
        dump('finish up\n');

        this.editor.focusDocument();
        this.editor.logMessage(_('Table cleaned up'));
    };

    this.fixAllTables = function() {
        /* fix all the tables in the document at once */
        var tables = this.editor.getInnerDocument().getElementsByTagName('table');
        for (var i=0; i < tables.length; i++) {
            this._fixTableHelper(tables[i]);
        };
    };
};

TableTool.prototype = new KupuTool;

function TableToolBox(addtabledivid, edittabledivid, newrowsinputid,
                    newcolsinputid, makeheaderinputid, classselectid, alignselectid, addtablebuttonid,
                    addrowbuttonid, delrowbuttonid, addcolbuttonid, delcolbuttonid, fixbuttonid,
                    fixallbuttonid, toolboxid, plainclass, activeclass) {
    /* The table tool */

    // XXX There are some awfully long methods in here!!


    // a lot of dependencies on html elements here, but most implementations
    // will use them all I guess
    this.addtablediv = getFromSelector(addtabledivid);
    this.edittablediv = getFromSelector(edittabledivid);
    this.newrowsinput = getFromSelector(newrowsinputid);
    this.newcolsinput = getFromSelector(newcolsinputid);
    this.makeheaderinput = getFromSelector(makeheaderinputid);
    this.classselect = getFromSelector(classselectid);
    this.alignselect = getFromSelector(alignselectid);
    this.addtablebutton = getFromSelector(addtablebuttonid);
    this.addrowbutton = getFromSelector(addrowbuttonid);
    this.delrowbutton = getFromSelector(delrowbuttonid);
    this.addcolbutton = getFromSelector(addcolbuttonid);
    this.delcolbutton = getFromSelector(delcolbuttonid);
    this.fixbutton = getFromSelector(fixbuttonid);
    this.fixallbutton = getFromSelector(fixallbuttonid);
    this.toolboxel = getFromSelector(toolboxid);
    this.plainclass = plainclass;
    this.activeclass = activeclass;

    // register event handlers
    this.initialize = function(tool, editor) {
        /* attach the event handlers */
        this.tool = tool;
        this.editor = editor;
        // build the select list of table classes if configured
        if (this.editor.config.table_classes) {
            var classes = this.editor.config.table_classes['class'];
            while (this.classselect.hasChildNodes()) {
                this.classselect.removeChild(this.classselect.firstChild);
            };
            for (var i=0; i < classes.length; i++) {
                var classname = classes[i];
                classname = classname.classname || classname;
                var option = document.createElement('option');
                var content = document.createTextNode(classname);
                option.appendChild(content);
                option.setAttribute('value', classname);
                this.classselect.appendChild(option);
            };
        };
        addEventHandler(this.addtablebutton, "click", this.addTable, this);
        addEventHandler(this.addrowbutton, "click", this.tool.addTableRow, this.tool);
        addEventHandler(this.delrowbutton, "click", this.tool.delTableRow, this.tool);
        addEventHandler(this.addcolbutton, "click", this.tool.addTableColumn, this.tool);
        addEventHandler(this.delcolbutton, "click", this.tool.delTableColumn, this.tool);
        addEventHandler(this.alignselect, "change", this.setColumnAlign, this);
        addEventHandler(this.classselect, "change", this.setTableClass, this);
        addEventHandler(this.fixbutton, "click", this.tool.fixTable, this.tool);
        addEventHandler(this.fixallbutton, "click", this.tool.fixAllTables, this.tool);
        this.addtablediv.style.display = "block";
        this.edittablediv.style.display = "none";
        this.editor.logMessage(_('Table tool initialized'));
    };

    this.updateState = function(selNode) {
        /* update the state (add/edit) and update the pulldowns (if required) */
        var table = this.editor.getNearestParentOfType(selNode, 'table');
        if (table) {
            this.addtablediv.style.display = "none";
            this.edittablediv.style.display = "block";

            var align = this.tool._getColumnAlign(selNode);
            selectSelectItem(this.alignselect, align);
            selectSelectItem(this.classselect, table.className);
            if (this.toolboxel) {
                this.toolboxel.className = this.activeclass;
            };
        } else {
            this.edittablediv.style.display = "none";
            this.addtablediv.style.display = "block";
            this.alignselect.selectedIndex = 0;
            this.classselect.selectedIndex = 0;
            if (this.toolboxel) {
                this.toolboxel.className = this.plainclass;
            };
        };
    };

    this.addTable = function() {
        /* add a table */
        var rows = this.newrowsinput.value;
        var cols = this.newcolsinput.value;
        var makeHeader = this.makeheaderinput.checked;
        // XXX getFromSelector
        var classchooser = getFromSelector("kupu-table-classchooser-add");
        var tableclass = this.classselect.options[this.classselect.selectedIndex].value;

        this.tool.createTable(rows, cols, makeHeader, tableclass);
    };

    this.setColumnAlign = function() {
        /* set the alignment of the current column */
        var newalign = this.alignselect.options[this.alignselect.selectedIndex].value;
        this.tool.setColumnAlign(newalign);
    };

    this.setTableClass = function() {
        /* set the class for the current table */
        var sel_class = this.classselect.options[this.classselect.selectedIndex].value;
        if (sel_class) {
            this.tool.setTableClass(sel_class);
        };
    };
};

TableToolBox.prototype = new KupuToolBox;

function ListTool(addulbuttonid, addolbuttonid, ulstyleselectid, olstyleselectid) {
    /* tool to set list styles */

    this.addulbutton = getFromSelector(addulbuttonid);
    this.addolbutton = getFromSelector(addolbuttonid);
    this.ulselect = getFromSelector(ulstyleselectid);
    this.olselect = getFromSelector(olstyleselectid);

    this.style_to_type = {'decimal': '1',
                            'lower-alpha': 'a',
                            'upper-alpha': 'A',
                            'lower-roman': 'i',
                            'upper-roman': 'I',
                            'disc': 'disc',
                            'square': 'square',
                            'circle': 'circle',
                            'none': 'none'
                            };
    this.type_to_style = {'1': 'decimal',
                            'a': 'lower-alpha',
                            'A': 'upper-alpha',
                            'i': 'lower-roman',
                            'I': 'upper-roman',
                            'disc': 'disc',
                            'square': 'square',
                            'circle': 'circle',
                            'none': 'none'
                            };

    this.initialize = function(editor) {
        /* attach event handlers */
        this.editor = editor;
        this._fixTabIndex(this.addulbutton);
        this._fixTabIndex(this.addolbutton);
        this._fixTabIndex(this.ulselect);
        this._fixTabIndex(this.olselect);

        addEventHandler(this.addulbutton, "click", this.addUnorderedList, this);
        addEventHandler(this.addolbutton, "click", this.addOrderedList, this);
        addEventHandler(this.ulselect, "change", this.setUnorderedListStyle, this);
        addEventHandler(this.olselect, "change", this.setOrderedListStyle, this);
        this.ulselect.style.display = "none";
        this.olselect.style.display = "none";

        this.editor.logMessage(_('List style tool initialized'));
    };

    this._handleStyles = function(currnode, onselect, offselect) {
        if (this.editor.config.use_css) {
            var currstyle = currnode.style.listStyleType;
        } else {
            var currstyle = this.type_to_style[currnode.getAttribute('type')];
        }
        selectSelectItem(onselect, currstyle);
        offselect.style.display = "none";
        onselect.style.display = "inline";
        offselect.selectedIndex = 0;
    };

    this.updateState = function(selNode) {
        /* update the visibility and selection of the list type pulldowns */
        // we're going to walk through the tree manually since we want to
        // check on 2 items at the same time
        for (var currnode=selNode; currnode; currnode=currnode.parentNode) {
            var tag = currnode.nodeName.toLowerCase();
            if (tag == 'ul') {
                this._handleStyles(currnode, this.ulselect, this.olselect);
                return;
            } else if (tag == 'ol') {
                this._handleStyles(currnode, this.olselect, this.ulselect);
                return;
            }
        }
        with(this.ulselect) {
            selectedIndex = 0;
            style.display = "none";
        };
        with(this.olselect) {
            selectedIndex = 0;
            style.display = "none";
        };
    };

    this.addList = function(command) {
        this.ulselect.style.display = "inline";
        this.olselect.style.display = "none";
        this.editor.execCommand(command);
        this.editor.focusDocument();
    };
    this.addUnorderedList = function() {
        /* add an unordered list */
        this.addList("insertunorderedlist");
    };

    this.addOrderedList = function() {
        /* add an ordered list */
        this.addList("insertorderedlist");
    };

    this.setListStyle = function(tag, select) {
        /* set the type of an ul */
        var currnode = this.editor.getSelectedNode();
        var l = this.editor.getNearestParentOfType(currnode, tag);
        var style = select.options[select.selectedIndex].value;
        if (this.editor.config.use_css) {
            l.style.listStyleType = style;
        } else {
            l.setAttribute('type', this.style_to_type[style]);
        }
        this.editor.focusDocument();
        this.editor.logMessage(_('List style changed'));
    };

    this.setUnorderedListStyle = function() {
        /* set the type of an ul */
        this.setListStyle('ul', this.ulselect);
    };

    this.setOrderedListStyle = function() {
        /* set the type of an ol */
        this.setListStyle('ol', this.olselect);
    };

    this.enable = function() {
        KupuButtonEnable(this.addulbutton);
        KupuButtonEnable(this.addolbutton);
        this.ulselect.disabled = "";
        this.olselect.disabled = "";
    }
    this.disable = function() {
        KupuButtonDisable(this.addulbutton);
        KupuButtonDisable(this.addolbutton);
        this.ulselect.disabled = "disabled";
        this.olselect.disabled = "disabled";
    }
};

ListTool.prototype = new KupuTool;

function ShowPathTool() {
    /* shows the path to the current element in the status bar */

    this.updateState = function(selNode) {
        /* calculate and display the path */
        var path = '';
        var url = null; // for links we want to display the url too
        var currnode = selNode;

        while (currnode && currnode.nodeName != '#document') {
            if (currnode.nodeName.toLowerCase() == 'a') {
                url = currnode.getAttribute('href');
            };
            path = '/' + currnode.nodeName.toLowerCase() + path;
            currnode = currnode.parentNode;
        }

        try {
            window.status = url ?
                    (path.toString() + ' - contains link to \'' +
                        url.toString() + '\'') :
                    path;
        } catch (e) {
            this.editor.logMessage(_('Could not set status bar message, ' +
                                    'check your browser\'s security settings.'
                                    ), 1);
        };
    };
};

ShowPathTool.prototype = new KupuTool;

function ViewSourceTool() {
    /* tool to provide a 'show source' context menu option */
    this.sourceWindow = null;

    this.viewSource = function() {
        /* open a window and write the current contents of the iframe to it */
        if (this.sourceWindow) {
            this.sourceWindow.close();
        };
        this.sourceWindow = window.open('#', 'sourceWindow');

        //var transform = this.editor._filterContent(this.editor.getInnerDocument().documentElement);
        //var contents = transform.xml;
        var contents = '<html>\n' + this.editor.getInnerDocument().documentElement.innerHTML + '\n</html>';

        var doc = this.sourceWindow.document;
        doc.write('\xa0');
        doc.close();
        var body = doc.getElementsByTagName("body")[0];
        while (body.hasChildNodes()) {
            body.removeChild(body.firstChild);
        };
        var pre = doc.createElement('pre');
        var textNode = doc.createTextNode(contents);
        body.appendChild(pre);
        pre.appendChild(textNode);
    };

    this.createContextMenuElements = function(selNode, event) {
        /* create the context menu element */
        return new Array(new ContextMenuElement(_('View source'), this.viewSource, this));
    };
};

ViewSourceTool.prototype = new KupuTool;

function DefinitionListTool(dlbuttonid) {
    /* a tool for managing definition lists

        the dl elements should behave much like plain lists, and the keypress
        behaviour should be similar
    */

    this.dlbutton = getFromSelector(dlbuttonid);

    this.initialize = function(editor) {
        /* initialize the tool */
        this.editor = editor;
        this._fixTabIndex(this.dlbutton);
        addEventHandler(this.dlbutton, 'click', this.createDefinitionList, this);
        addEventHandler(editor.getInnerDocument(), 'keyup', this._keyDownHandler, this);
        addEventHandler(editor.getInnerDocument(), 'keypress', this._keyPressHandler, this);
    };

    // even though the following methods may seem view related, they belong
    // here, since they describe core functionality rather then view-specific
    // stuff
    this.handleEnterPress = function(selNode) {
        var dl = this.editor.getNearestParentOfType(selNode, 'dl');
        if (dl) {
            var dt = this.editor.getNearestParentOfType(selNode, 'dt');
            if (dt) {
                if (dt.childNodes.length == 1 && dt.childNodes[0].nodeValue == '\xa0') {
                    this.escapeFromDefinitionList(dl, dt, selNode);
                    return;
                };

                var selection = this.editor.getSelection();
                var startoffset = selection.startOffset();
                var endoffset = selection.endOffset();
                if (endoffset > startoffset) {
                    // throw away any selected stuff
                    selection.cutChunk(startoffset, endoffset);
                    selection = this.editor.getSelection();
                    startoffset = selection.startOffset();
                };

                var ellength = selection.getElementLength(selection.parentElement());
                if (startoffset >= ellength - 1) {
                    // create a new element
                    this.createDefinition(dl, dt);
                } else {
                    var doc = this.editor.getInnerDocument();
                    var newdt = selection.splitNodeAtSelection(dt);
                    var newdd = doc.createElement('dd');
                    while (newdt.hasChildNodes()) {
                        if (newdt.firstChild != newdt.lastChild || newdt.firstChild.nodeName.toLowerCase() != 'br') {
                            newdd.appendChild(newdt.firstChild);
                        };
                    };
                    newdt.parentNode.replaceChild(newdd, newdt);
                    selection.selectNodeContents(newdd);
                    selection.collapse();
                };
            } else {
                var dd = this.editor.getNearestParentOfType(selNode, 'dd');
                if (!dd) {
                    this.editor.logMessage(_('Not inside a definition list element!'));
                    return;
                };
                if (dd.childNodes.length == 1 && dd.childNodes[0].nodeValue == '\xa0') {
                    this.escapeFromDefinitionList(dl, dd, selNode);
                    return;
                };
                var selection = this.editor.getSelection();
                var startoffset = selection.startOffset();
                var endoffset = selection.endOffset();
                if (endoffset > startoffset) {
                    // throw away any selected stuff
                    selection.cutChunk(startoffset, endoffset);
                    selection = this.editor.getSelection();
                    startoffset = selection.startOffset();
                };
                var ellength = selection.getElementLength(selection.parentElement());
                if (startoffset >= ellength - 1) {
                    // create a new element
                    this.createDefinitionTerm(dl, dd);
                } else {
                    // add a break and continue in this element
                    var br = this.editor.getInnerDocument().createElement('br');
                    this.editor.insertNodeAtSelection(br, 1);
                    //var selection = this.editor.getSelection();
                    //selection.moveStart(1);
                    selection.collapse(true);
                };
            };
        };
    };

    this.handleTabPress = function(selNode) {
    };

    this._keyDownHandler = function(event) {
        var selNode = this.editor.getSelectedNode();
        var dl = this.editor.getNearestParentOfType(selNode, 'dl');
        if (!dl) {
            return;
        };
        switch (event.keyCode) {
            case 13:
                if (event.preventDefault) {
                    event.preventDefault();
                } else {
                    event.returnValue = false;
                };
                break;
        };
    };

    this._keyPressHandler = function(event) {
        var selNode = this.editor.getSelectedNode();
        var dl = this.editor.getNearestParentOfType(selNode, 'dl');
        if (!dl) {
            return;
        };
        switch (event.keyCode) {
            case 13:
                this.handleEnterPress(selNode);
                if (event.preventDefault) {
                    event.preventDefault();
                } else {
                    event.returnValue = false;
                };
                break;
            case 9:
                if (event.preventDefault) {
                    event.preventDefault();
                } else {
                    event.returnValue = false;
                };
                this.handleTabPress(selNode);
        };
    };

    this.createDefinitionList = function() {
        /* create a new definition list (dl) */
        var selection = this.editor.getSelection();
        var doc = this.editor.getInnerDocument();

        var selection = this.editor.getSelection();
        var cloned = selection.cloneContents();
        // first get the 'first line' (until the first break) and use it
        // as the dt's content
        var iterator = new NodeIterator(cloned);
        var currnode = null;
        var remove = false;
        while (currnode = iterator.next()) {
            if (currnode.nodeName.toLowerCase() == 'br') {
                remove = true;
            };
            if (remove) {
                var next = currnode;
                while (!next.nextSibling) {
                    next = next.parentNode;
                };
                next = next.nextSibling;
                iterator.setCurrent(next);
                currnode.parentNode.removeChild(currnode);
            };
        };

        var dtcontentcontainer = cloned;
        var collapsetoend = false;

        var dl = doc.createElement('dl');
        this.editor.insertNodeAtSelection(dl);
        var dt = this.createDefinitionTerm(dl);
        if (dtcontentcontainer.hasChildNodes()) {
            collapsetoend = true;
            while (dt.hasChildNodes()) {
                dt.removeChild(dt.firstChild);
            };
            while (dtcontentcontainer.hasChildNodes()) {
                dt.appendChild(dtcontentcontainer.firstChild);
            };
        };

        var selection = this.editor.getSelection();
        selection.selectNodeContents(dt);
        selection.collapse(collapsetoend);
    };

    this.createDefinitionTerm = function(dl, dd) {
        /* create a new definition term inside the current dl */
        var doc = this.editor.getInnerDocument();
        var dt = doc.createElement('dt');
        // somehow Mozilla seems to add breaks to all elements...
        if (dd) {
            if (dd.lastChild.nodeName.toLowerCase() == 'br') {
                dd.removeChild(dd.lastChild);
            };
        };
        // dd may be null here, if so we assume this is the first element in
        // the dl
        if (!dd || dl == dd.lastChild) {
            dl.appendChild(dt);
        } else {
            var nextsibling = dd.nextSibling;
            if (nextsibling) {
                dl.insertBefore(dt, nextsibling);
            } else {
                dl.appendChild(dt);
            };
        };
        var nbsp = doc.createTextNode('\xa0');
        dt.appendChild(nbsp);
        var selection = this.editor.getSelection();
        selection.selectNodeContents(dt);
        selection.collapse();

        this.editor.focusDocument();
        return dt;
    };

    this.createDefinition = function(dl, dt, initial_content) {
        var doc = this.editor.getInnerDocument();
        var dd = doc.createElement('dd');
        var nextsibling = dt.nextSibling;
        // somehow Mozilla seems to add breaks to all elements...
        if (dt) {
            if (dt.lastChild.nodeName.toLowerCase() == 'br') {
                dt.removeChild(dt.lastChild);
            };
        };
        while (nextsibling) {
            var name = nextsibling.nodeName.toLowerCase();
            if (name == 'dd' || name == 'dt') {
                break;
            } else {
                nextsibling = nextsibling.nextSibling;
            };
        };
        if (nextsibling) {
            dl.insertBefore(dd, nextsibling);
            //this._fixStructure(doc, dl, nextsibling);
        } else {
            dl.appendChild(dd);
        };
        if (initial_content) {
            for (var i=0; i < initial_content.length; i++) {
                dd.appendChild(initial_content[i]);
            };
        };
        var nbsp = doc.createTextNode('\xa0');
        dd.appendChild(nbsp);
        var selection = this.editor.getSelection();
        selection.selectNodeContents(dd);
        selection.collapse();
    };

    this.escapeFromDefinitionList = function(dl, currel, selNode) {
        var doc = this.editor.getInnerDocument();
        var p = doc.createElement('p');
        var nbsp = doc.createTextNode('\xa0');
        p.appendChild(nbsp);

        if (dl.lastChild == currel) {
            dl.parentNode.insertBefore(p, dl.nextSibling);
        } else {
            for (var i=0; i < dl.childNodes.length; i++) {
                var child = dl.childNodes[i];
                if (child == currel) {
                    var newdl = this.editor.getInnerDocument().createElement('dl');
                    while (currel.nextSibling) {
                        newdl.appendChild(currel.nextSibling);
                    };
                    dl.parentNode.insertBefore(newdl, dl.nextSibling);
                    dl.parentNode.insertBefore(p, dl.nextSibling);
                };
            };
        };
        currel.parentNode.removeChild(currel);
        var selection = this.editor.getSelection();
        selection.selectNodeContents(p);
        selection.collapse();
        this.editor.focusDocument();
    };

    this._fixStructure = function(doc, dl, offsetnode) {
        /* makes sure the order of the elements is correct */
        var currname = offsetnode.nodeName.toLowerCase();
        var currnode = offsetnode.nextSibling;
        while (currnode) {
            if (currnode.nodeType == 1) {
                var nodename = currnode.nodeName.toLowerCase();
                if (currname == 'dt' && nodename == 'dt') {
                    var dd = doc.createElement('dd');
                    while (currnode.hasChildNodes()) {
                        dd.appendChild(currnode.childNodes[0]);
                    };
                    currnode.parentNode.replaceChild(dd, currnode);
                } else if (currname == 'dd' && nodename == 'dd') {
                    var dt = doc.createElement('dt');
                    while (currnode.hasChildNodes()) {
                        dt.appendChild(currnode.childNodes[0]);
                    };
                    currnode.parentNode.replaceChild(dt, currnode);
                };
            };
            currnode = currnode.nextSibling;
        };
    };
};

DefinitionListTool.prototype = new KupuTool;

function KupuZoomTool(buttonid, firsttab, lasttab) {
    this.button = getFromSelector(buttonid);
    firsttab = firsttab || 'kupu-tb-styles';
    lasttab = lasttab || 'kupu-logo-button';

    this.initialize = function(editor) {
        this.offclass = 'kupu-zoom';
        this.onclass = 'kupu-zoom-pressed';
        this.pressed = false;

        this.baseinitialize(editor);
        this.button.tabIndex = this.editor.document.editable.tabIndex;
        addEventHandler(window, "resize", this.onresize, this);
        addEventHandler(window, "scroll", this.onscroll, this);

        /* Toolbar tabbing */
        var lastbutton = getFromSelector(lasttab);
        var firstbutton = getFromSelector(firsttab);
        var iframe = editor.getInnerDocument();
        this.setTabbing(iframe, firstbutton, lastbutton);
        this.setTabbing(firstbutton, null, editor.getDocument().getWindow());

        this.editor.logMessage(_('Zoom tool initialized'));
    };
};

KupuZoomTool.prototype = new KupuLateFocusStateButton;
KupuZoomTool.prototype.baseinitialize = KupuZoomTool.prototype.initialize;

KupuZoomTool.prototype.onscroll = function() {
    if (!this.zoomed) return;
    /* XXX Problem here: Mozilla doesn't generate onscroll when window is
     * scrolled by focus move or selection. */
    var top = window.pageYOffset!=undefined ? window.pageYOffset : document.documentElement.scrollTop;
    var left = window.pageXOffset!=undefined ? window.pageXOffset : document.documentElement.scrollLeft;
    if (top || left) window.scrollTo(0, 0);
}

// Handle tab pressed from a control.
KupuZoomTool.prototype.setTabbing = function(control, forward, backward) {
    function TabDown(event) {
        if (event.keyCode != 9 || !this.zoomed) return;

        var target = event.shiftKey ? backward : forward;
        if (!target) return;

        if (event.stopPropogation) event.stopPropogation();
        event.cancelBubble = true;
        event.returnValue = false;

        target.focus();
        return false;
    }
    addEventHandler(control, "keydown", TabDown, this);
}

KupuZoomTool.prototype.onresize = function() {
    if (!this.zoomed) return;

    var editor = this.editor;
    var iframe = editor.getDocument().editable;
    var sourcetool = editor.getTool('sourceedittool');
    var sourceArea = sourcetool?sourcetool.getSourceArea():null;

    var fulleditor = iframe.parentNode;
    var body = document.body;

    if (window.innerWidth) {
        var width = window.innerWidth;
        var height = window.innerHeight;
    } else if (document.documentElement) {
        var width = document.documentElement.offsetWidth-5;
        var height = document.documentElement.offsetHeight-5;
    } else {
        var width = document.body.offsetWidth-5;
        var height = document.body.offsetHeight-5;
    }
    width = width + 'px';
    var offset = iframe.offsetTop;
    if (sourceArea) offset = sourceArea.offsetTop-1;
    // XXX: TODO: Using wrong values here, figure out why.
    var nheight = Math.max(height - offset -1/*top border*/, 10);
    nheight = nheight + 'px';
    fulleditor.style.width = width; /*IE needs this*/
    iframe.style.width = width;
    iframe.style.height = nheight;
    if (sourceArea) {
        sourceArea.style.width = width;
        sourceArea.style.height = height;
    }
}

KupuZoomTool.prototype.checkfunc = function(selNode, button, editor, event) {
    return this.zoomed;
}

KupuZoomTool.prototype.commandfunc = function(button, editor) {
    /* Toggle zoom state */
    var zoom = button.pressed;
    this.zoomed = zoom;

    var zoomClass = 'kupu-fulleditor-zoomed';
    var iframe = editor.getDocument().getEditable();

    var body = document.body;
    var html = document.getElementsByTagName('html')[0];
    if (zoom) {
        html.style.overflow = 'hidden';
        window.scrollTo(0, 0);
        editor.setClass(zoomClass);
        body.className += ' '+zoomClass;
        this.onresize();
    } else {
        html.style.overflow = '';
        var fulleditor = iframe.parentNode;
        fulleditor.style.width = '';
        body.className = body.className.replace(/ *kupu-fulleditor-zoomed/, '');
        editor.clearClass(zoomClass);

        iframe.style.width = '';
        iframe.style.height = '';

        var sourcetool = editor.getTool('sourceedittool');
        var sourceArea = sourcetool?sourcetool.getSourceArea():null;
        if (sourceArea) {
            sourceArea.style.width = '';
            sourceArea.style.height = '';
        };
    }
    var doc = editor.getInnerDocument();
    // Mozilla needs this. Yes, really!
    doc.designMode=doc.designMode;

    window.scrollTo(0, iframe.offsetTop);
    editor.focusDocument();
}
/*****************************************************************************
 *
 * Copyright (c) 2003-2005 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id: kupuloggers.js 9879 2005-03-18 12:04:00Z yuppie $


//----------------------------------------------------------------------------
// Loggers
//
//  Loggers are pretty simple classes, that should have 1 method, called 
//  'log'. This is called with 2 arguments, the first one is the message to
//  log and the second is the severity, which can be 0 or some other false
//  value for debug messages, 1 for warnings and 2 for errors (the loggers
//  are allowed to raise an exception if that happens).
//
//----------------------------------------------------------------------------

function DebugLogger() {
    /* Alert all messages */
    
    this.log = function(message, severity) {
        /* log a message */
        if (severity > 1) {
            alert("Error: " + message);
        } else if (severity == 1) {
            alert("Warning: " + message);
        } else {
            alert("Log message: " + message);
        }
    };
}

function PlainLogger(debugelid, maxlength) {
    /* writes messages to a debug tool and throws errors */

    this.debugel = getFromSelector(debugelid);
    this.maxlength = maxlength;
    
    this.log = function(message, severity) {
        /* log a message */
        if (severity > 1) {
            throw message;
        } else {
            if (this.maxlength) {
                if (this.debugel.childNodes.length > this.maxlength - 1) {
                    this.debugel.removeChild(this.debugel.childNodes[0]);
                }
            }
            var now = new Date();
            var time = now.getHours() + ':' + now.getMinutes() + ':' + now.getSeconds();
            
            var div = document.createElement('div');
            var text = document.createTextNode(time + ' - ' + message);
            div.appendChild(text);
            this.debugel.appendChild(div);
        }
    };
}

function DummyLogger() {
    this.log = function(message, severity) {
        if (severity > 1) {
            throw message;
        }
    };
};
/*****************************************************************************
 *
 * Copyright (c) 2004 Guido Wesdorp. All rights reserved.
 *
 * This software is distributed under the terms of the i18n.js
 * License. See LICENSE.txt for license text.
 *
 *****************************************************************************/

function MessageCatalog() {
    /* Simple i18n registry

        An XML island is used to produce a mapping from msgid to phrase,
        the phrase can optionally contain interpolation terms in the format
        ${name}. Each string in the application should be retrieved from
        this object using the 'translate' method with the msgid as argument,
        optionally called with a mapping (object) from name to value which
        will be used for the interpolation. Example:

        Say we have the following XML island (note that this also serves as
        an example for the format):

        <xml id="i18n">
          <i18n language="en">
            <foo>bar</foo>
            <someline>this is a ${type} line</someline>
          </i18n>
        </xml>

        we can create an MessageCatalog object like this:

        var mc = new MessageCatalog();
        mc.initialize(document, 'i18n');

        and can then make the following calls:

        mc.translate('foo'); # would result in 'bar'
        mc.translate('someline', {'type': 'short'}); # 'this is a short line'

    */
    this.mapping = {};
};

MessageCatalog.prototype.initialize = function(doc, elid) {
    /* load the mapping from XML

        if you don't call this function, no translation will be done,
        but the object is still usable
    */
    var mapping = this.getCatalogFromXML(doc, elid);
    this.mapping = mapping;
};

MessageCatalog.prototype.getCatalogFromXML = function(doc, elid) {
    /* Parse the message catalog XML

        If called with a single arg, that arg should be some XML document.
        If called with 2 args, the first one is the HTML 'document' and
        the second the id of the XML element containing the message catalog.
    */
    if (elid) {
        doc = doc.getElementById(elid);
    };
    var mapping = {};
    var items = doc.getElementsByTagName('message');
    for (var i=0; i < items.length; i++) {
        var msgid = this.getTextFromNode(
                        items[i].getElementsByTagName('msgid')[0]);
        var msgstr = this.getTextFromNode(
                        items[i].getElementsByTagName('msgstr')[0]);
        mapping[msgid] = msgstr;
    };

    return mapping;
};

MessageCatalog.prototype.getTextFromNode = function(node) {
    /* returns the text contents of a single, not-nested node */
    var text = '';
    for (var i=0; i < node.childNodes.length; i++) {
        var child = node.childNodes[i];
        if (child.nodeType != 3) {
            continue;
        };
        text += child.nodeValue.reduceWhitespace().strip();
    };
    return text;
};

MessageCatalog.prototype.acents = function( msg ) {

	msg = msg.replace("\\xBF", "&iquest;"); /*  */
	msg = msg.replace("\\xe1", "&aacute;"); /*  */
	msg = msg.replace("\\xe9", "&eacute;"); /*  */
	msg = msg.replace("\\xed", "&iacute;"); /*  */
	msg = msg.replace("\\xf3", "&oacute;"); /*  */
	msg = msg.replace("\\xfa", "&uacute;"); /*  */
	msg = msg.replace("\\xf1", "&ntilde;"); /*  */

	return msg;
};

MessageCatalog.prototype.translate = function(msgid, interpolations) {
    var translated = this.mapping[msgid];
    if (!translated) {
        translated = msgid;
    };
    if (interpolations) {
        for (var id in interpolations) {
            var value = interpolations[id];
            var reg = new RegExp('\\\$\\\{' + id + '\\\}', 'g');
            translated = translated.replace(reg, value);
        };
    };
    return translated;
};

// instantiate a global MessageCatalog for all scripts to use
window.i18n_message_catalog = new MessageCatalog();

// make a gettext-style _ function globally available
window._ = new ContextFixer(window.i18n_message_catalog.translate,
            window.i18n_message_catalog).execute;

function HTMLTranslator() {
    /* finds Zope-style messageids in the HTML and translates them

        tries to be completely compatible to allow using Zope tools etc.
    */
};

HTMLTranslator.prototype.translate = function(doc, catalog) {
    this.doc = doc;
    if (!catalog) {
        catalog = window.i18n_message_catalog;
    };
    this.catalog = catalog;
    var docel = doc.documentElement;
    var iterator = new NodeIterator(docel);
    while (true) {
        var node = iterator.next();
        if (!node) {
            break;
        };
        this.handleNode(node);
    };
};


if (document.all) {
    HTMLTranslator.prototype.handleNode = function(node) {
        /* find out if the node contains i18n attrs and if so handle them

            it seems that the only way to not make IE barf on getAttributes
            if an attribute doesn't exist (hasAttribute sometimes reports it's
            there when it's not) is use a try block, but it slows Moz down
            like crazy, hence the two different methods
        */
        if (node.nodeType != 1) {
            return;
        };
        try {
            var t = node.getAttribute('i18n:translate');
            this.handle_i18n_translate(node, t);
        } catch(e) {
            // IE seems to barf on certain node types
        };
        try {
            var a = node.getAttribute('i18n:attributes');
            this.handle_i18n_attributes(node, a);
        } catch(e) {
        };
    };
} else {
    HTMLTranslator.prototype.handleNode = function(node) {
        /* find out if the node contains i18n attrs and if so handle them */
        if (node.nodeType != 1) {
            return;
        };
        if (node.hasAttribute('i18n:translate')) {
            var t = node.getAttribute('i18n:translate');
            this.handle_i18n_translate(node, t);
        };
        if (node.hasAttribute('i18n:attributes')) {
            var a = node.getAttribute('i18n:attributes');
            this.handle_i18n_attributes(node, a);
        };
    };
};

HTMLTranslator.prototype.handle_i18n_translate = function(node, midstring) {
    var mid;
    if (midstring.strip() != '') {
        mid = midstring;
    } else {
        mid = node.innerHTML;
    };
    mid = mid.strip().reduceWhitespace();
    node.innerHTML = this.catalog.translate(mid);
};

HTMLTranslator.prototype.handle_i18n_attributes = function(node, attrstring) {
    var attrnames = attrstring.split(';');
    for (var i=0; i < attrnames.length; i++) {
        var attr = node.getAttribute(attrnames[i]).strip();
        node.setAttribute(attrnames[i], this.catalog.translate(attr));
    };
};

//-----------------------------------------------------------------------------
// from (kupu)helpers.js
//-----------------------------------------------------------------------------

function ContextFixer(func, context) {
    /* Make sure 'this' inside a method points to its class */
    this.func = func;
    this.context = context;
    this.args = arguments;
    var self = this;

    this.execute = function() {
        /* execute the method */
        var args = new Array();
        // the first arguments will be the extra ones of the class
        for (var i=0; i < self.args.length - 2; i++) {
            args.push(self.args[i + 2]);
        };
        // the last are the ones passed on to the execute method
        for (var i=0; i < arguments.length; i++) {
            args.push(arguments[i]);
        };

        return self.func.apply(self.context, args);
    };
};

function NodeIterator(node, continueatnextsibling) {
    /* simple node iterator

        can be used to recursively walk through all children of a node,
        the next() method will return the next node until either the next
        sibling of the startnode is reached (when continueatnextsibling is
        false, the default) or when there's no node left (when
        continueatnextsibling is true)

        returns false if no nodes are left
    */

    this.node = node;
    this.current = node;
    this.terminator = continueatnextsibling ? null : node;

    this.next = function() {
        /* return the next node */
        if (!this.current) {
            // restart
            this.current = this.node;
        };
        var current = this.current;
        if (current.firstChild) {
            this.current = current.firstChild;
        } else {
            // walk up parents until we finish or find one with a nextSibling
            while (current && current != this.terminator && !current.nextSibling) {
                current = current.parentNode;
            };
            if (!current || current == this.terminator) {
                this.current = false;
            } else {
                this.current = current.nextSibling;
            };
        };
        return this.current;
    };

    this.reset = function() {
        /* reset the iterator so it starts at the first node */
        this.current = this.node;
    };

    this.setCurrent = function(node) {
        /* change the current node

            can be really useful for specific hacks, the user must take
            care that the node is inside the iterator's scope or it will
            go wild
        */
        this.current = node;
    };
};

String.prototype.strip = function() {
    var stripspace = /^\s*([\s\S]*?)\s*$/;
    return stripspace.exec(this)[1];
};

String.prototype.reduceWhitespace = function() {
    /* returns a string in which all whitespace is reduced
        to a single, plain space */
    var spacereg = /(\s+)/g;
    var copy = this;
    while (true) {
        var match = spacereg.exec(copy);
        if (!match) {
            return copy;
        };
        copy = copy.replace(match[0], ' ');
    };
};

/*****************************************************************************
 *
 * Copyright (c) 2003-2004 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id: kupueditor.js 7951 2004-12-21 15:06:38Z guido $

// WARNING: this file can contain non-ascii characters, *always* make sure your
// text-editor uses 'UTF-8' as the character encoding!!

function CleanupExpressionsTool(actionselectid, performactionbuttonid) {
    /* tool that allows global replace actions on the text contents

        the actions will be presented to the user as a list of some
        sort (e.g. select) of which the user can choose one, when (s)he
        does the system will use a set of regular expressions and 
        replacements on the code, when a match of the expression is
        encountered the match will be replaced with the replacement

        matches and replacements can be configured from the XML, the
        format is:

        <config>
          <cleanup_expressions>
            <set>
              <name>Convert single quotes to curly ones</name>
              <expression>
                <reg>
                  (\W)'
                </reg>
                <replacement>
                  \1
                </replacement>
              </expression>
              <expression>
                <reg>
                  '
                </reg>
                <replacement>
                  
                </replacement>
              </expression>
            </set>
            <set>
              <name>Reduce whitespace</name>
              <expression>
                <reg>
                  [ ]{2}
                </reg>
                <replacement>
                  &#x20;
                </replacement>
              </expression>
            </set>
          </cleanup_expressions>
        </config>
        
    */
    this.actionselect = document.getElementById(actionselectid);
    this.performactionbutton = document.getElementById(performactionbuttonid);
};

CleanupExpressionsTool.prototype = new KupuTool;

CleanupExpressionsTool.prototype.initialize = function(editor) {
    /* initialize the tool, read the regexp sets into a mapping */
    this.editor = editor;
    // mapping name -> [[regexp, replacement], ...]
    this.expressions = this.generateExpressionsMapping();
    // populate action select
    this.populateActionSelect(this.expressions);
    // add the event handler to the button
    addEventHandler(this.performactionbutton, 'click', this.performAction, 
                    this);
};

CleanupExpressionsTool.prototype.generateExpressionsMapping = function() {
    /* convert the config struct to a somewhat simpler mapping */
    var ret = {};
    var expressions = this.editor.config['cleanup_expressions'];
    if (!expressions) {
        // no expressions in the XML config, bail out
        alert('no cleanup expressions configured');
        return ret;
    };
    var sets = expressions.set;
    for (var i=0; i < sets.length; i++) {
        var set = sets[i];
        var name = set.name;
        ret[name] = [];
        var exprs = set.expression;
        // may be list type as well as object
        if (exprs.length) {
          for (var j=0; j < exprs.length; j++) {
              var expr = exprs[j];
              var regexp = expr.reg.strip();
              var replacement = this._prepareReplacement(expr.replacement)
              ret[name].push([regexp, replacement]);
          };
        } else {
            var regexp = exprs.reg.strip();
            var replacement = this._prepareReplacement(exprs.replacement);
            ret[name].push([regexp, replacement]);
        };
    };
    return ret;
};

CleanupExpressionsTool.prototype._prepareReplacement = function(data) {
    /* replace \x([0-9a-f]{2}) escapes with the unicode value of \1 */
    data = data.strip();
    var reg = /\\x([0-9a-f]{2})/g;
    while (true) {
        var match = reg.exec(data);
        if (!match || !match.length) {
            return data;
        };
        data = data.replace(match[0], String.fromCharCode(parseInt(match[1], 16)));
    };
};

CleanupExpressionsTool.prototype.populateActionSelect = function(mapping) {
    /* populate the select with which the user can choose actions */
    for (var name in mapping) {
        var option = document.createElement('option');
        option.value = name;
        option.appendChild(document.createTextNode(name));
        this.actionselect.appendChild(option);
    };
    this.actionselect.style.width = '100%';
};

CleanupExpressionsTool.prototype.performAction = function() {
    /* perform a single action (set of regexps/replacements) to the whole body */
    var action = this.actionselect.options[
                  this.actionselect.selectedIndex].value;
    var sets = this.expressions[action];
    for (var i=0; i < sets.length; i++) {
        var body = this.editor.getInnerDocument().getElementsByTagName('body')[0];
        var nodeiterator = new NodeIterator(body);
        while (true) {
            var current = nodeiterator.next();
            if (!current) {
                break;
            };
            if (current.nodeType == 3) {
                var value = current.nodeValue;
                if (value.strip()) {
                    this.performReplaceOnNode(current, sets[i][0], sets[i][1]);
                };
            };
        };
    };
    alert('Cleanup done');
};

CleanupExpressionsTool.prototype.performReplaceOnNode = function(node, regexp, replacement) {
    /* perform the replacement to the contents of a single node */
    var value = node.nodeValue;
    while (true) {
        var reg = new RegExp(regexp, 'g');
        var match = reg.exec(value);
        if (!match || !match.length) {
            node.nodeValue = value;
            return;
        };
        value = value.replace(match[0], this.createReplacement(replacement, match));
    };
};

CleanupExpressionsTool.prototype.createReplacement = function(pattern, interpolations) {
    /* interpolate '\[0-9]' escapes, they will be replaced with interpolations[n] where
        n is the number behind the backslash */
    var reg = /\\([0-9])/g;
    while (true) {
        var match = reg.exec(pattern);
        if (!match || !match.length) {
            return pattern;
        };
        pattern = pattern.replace(match[0], interpolations[parseInt(match[1])]);
    };
};
/*****************************************************************************
 *
 * Copyright (c) 2003-2004 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id: kupucontentfilters.js 18097 2005-10-03 09:51:28Z duncan $


//----------------------------------------------------------------------------
// 
// ContentFilters
//
//  These are (or currently 'this is') filters for HTML cleanup and 
//  conversion. Kupu filters should be classes that should get registered to
//  the editor using the registerFilter method with 2 methods: 'initialize'
//  and 'filter'. The first will be called with the editor as its only
//  argument and the latter with a reference to the ownerdoc (always use 
//  that to create new nodes and such) and the root node of the HTML DOM as 
//  its arguments.
//
//----------------------------------------------------------------------------

function NonXHTMLTagFilter() {
    /* filter out non-XHTML tags*/
    
    // A mapping from element name to whether it should be left out of the 
    // document entirely. If you want an element to reappear in the resulting 
    // document *including* it's contents, add it to the mapping with a 1 value.
    // If you want an element not to appear but want to leave it's contents in 
    // tact, add it to the mapping with a 0 value. If you want an element and
    // it's contents to be removed from the document, don't add it.
    if (arguments.length) {
        // allow an optional filterdata argument
        this.filterdata = arguments[0];
    } else {
        // provide a default filterdata dict
        this.filterdata = {'html': 1,
                            'body': 1,
                            'head': 1,
                            'title': 1,
                            
                            'a': 1,
                            'abbr': 1,
                            'acronym': 1,
                            'address': 1,
                            'b': 1,
                            'base': 1,
                            'blockquote': 1,
                            'br': 1,
                            'caption': 1,
                            'cite': 1,
                            'code': 1,
                            'col': 1,
                            'colgroup': 1,
                            'dd': 1,
                            'dfn': 1,
                            'div': 1,
                            'dl': 1,
                            'dt': 1,
                            'em': 1,
                            'h1': 1,
                            'h2': 1,
                            'h3': 1,
                            'h4': 1,
                            'h5': 1,
                            'h6': 1,
                            'h7': 1,
                            'i': 1,
                            'img': 1,
                            'kbd': 1,
                            'li': 1,
                            'link': 1,
                            'meta': 1,
                            'ol': 1,
                            'p': 1,
                            'pre': 1,
                            'q': 1,
                            'samp': 1,
                            'script': 1,
                            'span': 1,
                            'strong': 1,
                            'style': 1,
                            'sub': 1,
                            'sup': 1,
                            'table': 1,
                            'tbody': 1,
                            'td': 1,
                            'tfoot': 1,
                            'th': 1,
                            'thead': 1,
                            'tr': 1,
                            'ul': 1,
                            'u': 1,
                            'var': 1,

                            // even though they're deprecated we should leave
                            // font tags as they are, since Kupu sometimes
                            // produces them itself.
                            'font': 1,
                            'center': 0
                            };
    };
                        
    this.initialize = function(editor) {
        /* init */
        this.editor = editor;
    };

    this.filter = function(ownerdoc, htmlnode) {
        return this._filterHelper(ownerdoc, htmlnode);
    };

    this._filterHelper = function(ownerdoc, node) {
        /* filter unwanted elements */
        if (node.nodeType == 3) {
            return ownerdoc.createTextNode(node.nodeValue);
        } else if (node.nodeType == 4) {
            return ownerdoc.createCDATASection(node.nodeValue);
        };
        // create a new node to place the result into
        // XXX this can be severely optimized by doing stuff inline rather 
        // than on creating new elements all the time!
        var newnode = ownerdoc.createElement(node.nodeName);
        // copy the attributes
        for (var i=0; i < node.attributes.length; i++) {
            var attr = node.attributes[i];
            newnode.setAttribute(attr.nodeName, attr.nodeValue);
        };
        for (var i=0; i < node.childNodes.length; i++) {
            var child = node.childNodes[i];
            var nodeType = child.nodeType;
            var nodeName = child.nodeName.toLowerCase();
            if (nodeType == 3 || nodeType == 4) {
                newnode.appendChild(this._filterHelper(ownerdoc, child));
            };
            if (nodeName in this.filterdata && this.filterdata[nodeName]) {
                newnode.appendChild(this._filterHelper(ownerdoc, child));
            } else if (nodeName in this.filterdata) {
                for (var j=0; j < child.childNodes.length; j++) {
                    newnode.appendChild(this._filterHelper(ownerdoc, 
                        child.childNodes[j]));
                };
            };
        };
        return newnode;
    };
};

//-----------------------------------------------------------------------------
//
// XHTML validation support
//
// This class is the XHTML 1.0 transitional DTD expressed as Javascript
// data structures.
//
function XhtmlValidation(editor) {
    // Support functions
    this.Set = function(ary) {
        if (typeof(ary)==typeof('')) ary = [ary];
        if (ary instanceof Array) {
            for (var i = 0; i < ary.length; i++) {
                this[ary[i]] = 1;
            }
        }
        else {
            for (var v in ary) { // already a set?
                this[v] = 1;
            }
        }
    }

    this._exclude = function(array, exceptions) {
        var ex;
        if (exceptions.split) {
            ex = exceptions.split("|");
        } else {
            ex = exceptions;
        }
        var exclude = new this.Set(ex);
        var res = [];
        for (var k=0; k < array.length;k++) {
            if (!exclude[array[k]]) res.push(array[k]);
        }
        return res;
    }
    this.setAttrFilter = function(attributes, filter) {
        for (var j = 0; j < attributes.length; j++) {
            var attr = attributes[j];
            this.attrFilters[attr] = filter || this._defaultCopyAttribute;
        }
    }

    this.setTagAttributes = function(tags, attributes) {
        for (var j = 0; j < tags.length; j++) {
            this.tagAttributes[tags[j]] = attributes;
        }
    }

    // define some new attributes for existing tags
    this.includeTagAttributes = function(tags, attributes) {
        for (var j = 0; j < tags.length; j++) {
            var tag = tags[j];
            this.tagAttributes[tag] = this.tagAttributes[tag].concat(attributes);
        }
    }

    this.excludeTagAttributes = function(tags, attributes) {
        var bad = new this.Set(attributes);
        var tagset = new this.Set(tags);
        for (var tag in tagset) {
            var val = this.tagAttributes[tag];
            for (var i = val.length; i >= 0; i--) {
                if (bad[val[i]]) {
                    val = val.concat(); // Copy
                    val.splice(i,1);
                }
            }
            this.tagAttributes[tag] = val;
            // have to store this to allow filtering for nodes on which
            // '*' is set as allowed, this allows using '*' for the attributes
            // but also filtering some out
            this.badTagAttributes[tag] = attributes;
        }
    }

    this.excludeTags = function(badtags) {
        if (typeof(badtags)==typeof('')) badtags = [badtags];
        for (var i = 0; i < badtags.length; i++) {
            delete this.tagAttributes[badtags[i]];
        }
    }

    this.excludeAttributes = function(badattrs) {
        this.excludeTagAttributes(this.tagAttributes, badattrs);
        for (var i = 0; i < badattrs.length; i++) {
            delete this.attrFilters[badattrs[i]];
        }
    }
    if (editor.getBrowserName()=="IE") {
        this._getTagName = function(htmlnode) {
            var nodename = htmlnode.nodeName.toLowerCase();
            if (htmlnode.scopeName && htmlnode.scopeName != "HTML") {
                nodename = htmlnode.scopeName+':'+nodename;
            }
            return nodename;
        }
    } else {
        this._getTagName = function(htmlnode) {
            return htmlnode.nodeName.toLowerCase();
        }
    };

    // Supporting declarations
    this.elements = new function(validation) {
        // A list of all attributes
        this.attributes = [
            'abbr','accept','accept-charset','accesskey','action','align','alink',
            'alt','archive','axis','background','bgcolor','border','cellpadding',
            'cellspacing','char','charoff','charset','checked','cite','class',
            'classid','clear','code','codebase','codetype','color','cols','colspan',
            'compact','content','coords','data','datetime','declare','defer','dir',
            'disabled','enctype','face','for','frame','frameborder','headers',
            'height','href','hreflang','hspace','http-equiv','id','ismap','label',
            'lang','language','link','longdesc','marginheight','marginwidth',
            'maxlength','media','method','multiple','name','nohref','noshade','nowrap',
            'object','onblur','onchange','onclick','ondblclick','onfocus','onkeydown',
            'onkeypress','onkeyup','onload','onmousedown','onmousemove','onmouseout',
            'onmouseover','onmouseup','onreset','onselect','onsubmit','onunload',
            'profile','prompt','readonly','rel','rev','rows','rowspan','rules',
            'scheme','scope','scrolling','selected','shape','size','span','src',
            'standby','start','style','summary','tabindex','target','text','title','uid','uidtype',
            'type','usemap','valign','value','valuetype','vlink','vspace','width',
            'xml:lang','xml:space','xmlns'];

        // Core attributes
        this.coreattrs = ['id', 'title', 'style', 'class'];
        this.i18n = ['lang', 'dir', 'xml:lang'];
        // All event attributes are here but commented out so we don't
        // have to remove them later.
        this.events = []; // 'onclick|ondblclick|onmousedown|onmouseup|onmouseover|onmousemove|onmouseout|onkeypress|onkeydown|onkeyup'.split('|');
        this.focusevents = []; // ['onfocus','onblur']
        this.loadevents = []; // ['onload', 'onunload']
        this.formevents = []; // ['onsubmit','onreset']
        this.inputevents = [] ; // ['onselect', 'onchange']
        this.focus = ['accesskey', 'tabindex'].concat(this.focusevents);
        this.attrs = [].concat(this.coreattrs, this.i18n, this.events);

        // entities
        this.special_extra = ['object','applet','img','map','iframe'];
        this.special_basic=['br','span','bdo'];
        this.special = [].concat(this.special_basic, this.special_extra);
        this.fontstyle_extra = ['big','small','font','basefont'];
        this.fontstyle_basic = ['tt','i','b','u','s','strike'];
        this.fontstyle = [].concat(this.fontstyle_basic, this.fontstyle_extra);
        this.phrase_extra = ['sub','sup'];
        this.phrase_basic=[
                          'em','strong','dfn','code','q',
                          'samp','kbd','var', 'cite','abbr','acronym'];
        this.inline_forms = ['input','select','textarea','label','button'];
        this.misc_inline = ['ins','del'];
        this.misc = ['noscript'].concat(this.misc_inline);
        this.inline = ['a'].concat(this.special, this.fontstyle, this.phrase, this.inline_forms);

        this.Inline = ['#PCDATA'].concat(this.inline, this.misc_inline);

        this.heading = ['h1','h2','h3','h4','h5','h6'];
        this.lists = ['ul','ol','dl','menu','dir'];
        this.blocktext = ['pre','hr','blockquote','address','center','noframes'];
        this.block = ['p','div','isindex','fieldset','table'].concat(
                     this.heading, this.lists, this.blocktext);

        this.Flow = ['#PCDATA','form'].concat(this.block, this.inline);
    }(this);

    this._commonsetting = function(self, names, value) {
        for (var n = 0; n < names.length; n++) {
            self[names[n]] = value;
        }
    }
    
    // The tagAttributes class returns all valid attributes for a tag,
    // e.g. a = this.tagAttributes.head
    // a.head -> [ 'lang', 'xml:lang', 'dir', 'id', 'profile' ]
    this.tagAttributes = new function(el, validation) {
        this.title = el.i18n.concat('id','uid', 'uidtype');
        this.html = this.title.concat('xmlns','uid', 'uidtype');
        this.head = this.title.concat('profile','uid', 'uidtype');
        this.base = ['id', 'href', 'target','uid', 'uidtype'];
        this.meta =  this.title.concat('http-equiv','name','content', 'scheme','uid', 'uidtype');
        this.link = el.attrs.concat('charset','href','hreflang','type', 'rel','rev','media','target','uid', 'uidtype');
        this.style = this.title.concat('type','media','title', 'xml:space','uid', 'uidtype');
        this.script = ['id','charset','type','language','src','defer', 'xml:space','uid', 'uidtype'];
        this.iframe = [
                      'longdesc','name','src','frameborder','marginwidth',
                      'marginheight','scrolling','align','height','width','uid', 'uidtype'].concat(el.coreattrs);
        this.body = ['background','bgcolor','text','link','vlink','alink','uid', 'uidtype'].concat(el.attrs, el.loadevents);
        validation._commonsetting(this,
                                  ['p','div','uid', 'uidtype'].concat(el.heading),
                                  ['align','uid', 'uidtype'].concat(el.attrs));
        this.dl = this.dir = this.menu = el.attrs.concat('compact','uid', 'uidtype');
        this.ul = this.menu.concat('type','uid', 'uidtype');
        this.ol = this.ul.concat('start','uid', 'uidtype');
        this.li = el.attrs.concat('type','value','uid', 'uidtype');
        this.hr = el.attrs.concat('align','noshade','size','width','uid', 'uidtype');
        this.pre = el.attrs.concat('width','xml:space','uid', 'uidtype');
        this.blockquote = this.q = el.attrs.concat('cite','uid', 'uidtype');
        this.ins = this.del = this.blockquote.concat('datetime','uid', 'uidtype');
        this.a = el.attrs.concat(el.focus,'charset','type','name','href','hreflang','rel','rev','shape','coords','target','uid', 'uidtype');
        this.bdo = el.coreattrs.concat(el.events, 'lang','xml:lang','dir','uid', 'uidtype');
        this.br = el.coreattrs.concat('clear','uid', 'uidtype');
        validation._commonsetting(this,
                                  ['noscript','noframes','dt', 'dd', 'address','center','span','em', 'strong', 'dfn','code',
                                  'samp','kbd','var','cite','abbr','acronym','sub','sup','tt',
                                  'i','b','big','small','u','s','strike', 'fieldset','uid', 'uidtype'],
                                  el.attrs);

        this.basefont = ['id','size','color','face','uid', 'uidtype'];
        this.p = ['id','uid','uidtype'];
        this.font = el.coreattrs.concat(el.i18n, 'size','color','face','uid', 'uidtype');
        this.object = el.attrs.concat('declare','classid','codebase','data','type','codetype','archive','standby','height','width','usemap','name','tabindex','align','border','hspace','vspace','uid', 'uidtype');
        this.param = ['id','name','value','valuetype','type','uid', 'uidtype'];
        this.applet = el.coreattrs.concat('codebase','archive','code','object','alt','name','width','height','align','hspace','vspace','uid', 'uidtype');
        this.img = el.attrs.concat('src','alt','name','longdesc','height','width','usemap','ismap','align','border','hspace','vspace','uid', 'uidtype');
        this.map = this.title.concat('title','name', 'style', 'class', el.events);
        this.area = el.attrs.concat('shape','coords','href','nohref','alt','target', el.focus);
        this.form = el.attrs.concat('action','method','name','enctype',el.formevents,'accept','accept-charset','target','uid', 'uidtype');
        this.label = el.attrs.concat('for','accesskey', el.focusevents);
        this.input = el.attrs.concat('type','name','value','checked','disabled','readonly','size','maxlength','src','alt','usemap',el.input,'accept','align', el.focus);
        this.select = el.attrs.concat('name','size','multiple','disabled','tabindex', el.focusevents,el.input);
        this.optgroup = el.attrs.concat('disabled','label','uid', 'uidtype');
        this.option = el.attrs.concat('selected','disabled','label','value','uid', 'uidtype');
        this.textarea = el.attrs.concat('name','rows','cols','disabled','readonly', el.inputevents, el.focus);
        this.legend = el.attrs.concat('accesskey','align','uid', 'uidtype');
        this.button = el.attrs.concat('name','value','type','disabled',el.focus);
        this.isindex = el.coreattrs.concat('prompt', el.i18n);
        this.table = el.attrs.concat('summary','width','border','frame','rules','cellspacing','cellpadding','align','bgcolor','uid', 'uidtype');
        this.caption = el.attrs.concat('align','uid', 'uidtype');
        this.col = this.colgroup = el.attrs.concat('span','width','align','char','charoff','valign','uid', 'uidtype');
        this.thead =  el.attrs.concat('align','char','charoff','valign','uid', 'uidtype');
        this.tfoot = this.tbody = this.thead;
        this.tr = this.thead.concat('bgcolor','uid', 'uidtype');
        this.td = this.th = this.tr.concat('abbr','axis','headers','scope','rowspan','colspan','nowrap','width','height','uid', 'uidtype');
    }(this.elements, this);

    this.badTagAttributes = new this.Set({});

    // State array. For each tag identifies what it can contain.
    // I'm not attempting to check the order or number of contained
    // tags (yet).
    this.States = new function(el, validation) {

        var here = this;
        function setStates(tags, value) {
            var valset = new validation.Set(value);

            for (var i = 0; i < tags.length; i++) {
                here[tags[i]] = valset;
            }
        }
        
        setStates(['html'], ['head','body']);
        setStates(['head'], ['title','base','script','style', 'meta','link','object','isindex']);
        setStates([
            'base', 'meta', 'link', 'hr', 'param', 'img', 'area', 'input',
            'br', 'basefont', 'isindex', 'col',
            ], []);

        setStates(['title','style','script','option','textarea'], ['#PCDATA']);
        setStates([ 'noscript', 'iframe', 'noframes', 'body', 'div',
            'li', 'dd', 'blockquote', 'center', 'ins', 'del', 'td', 'th',
            ], el.Flow);

        setStates(el.heading, el.Inline);
        setStates([ 'p', 'dt', 'address', 'span', 'bdo', 'caption',
            'em', 'strong', 'dfn','code','samp','kbd','var',
            'cite','abbr','acronym','q','sub','sup','tt','i',
            'b','big','small','u','s','strike','font','label',
            'legend'], el.Inline);

        setStates(['ul', 'ol', 'menu', 'dir', 'ul', ], ['li']);
        setStates(['dl'], ['dt','dd']);
        setStates(['pre'], validation._exclude(el.Inline, "img|object|applet|big|small|sub|sup|font|basefont"));
        setStates(['a'], validation._exclude(el.Inline, "a"));
        setStates(['applet', 'object'], ['#PCDATA', 'param','form'].concat(el.block, el.inline, el.misc));
        setStates(['map'], ['form', 'area'].concat(el.block, el.misc));
        setStates(['form'], validation._exclude(el.Flow, ['form']));
        setStates(['select'], ['optgroup','option']);
        setStates(['optgroup'], ['option']);
        setStates(['fieldset'], ['#PCDATA','legend','form'].concat(el.block,el.inline,el.misc));
        setStates(['button'], validation._exclude(el.Flow, ['a','form','iframe'].concat(el.inline_forms)));
        setStates(['table'], ['caption','col','colgroup','thead','tfoot','tbody','tr']);
        setStates(['thead', 'tfoot', 'tbody'], ['tr']);
        setStates(['colgroup'], ['col']);
        setStates(['tr'], ['th','td']);
    }(this.elements, this);

    // Permitted elements for style.
    this.styleWhitelist = new this.Set(['text-align', 'list-style-type', 'float']);
    this.classBlacklist = new this.Set(['MsoNormal', 'MsoTitle', 'MsoHeader', 'MsoFootnoteText',
        'Bullet1', 'Bullet2']);

    this.classFilter = function(value) {
        var classes = value.split(' ');
        var filtered = [];
        for (var i = 0; i < classes.length; i++) {
            var c = classes[i];
            if (c && !this.classBlacklist[c]) {
                filtered.push(c);
            }
        }
        return filtered.join(' ');
    }
    this._defaultCopyAttribute = function(name, htmlnode, xhtmlnode) {
        var val = htmlnode.getAttribute(name);
        if (val) xhtmlnode.setAttribute(name, val);
    }
    // Set up filters for attributes.
    var filter = this;
    this.attrFilters = new function(validation, editor) {
        var attrs = validation.elements.attributes;
        for (var i=0; i < attrs.length; i++) {
            this[attrs[i]] = validation._defaultCopyAttribute;
        }
        this['class'] = function(name, htmlnode, xhtmlnode) {
            var val = htmlnode.getAttribute('class');
            if (val) val = validation.classFilter(val);
            if (val) xhtmlnode.setAttribute('class', val);
        }
        // allow a * wildcard to make all attributes valid in the filter
        // note that this is pretty slow on IE
        this['*'] = function(name, htmlnode, xhtmlnode) {
            var nodeName = filter._getTagName(htmlnode);
            var bad = filter.badTagAttributes[nodeName];
            for (var i=0; i < htmlnode.attributes.length; i++) {
                var attr = htmlnode.attributes[i];
                if (bad && bad.contains(attr.name)) {
                    continue;
                };
                if (attr.value !== null && attr.value !== undefined) {
                    xhtmlnode.setAttribute(attr.name, attr.value);
                };
            };
        }
        if (editor.getBrowserName()=="IE") {
            this['class'] = function(name, htmlnode, xhtmlnode) {
                var val = htmlnode.className;
                if (val) val = validation.classFilter(val);
                if (val) xhtmlnode.setAttribute('class', val);
            }
            this['http-equiv'] = function(name, htmlnode, xhtmlnode) {
                var val = htmlnode.httpEquiv;
                if (val) xhtmlnode.setAttribute('http-equiv', val);
            }
            this['xml:lang'] = this['xml:space'] = function(name, htmlnode, xhtmlnode) {
                try {
                    var val = htmlnode.getAttribute(name);
                    if (val) xhtmlnode.setAttribute(name, val);
                } catch(e) {
                }
            }
        }
        this.rowspan = this.colspan = function(name, htmlnode, xhtmlnode) {
            var val = htmlnode.getAttribute(name);
            if (val && val != '1') xhtmlnode.setAttribute(name, val);
        }
        this.style = function(name, htmlnode, xhtmlnode) {
            var val = htmlnode.style.cssText;
            if (val) {
                var styles = val.split(/; */);
                for (var i = styles.length; i >= 0; i--) if (styles[i]) {
                    var parts = /^([^:]+): *(.*)$/.exec(styles[i]);
                    var name = parts[1].toLowerCase();
                    if (validation.styleWhitelist[name]) {
                        styles[i] = name+': '+parts[2];
                    } else {
                        styles.splice(i,1); // delete
                    }
                }
                if (styles[styles.length-1]) styles.push('');
                val = styles.join('; ').strip();
            }
            if (val) xhtmlnode.setAttribute('style', val);
        }
    }(this, editor);

    // Exclude unwanted tags.
    this.excludeTags(['center']);

    if (editor.config && editor.config.htmlfilter) {
        this.filterStructure = editor.config.htmlfilter.filterstructure;
        
        var exclude = editor.config.htmlfilter;
        if (exclude.a)
            this.excludeAttributes(exclude.a);
        if (exclude.t)
            this.excludeTags(exclude.t);
        if (exclude.c) {
            var c = exclude.c;
            if (!c.length) c = [c];
            for (var i = 0; i < c.length; i++) {
                this.excludeTagAttributes(c[i].t, c[i].a);
            }
        }
        if (exclude.xstyle) {
            var s = exclude.xstyle;
            for (var i = 0; i < s.length; i++) {
                this.styleWhitelist[s[i]] = 1;
            }
        }
        if (exclude['class']) {
            var c = exclude['class'];
            for (var i = 0; i < c.length; i++) {
                this.classBlacklist[c[i]] = 1;
            }
        }
    };

    // Copy all valid attributes from htmlnode to xhtmlnode.
    this._copyAttributes = function(htmlnode, xhtmlnode, valid) {
        if (valid.contains('*')) {
            // allow all attributes on this tag
            this.attrFilters['*'](name, htmlnode, xhtmlnode);
            return;
        };
        for (var i = 0; i < valid.length; i++) {
            var name = valid[i];
            var filter = this.attrFilters[name];
            if (filter) filter(name, htmlnode, xhtmlnode);
        }
    }

    this._convertToSarissaNode = function(ownerdoc, htmlnode, xhtmlparent) {
        return this._convertNodes(ownerdoc, htmlnode, xhtmlparent, new this.Set(['html']));
    };
    
    this._convertNodes = function(ownerdoc, htmlnode, xhtmlparent, permitted) {
        var name, parentnode = xhtmlparent;
        var nodename = this._getTagName(htmlnode);
        var nostructure = !this.filterstructure;

        // TODO: This permits valid tags anywhere. it should use the state
        // table in xhtmlvalid to only permit tags where the XHTML DTD
        // says they are valid.
        var validattrs = this.tagAttributes[nodename];
        if (validattrs && (nostructure || permitted[nodename])) {
            try {
                var xhtmlnode = ownerdoc.createElement(nodename);
                parentnode = xhtmlnode;
            } catch (e) { };

            if (validattrs && xhtmlnode)
                this._copyAttributes(htmlnode, xhtmlnode, validattrs);
        }

        var kids = htmlnode.childNodes;
        var permittedChildren = this.States[parentnode.tagName] || permitted;

        if (kids.length == 0) {
            if (htmlnode.text && htmlnode.text != "" &&
                (nostructure || permittedChildren['#PCDATA'])) {
                var text = htmlnode.text;
                var tnode = ownerdoc.createTextNode(text);
                parentnode.appendChild(tnode);
            }
        } else {
            for (var i = 0; i < kids.length; i++) {
                var kid = kids[i];

                if (kid.parentNode !== htmlnode) {
                    if (kid.tagName == 'BODY') {
                        if (nodename != 'html') continue;
                    } else if (kid.parentNode.tagName === htmlnode.tagName) {
                        continue; // IE bug: nodes appear multiple places
                    }
                }
                
                if (kid.nodeType == 1) {
                    var newkid = this._convertNodes(ownerdoc, kid, parentnode, permittedChildren);
                    if (newkid != null) {
                        parentnode.appendChild(newkid);
                    };
                } else if (kid.nodeType == 3) {
                    if (nostructure || permittedChildren['#PCDATA'])
                        parentnode.appendChild(ownerdoc.createTextNode(kid.nodeValue));
                } else if (kid.nodeType == 4) {
                    if (nostructure || permittedChildren['#PCDATA'])
                        parentnode.appendChild(ownerdoc.createCDATASection(kid.nodeValue));
                }
            }
        } 
        return xhtmlnode;
    };
}


// turn this into a nice module-like namespace to avoid messing up the global
// (window) namespace
this.kuputoolcollapser = new function() {
    var ToolCollapser = function(toolboxesparentid) {
        this.parent = document.getElementById(toolboxesparentid);
    };

    // make the collapser available in the namespace
    this.Collapser = ToolCollapser;

    ToolCollapser.prototype.initialize = function() {
        var initial_state = {};
        if (navigator.cookieEnabled) {
            var cookie = document.cookie;
            var reg = /initial_state=([^;]+);?/;
            var match = cookie.match(reg);
            if (match) {
                eval(unescape(match[0]));
            };
        };
        for (var i=0; i < this.parent.childNodes.length; i++) {
            var child = this.parent.childNodes[i];
            if (child.className == 'kupu-toolbox') {
                var heading = child.getElementsByTagName('h1')[0];
                if (!heading) {
                    throw('heading not found by collapser for toolbox ' +
                            child.id);
                };
                heading.setAttribute('title', _('click to unfold'));
                // find the toolbox's body
                var body = this.getToolBody(child);
                // now set a handler that makes the body display and hide
                // on click, and register it to the heading
                // WAAAAAHHHH!!! since there's some weird shit happening when
                // I just use closures to refer to the body (somehow only the
                // *last* value body is set to in this loop is used?!?) I
                // used a reference to the body as 'this' in the handler
                var handler = function(heading) {
                    if (this.style.display == 'none') {
                        // assume we have a block-level element here...
                        this.style.display = 'block';
                        heading.className = 'kupu-toolbox-heading-opened';
                        heading.setAttribute('title', _('click to fold'));
                    } else {
                        this.style.display = 'none';
                        heading.className = 'kupu-toolbox-heading-closed';
                        heading.setAttribute('title', _('click to unfold'));
                    };
                };
                var wrap_openhandler = function(body, heading) {
                    return function() {
                        body.style.display = 'block';
                        heading.className = 'kupu-toolbox-heading-opened';
                    };
                };
                addEventHandler(heading, 'click', handler, body, heading);
                if (initial_state[child.id] === undefined || 
                        initial_state[child.id] == '0') {
                    body.style.display = 'none';
                } else {
                    heading.className = 'kupu-toolbox-heading-opened';
                    heading.setAttribute('title', _('click to fold'));
                };
                // add a reference to the openhandler on the toolbox div
                // so any toolbox code can use that to open the toolbox if
                // it so desires
                child.open_handler = wrap_openhandler(body, heading);
            };
        };

        addEventHandler(window, 'beforeunload', this.saveState, this);
    };

    ToolCollapser.prototype.getToolBody = function(tool) {
        var heading = tool.getElementsByTagName('h1')[0];
        var currchild = heading.nextSibling;
        while (currchild.nodeType != 1) {
            currchild = currchild.nextSibling;
            if (!currchild) {
                throw('body not found by collapser for toolbox ' +
                        child.id);
            };
        };
        return currchild;
    };

    ToolCollapser.prototype.saveState = function() {
        /* save collapse state of the toolboxes in a cookie */
        if (!navigator.cookieEnabled) {
            return;
        };
        var current_state = {};
        for (var i=0; i < this.parent.childNodes.length; i++) {
            var child = this.parent.childNodes[i];
            if (child.nodeType != 1) {
                continue;
            };
            var body = this.getToolBody(child);
            current_state[child.id] = body.style.display == 'none' ? '0' : '1';
        };
        
        var exp = new Date();
        // 100 years before state is lost... should be enough ;)
        exp.setTime(exp.getTime() + (100 * 365 * 24 * 60 * 60 * 1000));
        var cookie = 'initial_state=' + 
                            escape(this.serializeMapping(current_state)) + 
                            ';' +
                            'expires=' + exp.toGMTString() + ';' +
                            'path=/';
        document.cookie = cookie;
    };

    ToolCollapser.prototype.serializeMapping = function(mapping) {
        /* serializes the config dict into a string that can be evalled
            
            works only for dicts with string values
        */
        if (typeof(mapping) == 'string') {
            return "'" + mapping + "'";
        };
        var ret = '{';
        var first = true;
        for (var key in mapping) {
            if (!first) {
                ret += ', ';
            };
            ret += "'" + key + "': " + 
                this.serializeMapping(mapping[key]);
            first = false;
        };
        return ret + '}';
    };
}();
/*****************************************************************************
 *
 * Copyright (c) 2003-2005 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id: kupueditor.js 18104 2005-10-03 14:10:11Z duncan $

//----------------------------------------------------------------------------
// Main classes
//----------------------------------------------------------------------------

/* KupuDocument

    This essentially wraps the iframe.
    XXX Is this overkill?

*/

function KupuDocument(iframe) {
    /* Model */

    // attrs
    this.editable = iframe; // the iframe
    this.window = this.editable.contentWindow;
    this.document = this.window.document;

    this._browser = _SARISSA_IS_IE ? 'IE' : 'Mozilla';

    // methods
    this.execCommand = function(command, arg) {
        /* delegate execCommand */
        if (arg === undefined) arg = null;
        this.document.execCommand(command, false, arg);
    };

    this.reloadSource = function() {
        /* reload the source */

        // XXX To temporarily work around problems with resetting the
        // state after a reload, currently the whole page is reloaded.
        // XXX Nasty workaround!! to solve refresh problems...
        document.location = document.location;
    };

    this.getDocument = function() {
        /* returns a reference to the window.document object of the iframe */
        return this.document;
    };

    this.getWindow = function() {
        /* returns a reference to the window object of the iframe */
        return this.window;
    };

    this.getSelection = function() {
        if (this._browser == 'Mozilla') {
            return new MozillaSelection(this);
        } else {
            return new IESelection(this);
        };
    };

    this.getEditable = function() {
        return this.editable;
    };
};

/* KupuEditor

    This controls the document, should be used from the UI.

*/

function KupuEditor(document, config, logger) {
    /* Controller */

    // attrs
    this.document = document; // the model
    this.config = config; // an object that holds the config values
    this.log = logger; // simple logger object
    this.tools = {}; // mapping id->tool
    this.filters = new Array(); // contentfilters

    this._designModeSetAttempts = 0;
    this._initialized = false;

    // some properties to save the selection, required for IE to remember
    // where in the iframe the selection was
    this._previous_range = null;

    // this property is true if the content is changed, false if no changes
    // are made yet
    this.content_changed = false;

    // methods
    this.initialize = function() {
        /* Should be called on iframe.onload, will initialize the editor */
        //DOM2Event.initRegistration();
        this._initializeEventHandlers();
        if (this.getBrowserName() == "IE") {
            var body = this.getInnerDocument().getElementsByTagName('body')[0];
            body.setAttribute('contentEditable', 'true');
            // provide an 'afterInit' method on KupuEditor.prototype
            // for additional bootstrapping (after editor init)
            this._initialized = true;
            if (this.afterInit) {
                this.afterInit();
            };
            this._saveSelection();
        } else {
            this._setDesignModeWhenReady();
        };
        this.logMessage(_('Editor initialized'));
    };

    this.setContextMenu = function(menu) {
        /* initialize the contextmenu */
        menu.initialize(this);
    };

    this.registerTool = function(id, tool) {
        /* register a tool */
        this.tools[id] = tool;
        tool.initialize(this);
    };

    this.getTool = function(id) {
        /* get a tool by id */
        return this.tools[id];
    };

    this.registerFilter = function(filter) {
        /* register a content filter method

            the method will be called together with any other registered
            filters before the content is saved to the server, the methods
            can be used to filter any trash out of the content. they are
            called with 1 argument, which is a reference to the rootnode
            of the content tree (the html node)
        */
        this.filters.push(filter);
        filter.initialize(this);
    };

    this.updateStateHandler = function(event) {
        /* check whether the event is interesting enough to trigger the
        updateState machinery and act accordingly */
        var interesting_codes = new Array(8, 13, 37, 38, 39, 40, 46);
        // unfortunately it's not possible to do this on blur, since that's
        // too late. also (some versions of?) IE 5.5 doesn't support the
        // onbeforedeactivate event, which would be ideal here...
        this._saveSelection();

        if (event.type == 'click' || event.type=='mouseup' ||
                (event.type == 'keyup' &&
                    interesting_codes.contains(event.keyCode))) {
            // Filthy trick to make the updateState method get called *after*
            // the event has been resolved. This way the updateState methods can
            // react to the situation *after* any actions have been performed (so
            // can actually stay up to date).
            this.updateState(event);
        }
    };

    this.updateState = function(event) {
        /* let each tool change state if required */
        // first see if the event is interesting enough to trigger
        // the whole updateState machinery
        var selNode = this.getSelectedNode();
        for (var id in this.tools) {
            try {
                this.tools[id].updateState(selNode, event);
            } catch (e) {
                if (e == UpdateStateCancelBubble) {
                    this.updateState(event);
                    break;
                } else {
                    this.logMessage(
                        _('Exception while processing updateState on ' +
                            '${id}: ${msg}', {'id': id, 'msg': e}), 2);
                };
            };
        };
    };

    this.saveDocument = function(redirect, synchronous) {
        /* save the document

            the (optional) redirect argument can be used to make the client
            jump to another URL when the save action was successful.

            synchronous is a boolean to allow sync saving (usually better to
            not save synchronous, since it may make browsers freeze on errors,
            this is used for saveOnPart, though)
        */

        // if no dst is available, bail out
        if (!this.config.dst) {
            this.logMessage(_('No destination URL available!'), 2);
            return;
        }
        var sourcetool = this.getTool('sourceedittool');
        if (sourcetool) {sourcetool.cancelSourceMode();};

        // make sure people can't edit or save during saving
        if (!this._initialized) {
            return;
        }
        this._initialized = false;

        // set the window status so people can see we're actually saving
        window.status= _("Please wait while saving document...");

        // call (optional) beforeSave() method on all tools
        for (var id in this.tools) {
            var tool = this.tools[id];
            if (tool.beforeSave) {
                try {
                    tool.beforeSave();
                } catch(e) {
                    alert(e);
                    this._initialized = true;
                    return;
                };
            };
        };

        // pass the content through the filters
        this.logMessage(_("Starting HTML cleanup"));
        var transform = this._filterContent(this.getInnerDocument().documentElement);

        // serialize to a string
        var contents = this._serializeOutputToString(transform);

        this.logMessage(_("Cleanup done, sending document to server"));
        var request = new XMLHttpRequest();

        if (!synchronous) {
            request.onreadystatechange = (new ContextFixer(this._saveCallback,
                                               this, request, redirect)).execute;
            request.open("PUT", this.config.dst, true);
            request.setRequestHeader("Content-type", this.config.content_type);
            request.send(contents);
            this.logMessage(_("Request sent to server"));
        } else {
            this.logMessage(_('Sending request to server'));
            request.open("PUT", this.config.dst, false);
            request.setRequestHeader("Content-type", this.config.content_type);
            request.send(contents);
            this.handleSaveResponse(request,redirect)
        };
    };

    this.prepareForm = function(form, id) {
        /* add a field to the form and place the contents in it

            can be used for simple POST support where Kupu is part of a
            form
        */
        var sourcetool = this.getTool('sourceedittool');
        if (sourcetool) {sourcetool.cancelSourceMode();};

        // make sure people can't edit or save during saving
        if (!this._initialized) {
            return;
        }
        this._initialized = false;

        // set the window status so people can see we're actually saving
        window.status= _("Please wait while saving document...");

        // call (optional) beforeSave() method on all tools
        for (var tid in this.tools) {
            var tool = this.tools[tid];
            if (tool.beforeSave) {
                try {
                    tool.beforeSave();
                } catch(e) {
                    alert(e);
                    this._initialized = true;
                    return;
                };
            };
        };

        // set a default id
        if (!id) {
            id = 'kupu';
        };

        // pass the content through the filters
        this.logMessage(_("Starting HTML cleanup"));
        var transform = this._filterContent(this.getInnerDocument().documentElement);

        // XXX need to fix this.  Sometimes a spurious "\n\n" text
        // node appears in the transform, which breaks the Moz
        // serializer on .xml
        var contents =  this._serializeOutputToString(transform);

        this.logMessage(_("Cleanup done, sending document to server"));

        // now create the form input, since IE 5.5 doesn't support the
        // ownerDocument property we use window.document as a fallback (which
        // will almost by definition be correct).
        var document = form.ownerDocument ? form.ownerDocument : window.document;
        var ta = document.createElement('textarea');
        ta.style.visibility = 'hidden';
        var text = document.createTextNode(contents);
        ta.appendChild(text);
        ta.setAttribute('name', id);

        // and add it to the form
        form.appendChild(ta);

        // let the calling code know we have added the textarea
        return true;
    };

    this.execCommand = function(command, param) {
        /* general stuff like making current selection bold, italics etc.
            and adding basic elements such as lists
            */
        if (!this._initialized) {
            this.logMessage(_('Editor not initialized yet!'));
            return;
        };
        if (this.getBrowserName() == "IE") {
            this._restoreSelection();
        } else {
            this.focusDocument();
            if (command != 'useCSS') {
                this.content_changed = true;
                // note the negation: the argument doesn't work as
                // expected...
                // Done here otherwise it doesn't always work or gets lost
                // after some commands
                this.getDocument().execCommand('useCSS', !this.config.use_css);
            };
        };
        this.getDocument().execCommand(command, param);
        var message = _('Command ${command} executed', {'command': command});
        if (param) {
            message = _('Command ${command} executed with parameter ${param}',
                            {'command': command, 'param': param});
        }
        this.updateState();
        this.logMessage(message);
    };

    this.getSelection = function() {
        /* returns a Selection object wrapping the current selection */
        this._restoreSelection();
        return this.getDocument().getSelection();
    };

    this.getSelectedNode = function() {
        /* returns the selected node (read: parent) or none */
        return this.getSelection().parentElement();
    };

    this.getNearestParentOfType = function(node, type) {
        /* well the title says it all ;) */
        var type = type.toLowerCase();
        while (node) {
            if (node.nodeName.toLowerCase() == type) {
                return node
            }
            var node = node.parentNode;
        }
        return false;
    };

    this.removeNearestParentOfType = function(node, type) {
        var nearest = this.getNearestParentOfType(node, type);
        if (!nearest) {
            return false;
        };
        var parent = nearest.parentNode;
        while (nearest.childNodes.length) {
            var child = nearest.firstChild;
            child = nearest.removeChild(child);
            parent.insertBefore(child, nearest);
        };
        parent.removeChild(nearest);
    };

    this.getDocument = function() {
        /* returns a reference to the document object that wraps the iframe */
        return this.document;
    };

    this.getInnerDocument = function() {
        /* returns a reference to the window.document object of the iframe */
        return this.getDocument().getDocument();
    };

    this.insertNodeAtSelection = function(insertNode, selectNode) {
        /* insert a newly created node into the document */
        if (!this._initialized) {
            this.logMessage(_('Editor not initialized yet!'));
            return;
        };

        this.content_changed = true;

        var browser = this.getBrowserName();
        if (browser != "IE") {
            this.focusDocument();
        };

        var ret = this.getSelection().replaceWithNode(insertNode, selectNode);
        this._saveSelection();

        return ret;
    };

    this.focusDocument = function() {
        this.getDocument().getWindow().focus();
    }

    this.logMessage = function(message, severity) {
        /* log a message using the logger, severity can be 0 (message, default), 1 (warning) or 2 (error) */
        //this.log.log(message, severity);
    };

    this.registerContentChanger = function(element) {
        /* set this.content_changed to true (marking the content changed) when the
            element's onchange is called
        */
        addEventHandler(element, 'change', function() {this.content_changed = true;}, this);
    };

    // helper methods
    this.getBrowserName = function() {
        /* returns either 'Mozilla' (for Mozilla, Firebird, Netscape etc.) or 'IE' */
        if (_SARISSA_IS_MOZ) {
            return "Mozilla";
        } else if (_SARISSA_IS_IE) {
            return "IE";
        } else {
            throw _("Browser not supported!");
        }
    };

    this.handleSaveResponse = function(request, redirect) {
        // mind the 1223 status, somehow IE gives that sometimes (on 204?)
        // at first we didn't want to add it here, since it's a specific IE
        // bug, but too many users had trouble with it...
        if (request.status != '200' && request.status != '204' &&
                request.status != '1223') {
            var msg = _('Error saving your data.\nResponse status: ' +
                            '${status}.\nCheck your server log for more ' +
                            'information.', {'status': request.status});
            alert(msg);
            window.status = _("Error saving document");
        } else if (redirect) { // && (!request.status || request.status == '200' || request.status == '204'))
            window.document.location = redirect;
            this.content_changed = false;
        } else {
            // clear content_changed before reloadSrc so saveOnPart is not triggered
            this.content_changed = false;
            if (this.config.reload_after_save) {
                this.reloadSrc();
            };
            // we're done so we can start editing again
            window.status= _("Document saved");
        };
        this._initialized = true;
    };

    // private methods
    this._addEventHandler = addEventHandler;

    this._saveCallback = function(request, redirect) {
        /* callback for Sarissa */
        if (request.readyState == 4) {
            this.handleSaveResponse(request, redirect)
        };
    };

    this.reloadSrc = function() {
        /* reload the src, called after a save when reload_src is set to true */
        // XXX Broken!!!
        /*
        if (this.getBrowserName() == "Mozilla") {
            this.getInnerDocument().designMode = "Off";
        }
        */
        // XXX call reloadSrc() which has a workaround, reloads the full page
        // instead of just the iframe...
        this.getDocument().reloadSource();
        if (this.getBrowserName() == "Mozilla") {
            this.getInnerDocument().designMode = "On";
        };
        /*
        var selNode = this.getSelectedNode();
        this.updateState(selNode);
        */
    };

    this._initializeEventHandlers = function() {
        /* attache the event handlers to the iframe */
        // Initialize DOM2Event compatibility
        // XXX should come back and change to passing in an element
        this._addEventHandler(this.getInnerDocument(), "click", this.updateStateHandler, this);
        this._addEventHandler(this.getInnerDocument(), "dblclick", this.updateStateHandler, this);
        this._addEventHandler(this.getInnerDocument(), "keyup", this.updateStateHandler, this);
        this._addEventHandler(this.getInnerDocument(), "keyup", function() {this.content_changed = true}, this);
        this._addEventHandler(this.getInnerDocument(), "mouseup", this.updateStateHandler, this);
    };

    this._setDesignModeWhenReady = function() {
        /* Rather dirty polling loop to see if Mozilla is done doing it's
            initialization thing so design mode can be set.
        */
        this._designModeSetAttempts++;
       /* if (this._designModeSetAttempts > 25) {
            alert(_('Couldn\'t set design mode. Kupu will not work on this browser.'));
            return;
        };*/
        var success = false;
        try {
            this._setDesignMode();
            success = true;
        } catch (e) {
            // register a function to the timer_instance because
            // window.setTimeout can't refer to 'this'...
            timer_instance.registerFunction(this, this._setDesignModeWhenReady, 100);
        };
        if (success) {
            // provide an 'afterInit' method on KupuEditor.prototype
            // for additional bootstrapping (after editor init)
            if (this.afterInit) {
                this.afterInit();
            };
        };
    };

    this._setDesignMode = function() {
        this.getInnerDocument().designMode = "On";
        this.execCommand("undo");
        // note the negation: the argument doesn't work as expected...
        this._initialized = true;
    };

    this._saveSelection = function() {
        /* Save the selection, works around a problem with IE where the
         selection in the iframe gets lost. We only save if the current
         selection in the document */
        if (this._isDocumentSelected()) {
            var currange = this.getInnerDocument().selection.createRange();
            this._previous_range = currange;
        };
    };

    this._restoreSelection = function() {
        /* re-selects the previous selection in IE. We only restore if the
        current selection is not in the document.*/
        if (this._previous_range && !this._isDocumentSelected()) {
            try {
                this._previous_range.select();
            } catch (e) {
                alert("Error placing back selection");
                this.logMessage(_('Error placing back selection'));
            };
        };
    };

    if (this.getBrowserName() != "IE") {
        this._saveSelection = function() {};
        this._restoreSelection = function() {};
    }

    this._isDocumentSelected = function() {
        var editable_body = this.getInnerDocument().getElementsByTagName('body')[0];
        try {
            var selrange = this.getInnerDocument().selection.createRange();
        } catch(e) {
            return false;
        }
        var someelement = selrange.parentElement ? selrange.parentElement() : selrange.item(0);

        while (someelement.nodeName.toLowerCase() != 'body') {
            someelement = someelement.parentNode;
        };

        return someelement == editable_body;
    };

    this._clearSelection = function() {
        /* clear the last stored selection */
        this._previous_range = null;
    };

    this._filterContent = function(documentElement) {
        /* pass the content through all the filters */
        // first copy all nodes to a Sarissa document so it's usable
        var xhtmldoc = Sarissa.getDomDocument();
        var doc = this._convertToSarissaNode(xhtmldoc, documentElement);
        // now pass it through all filters
        for (var i=0; i < this.filters.length; i++) {
            var doc = this.filters[i].filter(xhtmldoc, doc);
        };
        // fix some possible structural problems, such as an empty or missing head, title
        // or script or textarea tags without closing tag...
        this._fixXML(doc, xhtmldoc);
        return doc;
    };

    this.getXMLBody = function(transform) {
        var bodies = transform.getElementsByTagName('body');
        var data = '';
        for (var i = 0; i < bodies.length; i++) {
            data += Sarissa.serialize(bodies[i]);
        }
        return this.escapeEntities(data);
    };

    this.getHTMLBody = function() {
        var doc = this.getInnerDocument();
        var docel = doc.documentElement;
        var bodies = docel.getElementsByTagName('body');
        var data = '';
        for (var i = 0; i < bodies.length; i++) {
            data += bodies[i].innerHTML;
        }
        return this.escapeEntities(data);
    };

    // If we have multiple bodies this needs to remove the extras.
    this.setHTMLBody = function(text) {
        var bodies = this.getInnerDocument().documentElement.getElementsByTagName('body');
        for (var i = 0; i < bodies.length-1; i++) {
            bodies[i].parentNode.removeChild(bodies[i]);
        }
        bodies[bodies.length-1].innerHTML = text;
    };

    this._fixXML = function(doc, document) {
        /* fix some structural problems in the XML that make it invalid XTHML */
        // find if we have a head and title, and if not add them
        var heads = doc.getElementsByTagName('head');
        var titles = doc.getElementsByTagName('title');
        if (!heads.length) {
            // assume we have a body, guess Kupu won't work without one anyway ;)
            var body = doc.getElementsByTagName('body')[0];
            var head = document.createElement('head');
            body.parentNode.insertBefore(head, body);
            var title = document.createElement('title');
            var titletext = document.createTextNode('');
            head.appendChild(title);
            title.appendChild(titletext);
        } else if (!titles.length) {
            var head = heads[0];
            var title = document.createElement('title');
            var titletext = document.createTextNode('');
            head.appendChild(title);
            title.appendChild(titletext);
        };
        // create a closing element for all elements that require one in XHTML
        var dualtons = new Array('a', 'abbr', 'acronym', 'address', 'applet',
                                    'b', 'bdo', 'big', 'blink', 'blockquote',
                                    'button', 'caption', 'center', 'cite',
                                    'comment', 'del', 'dfn', 'dir', 'div',
                                    'dl', 'dt', 'em', 'embed', 'fieldset',
                                    'font', 'form', 'frameset', 'h1', 'h2',
                                    'h3', 'h4', 'h5', 'h6', 'i', 'iframe',
                                    'ins', 'kbd', 'label', 'legend', 'li',
                                    'listing', 'map', 'marquee', 'menu',
                                    'multicol', 'nobr', 'noembed', 'noframes',
                                    'noscript', 'object', 'ol', 'optgroup',
                                    'option', 'p', 'pre', 'q', 's', 'script',
                                    'select', 'small', 'span', 'strike',
                                    'strong', 'style', 'sub', 'sup', 'table',
                                    'tbody', 'td', 'textarea', 'tfoot',
                                    'th', 'thead', 'title', 'tr', 'tt', 'u',
                                    'ul', 'xmp');
        // XXX I reckon this is *way* slow, can we use XPath instead or
        // something to speed this up?
        for (var i=0; i < dualtons.length; i++) {
            var elname = dualtons[i];
            var els = doc.getElementsByTagName(elname);
            for (var j=0; j < els.length; j++) {
                var el = els[j];
                if (!el.hasChildNodes()) {
                    var child = document.createTextNode('');
                    el.appendChild(child);
                };
            };
        };
    };

    this.xhtmlvalid = new XhtmlValidation(this);

    this._convertToSarissaNode = function(ownerdoc, htmlnode) {
        /* Given a string of non-well-formed HTML, return a string of
           well-formed XHTML.

           This function works by leveraging the already-excellent HTML
           parser inside the browser, which generally can turn a pile
           of crap into a DOM.  We iterate over the HTML DOM, appending
           new nodes (elements and attributes) into a node.

           The primary problems this tries to solve for crappy HTML: mixed
           element names, elements that open but don't close,
           and attributes that aren't in quotes.  This can also be adapted
           to filter out tags that you don't want and clean up inline styles.

           Inspired by Guido, adapted by Paul from something in usenet.
           Tag and attribute tables added by Duncan
        */
        return this.xhtmlvalid._convertToSarissaNode(ownerdoc, htmlnode);
    };

    this._fixupSingletons = function(xml) {
        return xml.replace(/<([^>]+)\/>/g, "<$1 />");
    }
    this._serializeOutputToString = function(transform) {
        // XXX need to fix this.  Sometimes a spurious "\n\n" text
        // node appears in the transform, which breaks the Moz
        // serializer on .xml

        if (this.config.strict_output) {
            var contents =  '<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" ' +
                            '"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">\n' +
                            '<html xmlns="http://www.w3.org/1999/xhtml">' +
                            Sarissa.serialize(transform.getElementsByTagName("head")[0]) +
                            Sarissa.serialize(transform.getElementsByTagName("body")[0]) +
                            '</html>';
        } else {
            var contents = '<html>' +
                            Sarissa.serialize(transform.getElementsByTagName("head")[0]) +
                            Sarissa.serialize(transform.getElementsByTagName("body")[0]) +
                            '</html>';
        };

        contents = this.escapeEntities(contents);

        if (this.config.compatible_singletons) {
            contents = this._fixupSingletons(contents);
        };

        return contents;
    };
    this.escapeEntities = function(xml) {
        // XXX: temporarily disabled
        return xml;
        // Escape non-ascii characters as entities.
        return xml.replace(/[^\r\n -\177]/g,
            function(c) {
            return '&#'+c.charCodeAt(0)+';';
        });
    }

    this.getFullEditor = function() {
        var fulleditor = this.getDocument().getEditable();
        while (!/kupu-fulleditor/.test(fulleditor.className)) {
            fulleditor = fulleditor.parentNode;
        }
        return fulleditor;
    }
    // Control the className and hence the style for the whole editor.
    this.setClass = function(name) {
        this.getFullEditor().className += ' '+name;
    }

    this.clearClass = function(name) {
        var fulleditor = this.getFullEditor();
        fulleditor.className = fulleditor.className.replace(' '+name, '');
    }

    this.suspendEditing = function() {
        this._previous_range = this.getSelection().getRange();
        this.setClass('kupu-modal');
        for (var id in this.tools) {
            this.tools[id].disable();
        }
        if (this.getBrowserName() == "IE") {
            var body = this.getInnerDocument().getElementsByTagName('body')[0];
            body.setAttribute('contentEditable', 'false');
        } else {

            this.getInnerDocument().designMode = "Off";
            var iframe = this.getDocument().getEditable();
            iframe.style.position = iframe.style.position?"":"relative"; // Changing this disables designMode!
        }
        this.suspended = true;
    }

    this.resumeEditing = function() {
        if (!this.suspended) {
            return;
        }
        this.suspended = false;
        this.clearClass('kupu-modal');
        for (var id in this.tools) {
            this.tools[id].enable();
        }
        if (this.getBrowserName() == "IE") {
            this._restoreSelection();
            var body = this.getInnerDocument().getElementsByTagName('body')[0];
            body.setAttribute('contentEditable', 'true');
        } else {
            var doc = this.getInnerDocument();
            doc.designMode = "On";
            this.getSelection().restoreRange(this._previous_range);
        }
    }
}

/*****************************************************************************
 *
 * Copyright (c) 2003-2005 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id$


function SourceEditTool(sourcebuttonid, sourceareaid) {
    /* Source edit tool to edit document's html source */
    this.sourceButton = getFromSelector(sourcebuttonid);
    this.sourcemode = false;
    this._currently_editing = null;

    // method defined inline to support closure
    // XXX would be nice to have this defined on the prototype too, because
    // of subclassing issues?
    this.getSourceArea = function() {
        return getFromSelector(sourceareaid);
    };
};

SourceEditTool.prototype = new KupuTool;

SourceEditTool.prototype.cancelSourceMode = function() {
    if (this._currently_editing) {
        this.switchSourceEdit(null, true);
    };
};

SourceEditTool.prototype.updateState = 
        SourceEditTool.prototype.cancelSourceMode;

SourceEditTool.prototype.initialize = function(editor) {
    /* attach the event handlers */
    this.editor = editor;
    this._fixTabIndex(this.sourceButton);
    addEventHandler(this.sourceButton, "click", this.switchSourceEdit, this);
    this.editor.logMessage(_('Source edit tool initialized'));
};

SourceEditTool.prototype.switchSourceEdit = function(event, nograb) {
    var kupu = this.editor;
    var docobj = this._currently_editing||kupu.getDocument();
    var editorframe = docobj.getEditable();
    var sourcearea = this.getSourceArea();
    var kupudoc = docobj.getDocument();
    var sourceClass = 'kupu-sourcemode';

    if (!this.sourcemode) {
        if (window.drawertool) {
            window.drawertool.closeDrawer();
        };
        if (/on/i.test(kupudoc.designMode)) {
            kupudoc.designMode = 'Off';
        };
        kupu._initialized = false;

        var data='';
        if(kupu.config.filtersourceedit) {
            window.status = _('Cleaning up HTML...');
            var transform = kupu._filterContent(
                                kupu.getInnerDocument().documentElement);
            data = kupu.getXMLBody(transform);
            data = kupu._fixupSingletons(data).replace(/<\/?body[^>]*>/g, "");
            window.status = '';
        } else {
            data = kupu.getHTMLBody();
        };
        sourcearea.value = data;
        kupu.setClass(sourceClass);
        editorframe.style.display = 'none';
        sourcearea.style.display = 'block';
        if (!nograb) {
            sourcearea.focus();
        };
        this._currently_editing = docobj;
      } else {
        kupu.setHTMLBody(sourcearea.value);
        kupu.clearClass(sourceClass);
        sourcearea.style.display = 'none';
        editorframe.style.display = 'block';
        if (/off/i.test(kupudoc.designMode)) {
            kupudoc.designMode = 'On';
        };
        if (!nograb) {
            docobj.getWindow().focus();
            var selection = this.editor.getSelection();
            selection.collapse();
        };

        kupu._initialized = true;
        this._currently_editing = null;
        this.editor.updateState();
    };
    this.sourcemode = !this.sourcemode;
};

SourceEditTool.prototype.enable = function() {
    KupuButtonEnable(this.sourceButton);
};

SourceEditTool.prototype.disable = function() {
    KupuButtonDisable(this.sourceButton);
};

function MultiSourceEditTool(sourcebuttonid, textareaprefix) {
    /* Source edit tool to edit document's html source */
    this.sourceButton = getFromSelector(sourcebuttonid);
    this.textareaprefix = textareaprefix;

    this._currently_editing = null;
};

MultiSourceEditTool.prototype = new SourceEditTool;

MultiSourceEditTool.prototype.getSourceArea = function() {
    var docobj = this._currently_editing||kupu.getDocument();
    var sourceareaid = this.textareaprefix + docobj.getEditable().id;
    return getFromSelector(sourceareaid);
};
function KupuSpellChecker(buttonid, scripturl, spanstyle, 
                            winwidth, winheight, skip_tags) {
    this.button = document.getElementById(buttonid);
    this.scripturl = scripturl;
    this.spanstyle = spanstyle || 'color: red; ' +
                                    'text-decoration: underline;';
    this.winwidth = winwidth || '600';
    this.winheight = winheight || '400';
    this.skip_tags = skip_tags || ['head', 'script'];
};

KupuSpellChecker.prototype = new KupuTool;

KupuSpellChecker.prototype.initialize = function(editor) {
    this.editor = editor;
    addEventHandler(this.button, 'click', this.check, this);
};

KupuSpellChecker.prototype.check = function() {
    var request = new XMLHttpRequest();
    request.open('POST', this.scripturl, true);
    request.setRequestHeader('Content-Type', 
                                'application/x-www-form-urlencoded');
    request.onreadystatechange = new ContextFixer(
                                    this.stateChangeHandler,
                                    this,
                                    request).execute;
    var result = this.getCurrentContents();
    result = escape(result.strip().replace('\n', ' ').reduceWhitespace());
    request.send('text=' + result);
};

KupuSpellChecker.prototype.stateChangeHandler = function(request) {
    if (request.readyState == 4) {
        if (request.status == '200') {
            var result = request.responseXML;
            result = this.xmlToMapping(result);
            if (!result) {
                alert(_('There were no errors.'));
            } else {
                this.displayUnrecognized(result);
            };
        } else {
            alert(_('Error loading data, status ${status}',
                    {'status': request.status}));
        };
    };
};

KupuSpellChecker.prototype.getCurrentContents = function() {
    var doc = this.editor.getInnerDocument().documentElement;
    var iterator = new NodeIterator(doc);
    var bits = [];
    while (true) {
        var node = iterator.next();
        if (!node) {
            break;
        };
        while (this.skip_tags.contains(node.nodeName.toLowerCase())) {
            node = node.nextSibling;
            iterator.setCurrent(node);
        };
        if (node.nodeType == 3) {
            bits.push(node.nodeValue);
        };
    };
    return bits.join(' ');
};

KupuSpellChecker.prototype.displayUnrecognized = function(mapping) {
    // copy the current editable document into a new window
    var doc = this.editor.getInnerDocument();
    var docel = doc.documentElement;
    var win = window.open('kupublank.html', 'spellchecker', 
                            'width=' + this.winwidth + ',' +
                            'height=' + this.winheight + ',toolbar=no,' +
                            'menubar=no,scrollbars=yes,status=yes');
    if (!win) {
        alert(
            _('This feature requires pop-ups to be enabled on your browser!'));
        return;
    };
    var html = docel.innerHTML;
    // when Moz tries to set the content-type, for some reason leaving this
    // in breaks the feature(?!?)
    html = html.replace(/<meta[^>]*http-equiv="[Cc]ontent-[Tt]ype"[^>]*>/gm, 
                        '');
    win.document.write('<html>' + html + '</html>');
    win.deentitize = function(str) {return str.deentitize()};
    win.document.close();
    if (!win.document.getElementsByTagName('body').length) {
        addEventHandler(win, 'load', this.continueDisplay, this, win, mapping);
    } else {
        this.continueDisplay(win, mapping);
    };
};

KupuSpellChecker.prototype.continueDisplay = function(win, mapping) {
    /* walk through all elements of the body, colouring the text nodes */
    // start it all with a timeout to make Mozilla render the content first
    timer_instance.registerFunction(this, this.continueDisplayHelper,
                                    1000, win, mapping);
};

KupuSpellChecker.prototype.continueDisplayHelper = function(win, mapping) {
    var body = win.document.getElementsByTagName('body')[0];
    body.setAttribute('contentEditable', 'false');
    var iterator = new NodeIterator(body);
    var node = iterator.next();
    timer_instance.registerFunction(this, this.displayHelperNodeLoop,
                                    10, iterator, node, win, mapping);
};

KupuSpellChecker.prototype.displayHelperNodeLoop = function(iterator, node, 
                                                                win, mapping) {
    if (!node) {
        return;
    };
    var next = iterator.next();
    if (node.nodeType == 3) {
        if (win.closed) {
            return;
        };
        var span = win.document.createElement('span');
        var before = node.nodeValue;
        var after = this.colourText(before, mapping);
        if (before != after) {
            span.innerHTML = after;
            var last = span.lastChild;
            var parent = node.parentNode;
            parent.replaceChild(last, node);
            while (span.hasChildNodes()) {
                parent.insertBefore(span.firstChild, last);
            };
        };
    } else if (node.nodeType == 1 && node.nodeName.toLowerCase() == 'a') {
        var cancelEvent = function(e) {
            if (e.preventDefault) {
                e.preventDefault();
            } else {
                e.returnValue = false;
            };
            return false;
        };
        addEventHandler(node, 'click', cancelEvent);
        addEventHandler(node, 'mousedown', cancelEvent);
        addEventHandler(node, 'mouseup', cancelEvent);
    };
    // using a timeout here makes Moz render the coloring while it's busy, and
    // will make it stop popping up 'do you want to continue' prompts...
    timer_instance.registerFunction(this, this.displayHelperNodeLoop,
                                    10, iterator, next, win, mapping);
};

KupuSpellChecker.prototype.colourText = function(text, mapping) {
    var currtext = text;
    var newtext = '';
    for (var word in mapping) {
        var replacements = mapping[word];
        replacements = replacements.entitize();
        replacements = replacements.replace(/\'/g, "&apos;");
        var reg = new RegExp('^(.*\\\W)?(' + word + ')(\\\W.*)?$', 'mg');
        while (true) {
            var match = reg.exec(currtext);
            if (!match) {
                newtext += currtext;
                currtext = newtext;
                newtext = '';
                break;
            };
            var m = (match[1] || '') + match[2];
            newtext += currtext.substr(0, currtext.indexOf(m));
            newtext += (match[1] || '') +
                        '<span style="' + this.spanstyle + '" ' +
                        'onclick="alert(deentitize(\'' + 
                        replacements + '\'));" ' +
                        'title="' + replacements + '">' +
                        match[2] +
                        '</span>';
            currtext = currtext.substr(currtext.indexOf(m) + m.length);
        };
    };
    return currtext;
};

KupuSpellChecker.prototype.xmlToMapping = function(docnode) {
    var docel = docnode.documentElement;
    var result = {};
    var incorrect = docel.getElementsByTagName('incorrect');
    for (var i=0; i < incorrect.length; i++) {
        var word = incorrect[i].firstChild.firstChild.nodeValue;
        var replacements = '';
        if (incorrect[i].lastChild.hasChildNodes()) {
            replacements = incorrect[i].lastChild.firstChild.nodeValue;
        };
        result[word] = replacements;
    };
    var attrs = [];
    return result;
};
/*****************************************************************************
 *
 * Copyright (c) 2003-2005 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id: kupudrawers.js 15812 2005-08-09 12:30:34Z duncan $

function DrawerTool() {
    /* a tool to open and fill drawers

        this tool has to (and should!) only be instantiated once
    */
    this.drawers = null;
    this.current_drawer = null;

    this.initialize = function(editor) {
        this.editor = editor;
        this.drawers = {};
        this.isIE = this.editor.getBrowserName() == 'IE';
        // this essentially makes the drawertool a singleton
        window.drawertool = this;
    };

    this.registerDrawer = function(id, drawer, editor) {
    	if (!this.drawers) this.drawers = {};
        this.drawers[id] = drawer;
        drawer.initialize(editor || this.editor, this);
    };

    this.openDrawer = function(id) {
        /* open a drawer */
        if (this.current_drawer) {
            this.closeDrawer();
        };
        var drawer = this.drawers[id];
        if (this.isIE) {
            drawer.editor._saveSelection();
        }
        drawer.createContent();
        drawer.editor.suspendEditing();
        this.current_drawer = drawer;
    };

    this.updateState = function(selNode) {
    };

    this.closeDrawer = function(button) {
        if (!this.current_drawer) {
            return;
        };
        this.current_drawer.hide();
        this.current_drawer.editor.resumeEditing();
        this.current_drawer = null;
    };

//     this.getDrawerEnv = function(iframe_win) {
//         var drawer = null;
//         for (var id in this.drawers) {
//             var ldrawer = this.drawers[id];
//             // Note that we require drawers to provide us with an
//             // element property!
//             if (ldrawer.element.contentWindow == iframe_win) {
//                 drawer = ldrawer;
//             };
//         };
//         if (!drawer) {
//             this.editor.logMessage("Drawer not found", 1);
//             return;
//         };
//         return {
//             'drawer': drawer,
//             'drawertool': this,
//             'tool': drawer.tool
//         };
//     };
};

DrawerTool.prototype = new KupuTool;

function Drawer(elementid, tool) {
    /* base prototype for drawers */

    this.element = getFromSelector(elementid);
    this.tool = tool;

    this.initialize = function(editor, drawertool) {
        this.editor = editor;
        this.drawertool = drawertool;
    };

    this.createContent = function() {
        /* fill the drawer with some content */
        // here's where any intelligence and XSLT transformation and such
        // is done
        this.element.style.display = 'block';
        this.focusElement();
    };

    this.hide = function() {
        this.element.style.display = 'none';
        this.focussed = false;
    };

    this.focusElement = function() {
        // IE can focus the drawer element, but Mozilla needs more help
        this.focussed = false;
        var iterator = new NodeIterator(this.element);
        var currnode = iterator.next();
        while (currnode) {
            if (currnode.tagName && (currnode.tagName.toUpperCase()=='BUTTON' ||
                (currnode.tagName.toUpperCase()=='INPUT' && !(/nofocus/.test(currnode.className)))
                )) {
                this.focussed = true;
                function focusit() {
                    currnode.focus();
                }
                timer_instance.registerFunction(this, focusit, 100);
                return;
            }
            currnode = iterator.next();
        }
    }
};

function LinkDrawer(elementid, tool, wrap) {
    /* Link drawer */
    this.element = getFromSelector(elementid);
    this.tool = tool;
    function wrap(id, tag) {
        return '#'+this.element.id+' '+tag+'.'+id;
    }
    var input = getBaseTagClass(this.element, 'input', 'kupu-linkdrawer-input');
    var preview = getBaseTagClass(this.element, 'iframe', 'kupu-linkdrawer-preview');

    this.createContent = function() {
        /* display the drawer */
        var currnode = this.editor.getSelectedNode();
        var linkel = this.editor.getNearestParentOfType(currnode, 'a');
        input.value = "";
        this.preview();
        if (linkel) {
            input.value = linkel.getAttribute('href');
        } else {
            input.value = 'http://';
        };
        this.element.style.display = 'block';
        this.focusElement();
    };

    this.save = function() {
        /* add or modify a link */
        this.editor.resumeEditing();
        var url = input.value;
        var target = '_self';
        if (this.target) target = this.target;
        this.tool.createLink(url, null, null, target);
        input.value = '';

        // XXX when reediting a link, the drawer does not close for
        // some weird reason. BUG! Close the drawer manually until we
        // find a fix:
        this.drawertool.closeDrawer();
    };

    this.preview = function() {
        preview.src = input.value;
        if (this.editor.getBrowserName() == 'IE') {
            preview.width = "800";
            preview.height = "365";
            preview.style.zoom = "60%";
        };
    }
    this.preview_loaded = function() {
        if (input.value  != preview.src) {
            input.value = preview.src;
        }
    }
};

LinkDrawer.prototype = new Drawer;

function TableDrawer(elementid, tool) {
    /* Table drawer */
    this.element = getFromSelector(elementid);
    this.tool = tool;

    this.addpanel = getBaseTagClass(this.element, 'div', 'kupu-tabledrawer-addtable');
    this.editpanel = getBaseTagClass(this.element, 'div', 'kupu-tabledrawer-edittable');
    var editclassselect = getBaseTagClass(this.element, 'select', 'kupu-tabledrawer-editclasschooser');
    var addclassselect = getBaseTagClass(this.element, 'select', 'kupu-tabledrawer-addclasschooser');
    var alignselect = getBaseTagClass(this.element, 'select', 'kupu-tabledrawer-alignchooser');
    var newrowsinput = getBaseTagClass(this.element, 'input', 'kupu-tabledrawer-newrows');
    var newcolsinput = getBaseTagClass(this.element, 'input', 'kupu-tabledrawer-newcols');
    var makeheadercheck = getBaseTagClass(this.element, 'input', 'kupu-tabledrawer-makeheader');

    this.createContent = function() {
        var editor = this.editor;
        var selNode = editor.getSelectedNode();

        function fixClasses(classselect) {
            if (editor.config.table_classes) {
                var classes = editor.config.table_classes['class'];
                while (classselect.hasChildNodes()) {
                    classselect.removeChild(classselect.firstChild);
                };
                for (var i=0; i < classes.length; i++) {
                    var classinfo = classes[i];
                    var caption = classinfo.xcaption || classinfo;
                    var classname = classinfo.classname || classinfo;

                    var option = document.createElement('option');
                    var content = document.createTextNode(caption);
                    option.appendChild(content);
                    option.setAttribute('value', classname);
                    classselect.appendChild(option);
                };
            };
        };
        fixClasses(addclassselect);
        fixClasses(editclassselect);

        var table = editor.getNearestParentOfType(selNode, 'table');

        if (!table) {
            // show add table drawer
            show = this.addpanel;
            hide = this.editpanel;
        } else {
            // show edit table drawer
            show = this.editpanel;
            hide = this.addpanel;
            var align = this.tool._getColumnAlign(selNode);
            selectSelectItem(alignselect, align);
            selectSelectItem(editclassselect, table.className);
        };
        hide.style.display = 'none';
        show.style.display = 'block';
        this.element.style.display = 'block';
        this.focusElement();
    };

    this.createTable = function() {
        this.editor.resumeEditing();
        var rows = newrowsinput.value;
        var cols = newcolsinput.value;
        var style = addclassselect.value;
        var add_header = makeheadercheck.checked;
        this.tool.createTable(parseInt(rows), parseInt(cols), add_header, style);
        this.drawertool.closeDrawer();
    };
    this.delTableRow = function() {
        this.editor.resumeEditing();
        this.tool.delTableRow();
        this.editor.suspendEditing();
    };
    this.addTableRow = function() {
        this.editor.resumeEditing();
        this.tool.addTableRow();
        this.editor.suspendEditing();
    };
    this.delTableColumn = function() {
        this.editor.resumeEditing();
        this.tool.delTableColumn();
        this.editor.suspendEditing();
    };
    this.addTableColumn = function() {
        this.editor.resumeEditing();
        this.tool.addTableColumn();
        this.editor.suspendEditing();
    };
    this.fixTable = function() {
        this.editor.resumeEditing();
        this.tool.fixTable();
        this.editor.suspendEditing();
    };
    this.fixAllTables = function() {
        this.editor.resumeEditing();
        this.tool.fixAllTables();
        this.editor.suspendEditing();
    };
    this.setTableClass = function(className) {
        this.editor.resumeEditing();
        this.tool.setTableClass(className);
        this.editor.suspendEditing();
    };
    this.setColumnAlign = function(align) {
        this.editor.resumeEditing();
        this.tool.setColumnAlign(align);
        this.editor.suspendEditing();
    };
};

TableDrawer.prototype = new Drawer;

function LibraryDrawer(tool, xsluri, libsuri, searchuri, baseelement) {
    /* a drawer that loads XSLT and XML from the server
       and converts the XML to XHTML for the drawer using the XSLT

       there are 2 types of XML file loaded from the server: the first
       contains a list of 'libraries', partitions for the data items,
       and the second a list of data items for a certain library

       all XML loading is done async, since sync loading can freeze Mozilla
    */

    this.init = function(tool, xsluri, libsuri, searchuri, baseelement) {
        /* This method is there to thin out the constructor and to be
           able to inherit it in sub-prototypes. Don't confuse this
           method with the component initializer (initialize()).
        */
        // these are used in the XSLT. Maybe they should be
        // parameterized or something, but we depend on so many other
        // things implicitly anyway...
        this.drawerid = 'kupu-librarydrawer';
        this.librariespanelid = 'kupu-librariespanel';
        this.resourcespanelid = 'kupu-resourcespanel';
        this.propertiespanelid = 'kupu-propertiespanel';

        if (baseelement) {
            this.baseelement = getFromSelector(baseelement);
        } else {
            this.baseelement = getBaseTagClass(document.body, 'div', 'kupu-librarydrawer-parent');
        }

        this.tool = tool;
        this.element = document.getElementById(this.drawerid);
        if (!this.element) {
            var e = document.createElement('div');
            e.id = this.drawerid;
            e.className = 'kupu-drawer '+this.drawerid;
            this.baseelement.appendChild(e);
            this.element = e;
        }
        this.shared.xsluri = xsluri;
        this.shared.libsuri = libsuri;
        this.shared.searchuri = searchuri;

        // marker that gets set when a new image has been uploaded
        this.shared.newimages = null;

        // the following vars will be available after this.initialize()
        // has been called

        // this will be filled by this._libXslCallback()
        this.shared.xsl = null;
        // this will be filled by this.loadLibraries(), which is called
        // somewhere further down the chain starting with
        // this._libsXslCallback()
        this.shared.xmldata = null;

    };
    if (tool) {
        this.init(tool, xsluri, libsuri, searchuri);
    }

    this.initialize = function(editor, drawertool) {
        this.editor = editor;
        this.drawertool = drawertool;
        this.selecteditemid = '';

        // load the xsl and the initial xml
        var wrapped_callback = new ContextFixer(this._libsXslCallback, this);
        this._loadXML(this.shared.xsluri, wrapped_callback.execute);
    };

    /*** bootstrapping ***/

    this._libsXslCallback = function(dom) {
        /* callback for when the xsl for the libs is loaded

            this is called on init and since the initial libs need
            to be loaded as well (and everything is async with callbacks
            so there's no way to wait until the XSL is loaded) this
            will also make the first loadLibraries call
        */
        this.shared.xsl = dom;

        // Change by Paul to have cached xslt transformers for reuse of
        // multiple transforms and also xslt params
        try {
            var xsltproc =  new XSLTProcessor();
            this.shared.xsltproc = xsltproc;
            xsltproc.importStylesheet(dom);
            xsltproc.setParameter("", "drawertype", this.drawertype);
            xsltproc.setParameter("", "drawertitle", this.drawertitle);
            xsltproc.setParameter("", "showupload", this.showupload);
            if (this.editor.config.captions) {
                xsltproc.setParameter("", "usecaptions", 'yes');
            }
        } catch(e) {
            return; // No XSLT Processor, maybe IE 5.5?
        }
    };

    this.createContent = function() {
        // Make sure the drawer XML is in the current Kupu instance
        if (this.element.parentNode != this.baseelement) {
            this.baseelement.appendChild(this.element);
        }
        // load the initial XML
        if(!this.shared.xmldata) {
            // Do a meaningful test to see if this is IE5.5 or some other
            // editor-enabled version whose XML support isn't good enough
            // for the drawers
            if (!window.XSLTProcessor) {
               alert("This function requires better XML support in your browser.");
               return;
            }
            this.loadLibraries();
        } else {
            if (this.shared.newimages) {
                this.reloadCurrent();
                this.shared.newimages = null;
            };
            this.updateDisplay();
            this.initialSelection();
        };

        // display the drawer div
        this.element.style.display = 'block';
    };

    this._singleLibsXslCallback = function(dom) {
        /* callback for then the xsl for single libs (items) is loaded

            nothing special needs to be called here, since initially the
            items pane will be empty
        */
        this.singlelibxsl = dom;
    };

    this.loadLibraries = function() {
        /* load the libraries and display them in a redrawn drawer */
        var wrapped_callback = new ContextFixer(this._libsContentCallback, this);
        this._loadXML(this.shared.libsuri, wrapped_callback.execute);
    };

    this._libsContentCallback = function(dom) {
        /* this is called when the libs xml is loaded

            does the xslt transformation to set up or renew the drawer's full
            content and adds the content to the drawer
        */
        this.shared.xmldata = dom;
        this.shared.xmldata.setProperty("SelectionLanguage", "XPath");

        // replace whatever is in there with our stuff
        this.updateDisplay(this.drawerid);
        this.initialSelection();
    };

    this.initialSelection = function() {
        var libnode_path = '/libraries/library[@selected]';
        var libnode = this.shared.xmldata.selectSingleNode(libnode_path);
        if (libnode) {
            var id = libnode.getAttribute('id');
            this.selectLibrary(id);
        }
    }

    this.updateDisplay = function(id) {
      /* (re-)transform XML and (re-)display the necessary part
       */
        if(!id) {
            id = this.drawerid;
        };
        try {
            this.shared.xsltproc.setParameter("", "showupload", this.showupload);
        } catch(e) {};
        var doc = this._transformXml();
        var sourcenode = doc.selectSingleNode('//*[@id="'+id+'"]');
        var targetnode = document.getElementById(id);
        sourcenode = document.importNode(sourcenode, true);
        Sarissa.copyChildNodes(sourcenode, targetnode);
        if (!this.focussed) {
            this.focusElement();
        }

        if (this.editor.getBrowserName() == 'IE' && id == this.resourcespanelid) {
            this.updateDisplay(this.drawerid);
        };
    };

    this.deselectActiveCollection = function() {
        /* Deselect the currently active collection or library */
        while (1) {
            // deselect selected DOM node
            var selected = this.shared.xmldata.selectSingleNode('//*[@selected]');
            if (!selected) {
                return;
            };
            selected.removeAttribute('selected');
        };
    };

    /*** Load a library ***/

    this.selectLibrary = function(id) {
        /* unselect the currently selected lib and select a new one

            the selected lib (libraries pane) will have a specific CSS class
            (selected)
        */
        // remove selection in the DOM
        this.deselectActiveCollection();
        // as well as visual selection in CSS
        // XXX this is slow, but we can't do XPath, unfortunately
        var divs = this.element.getElementsByTagName('div');
        for (var i=0; i<divs.length; i++ ) {
          if (divs[i].className == 'kupu-libsource-selected') {
            divs[i].className = 'kupu-libsource';
          };
        };

        var libnode_path = '/libraries/library[@id="' + id + '"]';
        var libnode = this.shared.xmldata.selectSingleNode(libnode_path);
        libnode.setAttribute('selected', '1');

        var items_xpath = "items";
        var items_node = libnode.selectSingleNode(items_xpath);

        if (items_node && !this.shared.newimages) {
            // The library has already been loaded before or was
            // already provided with an items list. No need to do
            // anything except for displaying the contents in the
            // middle pane. Newimages is set if we've lately
            // added an image.
            this.updateDisplay(this.resourcespanelid);
            this.updateDisplay(this.propertiespanelid);
        } else {
            // We have to load the library from XML first.
            var src_uri = libnode.selectSingleNode('src/text()').nodeValue;
            src_uri = src_uri.strip(); // needs kupuhelpers.js
            // Now load the library into the items pane. Since we have
            // to load the XML, do this via a call back
            var wrapped_callback = new ContextFixer(this._libraryContentCallback, this);
            this._loadXML(src_uri, wrapped_callback.execute, null);
            this.shared.newimages = null;
        };
        // instead of running the full transformations again we get a
        // reference to the element and set the classname...
        var newseldiv = document.getElementById(id);
        newseldiv.className = 'kupu-libsource-selected';
    };

    this._libraryContentCallback = function(dom, src_uri) {
        /* callback for when a library's contents (item list) is loaded

        This is also used as he handler for reloading a standard
        collection.
        */
        var libnode = this.shared.xmldata.selectSingleNode('//*[@selected]');
        var itemsnode = libnode.selectSingleNode("items");
        var newitemsnode = dom.selectSingleNode("//items");

        // IE does not support importNode on XML document nodes. As an
        // evil hack, clonde the node instead.

        if (this.editor.getBrowserName() == 'IE') {
            newitemsnode = newitemsnode.cloneNode(true);
        } else {
            newitemsnode = this.shared.xmldata.importNode(newitemsnode, true);
        }
        if (!itemsnode) {
            // We're loading this for the first time
            libnode.appendChild(newitemsnode);
        } else {
            // User has clicked reload
            libnode.replaceChild(newitemsnode, itemsnode);
        };
        this.updateDisplay(this.resourcespanelid);
        this.updateDisplay(this.propertiespanelid);
    };

    /*** Load a collection ***/

    this.selectCollection = function(id) {
        this.deselectActiveCollection();

        // First turn off current selection, if any
        this.removeSelection();

        var leafnode_path = "//collection[@id='" + id + "']";
        var leafnode = this.shared.xmldata.selectSingleNode(leafnode_path);

        // Case 1: We've already loaded the data, so we just need to
        // refer to the data by id.
        var loadedInNode = leafnode.getAttribute('loadedInNode');
        if (loadedInNode) {
            var collnode_path = "/libraries/collection[@id='" + loadedInNode + "']";
            var collnode = this.shared.xmldata.selectSingleNode(collnode_path);
            if (collnode) {
                collnode.setAttribute('selected', '1');
                this.updateDisplay(this.resourcespanelid);
                this.updateDisplay(this.propertiespanelid);
                return;
            };
        };

        // Case 2: We've already loaded the data, but there hasn't
        // been a reference made yet. So, make one :)
        uri = leafnode.selectSingleNode('uri/text()').nodeValue;
        uri = (new String(uri)).strip(); // needs kupuhelpers.js
        var collnode_path = "/libraries/collection/uri[text()='" + uri + "']/..";
        var collnode = this.shared.xmldata.selectSingleNode(collnode_path);
        if (collnode) {
            id = collnode.getAttribute('id');
            leafnode.setAttribute('loadedInNode', id);
            collnode.setAttribute('selected', '1');
            this.updateDisplay(this.resourcespanelid);
            this.updateDisplay(this.propertiespanelid);
            return;
        };

        // Case 3: We've not loaded the data yet, so we need to load it
        // this is just so we can find the leafnode much easier in the
        // callback.
        leafnode.setAttribute('selected', '1');
        var src_uri = leafnode.selectSingleNode('src/text()').nodeValue;
        src_uri = src_uri.strip(); // needs kupuhelpers.js
        var wrapped_callback = new ContextFixer(this._collectionContentCallback, this);
        this._loadXML(src_uri, wrapped_callback.execute, null);
    };

    this._collectionContentCallback = function(dom, src_uri) {
        // Unlike with libraries, we don't have to find a node to hook
        // our results into (UNLESS we've hit the reload button, but
        // that is handled in _libraryContentCallback anyway).
        // We need to give the newly retrieved data a unique ID, we
        // just use the time.
        date = new Date();
        time = date.getTime();

        // attach 'loadedInNode' attribute to leaf node so Case 1
        // applies next time.
        var leafnode = this.shared.xmldata.selectSingleNode('//*[@selected]');
        leafnode.setAttribute('loadedInNode', time);
        this.deselectActiveCollection()

        var collnode = dom.selectSingleNode('/collection');
        collnode.setAttribute('id', time);
        collnode.setAttribute('selected', '1');

        var libraries = this.shared.xmldata.selectSingleNode('/libraries');

        // IE does not support importNode on XML documet nodes
        if (this.editor.getBrowserName() == 'IE') {
            collnode = collnode.cloneNode(true);
        } else {
            collnode = this.shared.xmldata.importNode(collnode, true);
        }
        libraries.appendChild(collnode);
        this.updateDisplay(this.resourcespanelid);
        this.updateDisplay(this.propertiespanelid);
    };

    /*** Reloading a collection or library ***/

    this.reloadCurrent = function() {
        // Reload current collection or library
        this.showupload = '';
        var current = this.shared.xmldata.selectSingleNode('//*[@selected]');
        // make sure we're dealing with a collection even though a
        // resource might be selected
        if (current.tagName == "resource") {
            current.removeAttribute("selected");
            current = current.parentNode;
            current.setAttribute("selected", "1");
        };
        var src_node = current.selectSingleNode('src');
        if (!src_node) {
            // simply do nothing if the library cannot be reloaded. This
            // is currently the case w/ search result libraries.
            return;
        };

        var src_uri = src_node.selectSingleNode('text()').nodeValue;

        src_uri = src_uri.strip(); // needs kupuhelpers.js

        var wrapped_callback = new ContextFixer(this._libraryContentCallback, this);
        this._loadXML(src_uri, wrapped_callback.execute);
    };

    this.removeSelection = function() {
        // turn off current selection, if any
        var oldselxpath = '/libraries/*[@selected]//resource[@selected]';
        var oldselitem = this.shared.xmldata.selectSingleNode(oldselxpath);
        if (oldselitem) {
            oldselitem.removeAttribute("selected");
        };
        if (this.selecteditemid) {
            var item = document.getElementById(this.selecteditemid);
            if (item) {
                var span = item.getElementsByTagName('span');
                if (span.length > 0) {
                    span = span[0];
                    span.className = span.className.replace(' selected-item', '');
                }
            }
            this.selecteditemid = '';
        }
        this.showupload = '';
    }

    this.selectUpload = function() {
        this.removeSelection();
        this.showupload = 'yes';
        this.updateDisplay(this.resourcespanelid);
        this.updateDisplay(this.propertiespanelid);
    }
    /*** Selecting a resource ***/

    this.selectItem = function (item, id) {
        /* select an item in the item pane, show the item's metadata */

        // First turn off current selection, if any
        this.removeSelection();

        // Grab XML DOM node for clicked "resource" and mark it selected
        var newselxpath = '/libraries/*[@selected]//resource[@id="' + id + '"]';
        var newselitem = this.shared.xmldata.selectSingleNode(newselxpath);
        newselitem.setAttribute("selected", "1");
        //this.updateDisplay(this.resourcespanelid);
        this.updateDisplay(this.propertiespanelid);

        // Don't want to reload the resource panel xml as it scrolls to
        // the top.
        var span = item.getElementsByTagName('span');
        if (span.length > 0) {
            span = span[0];
            span.className += ' selected-item';
        }
        this.selecteditemid = id;
        if (this.editor.getBrowserName() == 'IE') {
            var ppanel = document.getElementById(this.propertiespanelid)
            var height = ppanel.clientHeight;
            if (height > ppanel.scrollHeight) height = ppanel.scrollHeight;
            if (height < 260) height = 260;
            document.getElementById(this.resourcespanelid).style.height = height+'px';
        }
        return;
    }


    this.search = function() {
        /* search */
        var searchvalue = getFromSelector('kupu-searchbox-input').value;
        //XXX make search variable configurable
        var body = 'SearchableText=' + escape(searchvalue);

        // the search uri might contain query parameters in HTTP GET
        // style. We want to do a POST though, so find any possible
        // parameters, trim them from the URI and append them to the
        // POST body instead.
        var chunks = this.shared.searchuri.split('?');
        var searchuri = chunks[0];
        if (chunks[1]) {
            body += "&" + chunks[1];
        };
        var wrapped_callback = new ContextFixer(this._searchCallback, this);
        this._loadXML(searchuri, wrapped_callback.execute, body);
    };

    this._searchCallback = function(dom) {
        var resultlib = dom.selectSingleNode("/library");

        var items = resultlib.selectNodes("items/*");
        if (!items.length) {
            alert("No results found.");
            return;
        };

        // we need to give the newly retrieved data a unique ID, we
        // just use the time.
        date = new Date();
        time = date.getTime();
        resultlib.setAttribute("id", time);

        // deselect the previous collection and mark the result
        // library as selected
        this.deselectActiveCollection();
        resultlib.setAttribute("selected", "1");

        // now hook the result library into our DOM
        if (this.editor.getBrowserName() == 'IE') {
            resultlib = resultlib.cloneNode(true);
        } else {
            this.shared.xmldata.importNode(resultlib, true);
        }
        var libraries = this.shared.xmldata.selectSingleNode("/libraries");
        libraries.appendChild(resultlib);

        this.updateDisplay(this.drawerid);
        var newseldiv = getFromSelector(time);
        newseldiv.className = 'selected';
    };

    this.save = function() {
        /* save the element, should be implemented on subclasses */
        throw "Not yet implemented";
    };

    /*** Auxiliary methods ***/

    this._transformXml = function() {
        /* transform this.shared.xmldata to HTML using this.shared.xsl and return it */
        var doc = Sarissa.getDomDocument();
	var result = this.shared.xsltproc.transformToDocument(this.shared.xmldata);
        return result;
    };

    this._loadXML = function(uri, callback, body) {
        /* load the XML from a uri

            calls callback with one arg (the XML DOM) when done
            the (optional) body arg should contain the body for the request
*/
	var xmlhttp = new XMLHttpRequest();
        var method = 'GET';
        if (body) {
          method = 'POST';
        } else {
          // be sure that body is null and not an empty string or
          // something
          body = null;
        };
        xmlhttp.open(method, uri, true);
        // use ContextFixer to wrap the Sarissa callback, both for isolating
        // the 'this' problem and to be able to pass in an extra argument
        // (callback)
        var wrapped_callback = new ContextFixer(this._sarissaCallback, xmlhttp,
                                                callback, uri);
        xmlhttp.onreadystatechange = wrapped_callback.execute;
        if (method == "POST") {
            // by default, we would send a 'text/xml' request, which
            // is a dirty lie; explicitly set the content type to what
            // a web server expects from a POST.
            xmlhttp.setRequestHeader('content-type', 'application/x-www-form-urlencoded');
        };
        xmlhttp.send(body);
    };

    this._sarissaCallback = function(user_callback, uri) {
        /* callback for Sarissa
            when the callback is called because the data's ready it
            will get the responseXML DOM and call user_callback
            with the DOM as the first argument and the uri loaded
            as the second

            note that this method should be called in the context of an
            xmlhttp object
        */
        var errmessage = 'Error loading XML: ';
        if (uri) {
            errmessage = 'Error loading ' + uri + ':';
        };
        if (this.readyState == 4) {
            if (this.status && this.status != 200) {
                alert(errmessage + this.status);
                throw "Error loading XML";
            };
            var dom = this.responseXML;
            user_callback(dom, uri);
        };
    };
};

LibraryDrawer.prototype = new Drawer;
LibraryDrawer.prototype.shared = {}; // Shared data

function ImageLibraryDrawer(tool, xsluri, libsuri, searchuri, baseelement) {
    /* a specific LibraryDrawer for images */

    this.drawertitle = "Insert Image";
    this.drawertype = "image";
    this.showupload = '';
    if (tool) {
        this.init(tool, xsluri, libsuri, searchuri, baseelement);
    }


    // upload, on submit/insert press
    this.uploadImage = function() {
        var form = document.kupu_upload_form;
        if (!form || form.node_prop_image.value=='') return;

        if (form.node_prop_caption.value == "") {
            alert("Please enter a title for the image you are uploading");
            return;
        };

        var targeturi =  this.shared.xmldata.selectSingleNode('/libraries/*[@selected]/uri/text()').nodeValue
        document.kupu_upload_form.action =  targeturi + "/kupuUploadImage";
        document.kupu_upload_form.submit();
    };

    // called for example when no permission to upload for some reason
    this.cancelUpload = function(msg) {
        var s = this.shared.xmldata.selectSingleNode('/libraries/*[@selected]');
        s.removeAttribute("selected");
        this.updateDisplay();
        if (msg != '') {
            alert(msg);
        };
    };

    // called by onLoad within document sent by server
    this.finishUpload = function(url) {
        this.editor.resumeEditing();
        var imgclass = 'image-inline';
        if (this.editor.config.captions) {
            imgclass += " captioned";
        };
        this.tool.createImage(url, null, imgclass);
        this.shared.newimages = 1;
        this.drawertool.closeDrawer();
    };


    this.save = function() {
        this.editor.resumeEditing();
        /* create an image in the iframe according to collected data
           from the drawer */
        var selxpath = '//resource[@selected]';
        var selnode = this.shared.xmldata.selectSingleNode(selxpath);

        // If no image resource is selected, check for upload
        if (!selnode) {
            var uploadbutton = this.shared.xmldata.selectSingleNode("/libraries/*[@selected]//uploadbutton");
            if (uploadbutton) {
                this.uploadImage();
            };
            return;
        };

        var uri = selnode.selectSingleNode('uri/text()').nodeValue;
        uri = uri.strip();  // needs kupuhelpers.js
        var alt = getFromSelector('image_alt').value;

        var radios = document.getElementsByName('image-align');
        for (var i = 0; i < radios.length; i++) {
            if (radios[i].checked) {
                var imgclass = radios[i].value;
            };
        };

        var caption = document.getElementsByName('image-caption');
        if (caption && caption.length>0 && caption[0].checked) {
            imgclass += " captioned";
        };

        this.tool.createImage(uri, alt, imgclass);
        this.drawertool.closeDrawer();
    };
};

ImageLibraryDrawer.prototype = new LibraryDrawer;
ImageLibraryDrawer.prototype.shared = {}; // Shared data

function LinkLibraryDrawer(tool, xsluri, libsuri, searchuri, baseelement) {
    /* a specific LibraryDrawer for links */

    this.drawertitle = "Insert Link";
    this.drawertype = "link";
    this.showupload = '';
    if (tool) {
        this.init(tool, xsluri, libsuri, searchuri, baseelement);
    }

    this.save = function() {
        this.editor.resumeEditing();
        /* create a link in the iframe according to collected data
           from the drawer */
        var selxpath = '//resource[@selected]';
        var selnode = this.shared.xmldata.selectSingleNode(selxpath);
        if (!selnode) {
            return;
        };

        var uri = selnode.selectSingleNode('uri/text()').nodeValue;
        uri = uri.strip();  // needs kupuhelpers.js
        var title = '';
        title = selnode.selectSingleNode('title/text()').nodeValue;
        title = title.strip();

        // XXX requiring the user to know what link type to enter is a
        // little too much I think. (philiKON)
        var type = null;
        var name = getFromSelector('link_name').value;
        var target = null;
        if (getFromSelector('link_target') && getFromSelector('link_target').value != '')
            target = getFromSelector('link_target').value;

        this.tool.createLink(uri, type, name, target, title);
        this.drawertool.closeDrawer();
    };
};

LinkLibraryDrawer.prototype = new LibraryDrawer;
LinkLibraryDrawer.prototype.shared = {}; // Shared data

/* Function to suppress enter key in drawers */
function HandleDrawerEnter(event, clickid) {
    var key;
    event = event || window.event;
    key = event.which || event.keyCode;

    if (key==13) {
        if (clickid) {
            var button = document.getElementById(clickid);
            if (button) {
                button.click();
            }
        }
        event.cancelBubble = true;
        if (event.stopPropogation) event.stopPropogation();

        return false;
    }
    return true;
};
function loadingImg() {
	// Creating loading image
	this.createLoadingImage = function() {
		var tLayer = $('<div id="tLayer" class="kupu-tLayer"></div>',
		$('.kupu-editorframe')).css({
			display: 'none',
			border: '1px solid #222222',
			'background-color': '#000',
			opacity: '0.3',
			filter: 'alpha(opacity=30)',
			position: 'absolute',
			top: '0px',
			left: '0px',
			'text-align': 'center',
			width: '100%',
			height: '100%',
			zIndex: '1000'
		});
		var wMessage = $('<div id="wMessage" class="kupu-wMessage">' + _('Wait, please...') + '</div>',
		$('.kupu-editorframe')).css({
			display: 'none',
			position: 'absolute',
			top: '35%',
			left: '43%',
			//width: '30%',
			//height: '24px',
			zIndex: '1001'
		});
		$('.kupu-editorframe').append(tLayer);
		$('.kupu-editorframe').append(wMessage);
	}

	this.showLoadingImage = function() {
		$('.kupu-tLayer').show();
		$('.kupu-wMessage').show();
	}


	this.showLoadingImage = function() {
		$('.kupu-tLayer').show();
		$('.kupu-wMessage').show();
	}

	this.hideLoadingImage = function() {
		$('.kupu-tLayer').hide();
		$('.kupu-wMessage').hide();
	}

};

loadingImage = new loadingImg();
function xsltParser() {


	this.xsltTransform = function(xmldoc, xsldoc, editor) {

		var xsltProcessor = new XSLTProcessor();
		var resultDocument = null;

		try {
			xsltProcessor.importStylesheet(xsldoc);
		} catch (e) {
			editor.alert(e.name + " - "  + e.message + "\n\n\n" + _('XSL stylesheet cannot be imported. Changing to tree view.'));
			editor.tools.editorviewtool.setView(editor.tools.editorviewtool.VIEW_TREE);
			return false;
		}

		this.beforeTransform(xmldoc, xsldoc, editor);

		try {
			resultDocument = xsltProcessor.transformToDocument(xmldoc);
		} catch (e) {
			editor.alert(e.name + " - "  + e.message + "\n" + _('No valid XSLT templates or no docxap template detected. Changing back to tree view.'));
			editor.tools.editorviewtool.setView(editor.tools.editorviewtool.VIEW_TREE);

			return false;
		}

		this.afterTransform(xmldoc, xsldoc, resultDocument, editor);

		if(editor.getView()=="normal"){
			$('#kupu-designview-button').addClass("kupu-designview-pressed").removeClass("kupu-designview");
		}
		// IE doesn't allow to extend XML DOM documents.
		/*resultDocument.toString = function(node) {
		 n od*e = node || this;
		 var str = new XMLSerializer().serializeToString(node);
		 return str;
	}*/

		return resultDocument;
	};

	this.beforeTransform = function(xmldoc, xsldoc, editor) {

			// Called before the XSL transformation
			var tools = editor.getTools();

			for (var id in tools) {
				try {
					if (tools[id]['beforeTransform']) tools[id].beforeTransform(xmldoc, xsldoc);
				} catch (e) {
					editor.logMessage(_('Exception while processing beforeTransform on ${id}: ${msg}', {'id': id, 'msg': e.message}), 2);
					console.error(_('Exception while processing beforeTransform on ${id}: ${msg}', {'id': id, 'msg': e}));
			}
		}
	};

	this.afterTransform = function(xmldoc, xsldoc, resultDocument, editor) {
		// Called after the XSL transformation
		var tools = editor.getTools();

		for (var id in tools) {
			try {
				if (tools[id]['afterTransform']) tools[id].afterTransform(xmldoc, xsldoc, resultDocument);
			} catch (e) {
				editor.logMessage(_('Exception while processing afterTransform on ${id}: ${msg}', {'id': id, 'msg': e.message}), 2);
				console.error(_('Exception while processing afterTransform on ${id}: ${msg}', {'id': id, 'msg': e}));
			}
		}
	}
};

xslt = new xsltParser();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




(function() {

	/**
	 *	Iterator implementation for IE.
	 *	Can't use it with a for...in loop yet, but can use it with a while loop.
	 */
	if (!Object.isFunction(window.Iterator)) {
		window.Iterator = function(collection, keys) {

			this._collection = null;
			this._keys = false;
			this._length = null;
			this._index = null;

			this._initialize = function(collection, keys) {

				this._collection = [];
				this._keys = keys;
				this._length = 0;
				this._index = 0;

				for (var index in collection) {
					var elem = collection[index];
					if (typeof(elem) != 'function') {
						var item = [index, elem];
						this._collection.push(item);
						this._length++;
					}
				}
			};

			this.next = function() {
				var item = null;
				this._index++;
				if (this._collection[this._index]) {
					item = this._collection[this._index];
				}
				return item;
			};

			this._initialize(collection, keys);
		}
	}

	if (!Object.isFunction(Array.prototype.asArray)) {
		Array.prototype.asArray = function() {
			var l = this.length;
			var arr = [];
			for (var i=0; i<l; i++) {
				var element = this[i];
				if (!element['tagName']) {
					return this;
				}
				if (!element['PATTERN'] || element.PATTERN == 'element') {
					arr.push(element.tagName);
				} else {
					arr = arr.concat(element.childNodes.asArray());
				}
			}
			return arr;
		}
	}

	$.fn.extend({
		// Defined in inc/js/helpers.js
		contains: Array.prototype.contains
	});


	/**
	 *  The AJAX Request object!
	 */
	if (!Object.isFunction(window.AjaxRequest)) {
		window.AjaxRequest = function(url, options) {

			this.send = function(url, options) {

				// TODO: Parse and work with options.params!

				options = options || {};
				options.async = options.async || true;
				options.method = options.method || 'GET';
				options.params = options.params || {};
				options.content = options.content || '';

				var req = new XMLHttpRequest();
				req.options = options;

				req.onreadystatechange = function() {

					this.req = req;
					this.options = options;

					try {

/*  * 0 Non-initiated (the open method has not been called)
    * 1 Loading (open method is called)
    * 2 Loading (send method is called and we get the http header and status)
    * 3 Interactive (responseText property has partial data)
    * 4 Complete (responseText property has all the data asked to server)*/

						if (req.readyState != 4) return;

						/**
						 * There is a known bug in MSIE, when the server response is 204
						 * the status code in IE is 1223.
						 *
						 * http://webbugtrack.blogspot.com/2008/05/bug-122-in-ie-http-204-status-may.html
						 * http://prototype.lighthouseapp.com/projects/8886/tickets/207-ajax-request-considers-http-204-a-failure-under-ie-only
						 * http://www.mail-archive.com/jquery-en@googlegroups.com/msg13093.html
						 */
						var status = (req.status != 1223) ? req.status : 204;
						if (status >= 400) {
							if (options.onError) options.onError(req);
							return;
						}

					} catch(e) {
						return;
					}

					var json = null;
					try {
						json = eval('new function() {return '+req.responseText+';}');
					} catch(e) {
						json = {};
					}
					if (options.onComplete) {
						options.onComplete(req, json);
					}
				};


				req.open(options.method, url, options.async);
				if (options.method == 'POST') {
					req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
				}
				req.send(options.content);
			};

			this._parseParams = function(params) {
				// TODO: Params in querystring, in a POST form???
				return params;
			}

			this.send(url, options);

		}
	}

})();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



/* Functions related with autoscrolling embebbed in Xedit */
$(function() {
	var intval = "";
	var myIframe;
	var dir = "";// FUTURE IMPROVEMENT: make this variable local
	// Up direction
	$('.scrollup').bind('mouseenter', function() {
		autoscrolling_start('up');
	});
	$('.scrollup').bind('mouseleave', autoscrolling_stop);

	// Down direction
	$('.scrolldown').bind('mouseenter', function() {
		autoscrolling_start('down');
	});
	$('.scrolldown').bind('mouseleave', autoscrolling_stop);

	// executes when the mouse is hover the div#autoscroll in Xedit
	function autoscrolling_start(direccion) {
		dir = direccion;
		if (intval == "") {
			intval = setInterval(playAutoScroll, 100);
		} else {
			autoscrolling_stop();
		} // stop scrolling
	}
	// executes when the mouse is out of the div#autoscroll in Xedit
	function autoscrolling_stop() {
		if (intval != "") {
			window.clearInterval(intval); // stoping scrolling
			intval = ""; // restarting variables
			dir = "";
		}
	}
	// executes the scroll on the iframe
	function playAutoScroll() {
		myIframe = document.getElementById('kupu-editor'); // rescue the iframe
															// DOM object
		if (dir == "down") {
			myIframe.contentWindow.scrollBy(0, 10);
		} // 5 pixels down
		else {
			myIframe.contentWindow.scrollBy(0, -10);
		} // 5 pixels up
	}
	/*
	 * FUTURE IMPROVEMENT TO COMPLETE function goToTop(){ myIframe =
	 * document.getElementById('kupu-editor'); //rescue the iframe DOM object
	 * myIframe.contentWindow.scrollTo(0,0); } function goToBottom(){ myIframe =
	 * document.getElementById('kupu-editor'); //rescue the iframe DOM object
	 * var myheight=myIframe.contentWindow.innerHeight;
	 * myIframe.contentWindow.scrollTo(0,900); }
	 */

});
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




var com; 
if (!com) com = {}; 
if (!com.ximdex) com.ximdex = {}; 
if (!com.ximdex.ximdex) com.ximdex.ximdex = {}; 
if (!com.ximdex.ximdex.editors) com.ximdex.ximdex.editors = {};

com.ximdex.ximdex.editors.LoadHandler = function() {

}

com.ximdex.ximdex.editors.SaveHandler = function(baseURL, content, callback, autoSave) {

	var url = baseURL + '&method=saveXmlFile';
	if(autoSave === true)
		url = url + '&autosave=true';


	new AjaxRequest(url, {
		method: 'POST',
		content: content,
		onComplete: function(req, json) {
			if (callback.onComplete) callback.onComplete(req, json);
		}.bind(this),
		onError: function(req) {
			if (callback.onError) callback.onError(req);
		}.bind(this)
	});
	
	//Tags saving
	try{
		$('.xim-tagsinput-container').tagsinput('save' ,baseURL, content, null, null);
	}catch(e){}
}

com.ximdex.ximdex.editors.PublicateHandler = function(baseURL, content, callback) {

	var url = baseURL + '&method=publicateFile';

	new AjaxRequest(url, {
		method: 'POST',
		content: content,
		onComplete: function(req, json) {
			if (callback.onComplete) callback.onComplete(req, json);
		}.bind(this),
		onError: function(req) {
			if (callback.onError) callback.onError(req);
		}.bind(this)
	});
}

com.ximdex.ximdex.editors.ValidateHandler = function(baseURL, content, callback) {

	var url = baseURL + '&ajax=json&method=validateSchema';

	new AjaxRequest(url, {
		method: 'POST',
		content: content,
		onComplete: function(req, json) {
			//console.log(json, this);
			if (callback.onComplete) callback.onComplete(req, json);
		}.bind(this),
		onError: function(req) {
			//console.error(req);
			if (callback.onError) callback.onError(req);
		}.bind(this)
	});
}

com.ximdex.ximdex.editors.PreviewHandler = function(loadActionURL, content, callback, bxeOptions) {

	var url = loadActionURL + '&action=prevdoc&ajax=json';

	new AjaxRequest(url, {
		method: 'POST',
		content: content,
		onComplete: function(req, json) {
			if (callback.onComplete) callback.onComplete(req, json);
		}.bind(this),
		onError: function(req) {
			if (callback.onError) callback.onError(req);
		}.bind(this)
	});
}

com.ximdex.ximdex.editors.SpellCheckingHandler = function(baseURL, content, callback, bxeOptions) {

	var url = baseURL + '&method=getSpellCheckingFile';

	new AjaxRequest(url, {
		method: 'POST',
		content: content,
		onComplete: function(req, json) {
			if (callback.onComplete) callback.onComplete(req, json);
		}.bind(this),
		onError: function(req) {
			if (callback.onError) callback.onError(req);
		}.bind(this)
	});
}

com.ximdex.ximdex.editors.noRenderizableElementsHandler = function(baseURL, content, callback, bxeOptions) {

	var url = baseURL + '&method=getNoRenderizableElements';

	new AjaxRequest(url, {
		method: 'POST',
		content: content,
		onComplete: function(req, json) {
			if (callback.onComplete) callback.onComplete(req, json);
		}.bind(this),
		onError: function(req) {
			if (callback.onError) callback.onError(req);
		}.bind(this)
	});
}

com.ximdex.ximdex.editors.AnnotationHandler = function(baseURL, content, callback, bxeOptions) {

	var url = baseURL + '&method=getAnnotationFile&ajax=json';

	new AjaxRequest(url, {
		method: 'POST',
		content: content,
		onComplete: function(req, json) {
			if (callback.onComplete) callback.onComplete(req, json);
		}.bind(this),
		onError: function(req) {
			if (callback.onError) callback.onError(req);
		}.bind(this)
	});
}

com.ximdex.ximdex.editors.PreviewInServerHandler = function(baseURL, content, callback, bxeOptions) {

	var url = baseURL + '&method=getPreviewInServerFile';

	new AjaxRequest(url, {
		method: 'POST',
		content: content,
		onComplete: function(req, json) {
			if (callback.onComplete) callback.onComplete(req, json);
		}.bind(this),
		onError: function(req) {
			if (callback.onError) callback.onError(req);
		}.bind(this)
	});
}

/*com.ximdex.ximdex.editors.GetXmlHandler = function(callback, caller) {

	var url = location + '&ajax=json&method=getXmlFile';

	/*var req = new com.ximdex.ximdex.editors.XMLHttpRequest();
	req.send(url, {
		cbFunction: callback,
		content: content,
		caller: caller
	});

	/*new AjaxRequest(url, {
		onComplete: function(req, json) {
			//console.log(json, this);
			callback(req, json);
		}.bind(this),
		onError: function(req) {
			//console.error(req);
			callback(req);
		}.bind(this)
	});
}*/

/*com.ximdex.ximdex.editors.GetSchemaHandler = function(callback, caller) {

	var url = location + '&ajax=json&method=getSchemaFile';

	/*
	var req = new XMLHttpRequest();
	req.overrideMimeType("text/xml");
	req.onload = function(e) {
		var req = e.currentTarget;
		req.caller = caller;
		var json = new Function("return " + req.responseText + ' || {}')();
		callback(req, json, e);
	};
	req.open("POST", url);
	req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

	req.send(content, true);


	/*var req = new com.ximdex.ximdex.editors.XMLHttpRequest();
	req.send(url, {
		cbFunction: callback,
		content: content,
		caller: caller
	});
}*/

/*com.ximdex.ximdex.editors.AllowedChildrensHandler = function(uid, content, callback) {

	var url = location + '&ajax=json&method=getAllowedChildrens&uid=' + uid;

	/*
	var req = new XMLHttpRequest();
	req.overrideMimeType("text/xml");
	req.onload = callback;
	req.open("POST", url);
	req.setRequestHeader("Content-type", "application/x-www-form-urlencoded");

	req.send(content, true);


	var req = new com.ximdex.ximdex.editors.XMLHttpRequest();
	req.send(url, {
		cbFunction: callback,
		content: content
	});

}*/
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



/**
 *  A Iterator object for childrens of a DOMNode object
 *	nodeType is optional. Normally it will be Node.ELEMENT_NODE (1).
 *	If nodeType is especified the returned node must match the nodeType.
 */
DOMNodeIterator = function(node, nodeType) {

	this.node = null;
	this.nodeType = null;
	this.childs = null;
	this.currentNode = null;

	this._initialize = function(node, nodeType) {
		if (!node || !node.childNodes) return;
		this.node = node;
		this.nodeType = nodeType || false;
		this.childs = this.node.childNodes;
		this.currentNode = -1;
	};

	this.hasNext = function() {
		if (!this.node || !this.node.childNodes) return false;
		var i = this.currentNode + 1;
		var node = this.childs[i];
		while (node && this.nodeType && node.nodeType != this.nodeType) {
			node = this.childs[++i];
		}
		var ret = node ? true : false;
		return ret;
	};

	this.next = function() {
		if (!this.node || !this.node.childNodes) return null;
		var node = null;
		while (this.hasNext() && node == null) {
			node = this.childs[++this.currentNode];
			if (this.nodeType && node && node.nodeType != this.nodeType) node = null;
		}
		return node;
	};

	this.current = function() {
		if (!this.node || !this.node.childNodes) return null;
		var node = this.childs[this.currentNode] ? this.childs[this.currentNode] : null;
		return node;
	};

	this.reset = function() {
		this.currentNode = -1;
	};

	this._initialize(node, nodeType);

}/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




/**
 *  A Iterator object for DOM attributes
 *  IE shows user and language defined attributes
 *  If attribute is an user defined one, then specified = true
 *  For FF "attributes" is an array, indexed by numbers
 *  For IE "attributes" is an associative array, indexed by attribute names
 */
DOMAttrIterator = function(node) {

	this.node = null;
	this.childs = null;
	this.currentNode = null;

	this._initialize = function(node) {
		if (!node || !node.attributes) return;
		this.node = node;
		this.childs = this.node.attributes;
		this.currentNode = -1;
	};

	this.hasNext = function() {
		if (!this.node || !this.node.attributes) return false;
		var i = this.currentNode + 1;
		var node = this.childs[i];
		while (node && !node.specified) {
			node = this.childs[++i];
		}
		var ret = node ? true : false;
		return ret;
	};

	this.next = function() {
		if (!this.node || !this.node.attributes) return null;
		var node = null;
		while (this.hasNext() && node == null) {
			node = this.childs[++this.currentNode];
			if (!node.specified) node = null;
		}
		return node;
	};

	this.current = function() {
		if (!this.node || !this.node.attributes) return null;
		var node = this.childs[this.currentNode] ? this.childs[this.currentNode] : null;
		return node;
	};

	this.reset = function() {
		this.currentNode = -1;
	};

	this._initialize(node);

}/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


/**
 * Representation of a Ximdoc document.
 * Function which loads the XML into a javascript object and creates relations between the XML node and RNG node.
 * It defines an API to operate with the nodes and export them to valid XML.
 * @constructor
 */
XimDocument = function(editorConfig) {

	/**
	 * @constant
	 */
	this.POSITION_LAST = 0x01;

	/**
	 * @constant
	 */
	this.POSITION_BEFORE = 0x02;

	/**
	 * @constant
	 */
	this.POSITION_AFTER = 0x03;

	this._nodeId = null;
	this._lastUID = [];
	this._rootNode = null;
	this._ximModel = null;
	this._xmldoc = null;
	this._rngDoc = null;
	this._exportDoc = null;
	this._channelId = null;
	this._schemaValidatorIsActive = null;
	this._editorConfig = editorConfig;
	this.editor = null;
	this._errors=[];
	this.ELEMENT_NOT_FOUND_MESSAGE = _("Elements not found in Relax-ng schema: ");

	/**
	 * Function which returns the ximdex node ID.
	 * @returns {int}
	 */
	this.getNodeId = function() {
		return this._nodeId;
	};

	/**
	 * Function which returns the ximdoc model object.
	 * @returns {object}
	 */
	this.getXimModel = function() {
		return this._ximModel;
	};

	/**
	 * Function which sets the ximdoc model object.
	 * @returns {object}
	 */
	this.setXimModel = function(model) {
		this._ximModel = model;
	};

	/**
	 * Function which returns the RNG model object.
	 * @returns {object}
	 */
	this.getRngModel = function() {
		return this._rngDoc.getModel();
	};

	/**
	 * Function which returns the RNG document.
	 * @returns {DOMDocument}
	 */
	this.getRngDocument = function() {
		return this._rngDoc;
	};

	/**
	 * Function which returns the XML document.
	 * @returns {DOMDocument}
	 */
	this.getXmlDocument = function() {
		return this._xmldoc;
	};

	/**
	 * Function which returns the transformation channel ID.
	 * @returns {int}
	 */
	this.getChannelId = function() {
		return this._channelId;
	};

	this.expertModeIsAllowed = function() {
		return (this._editorConfig.expert_mode_allowed == 0) ? false : true;
	};

	this.publicationIsAllowed = function() {
		return (this._editorConfig.publication_allowed == 0) ? false : true;
	};

	this.toggleSchemaValidator = function() {
		if (!this.expertModeIsAllowed()) this._schemaValidatorIsActive = false;
		this._schemaValidatorIsActive = !this._schemaValidatorIsActive;
		//console.info('Schema validation: %s', (this._schemaValidatorIsActive ? 'On' : 'Off'));
	};

	this.schemaValidatorIsActive = function() {
		return this._schemaValidatorIsActive;
	};

	this.setSchemaValidator = function(validate) {
		if (!this.expertModeIsAllowed()) validate = true;
		this._schemaValidatorIsActive = (validate ? true : false);
		//console.info('Schema validation: %s', (this._schemaValidatorIsActive ? 'On' : 'Off'));
	};

	/**
	 * Function which starts the parsing of a new Ximdoc Document.
	 * @param {DOMDocument} xmldoc The document to be parsed
	 * @param {DOMDocument} rngdoc The RNG schema to validate the ximdoc document.
	 */
	this.loadXML = function(xmldoc, rngdoc) {
                console.time('loadXMLXimDocument');
		this._xmldoc = xmldoc;
		this._rngDoc = rngdoc;
		this._ximModel = {};
		this._nodeId = null;
		this._lastUID = [];
		this._rootNode = null;
		this._errors = [];

		/*
		var grammar = this._findGrammarElement(this._xmldoc);
		if(grammar)
			grammar.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xim', 'http://www.ximdex.com/');
		*/

		var docxap = this._findDocxapElement(this._xmldoc);
		if (docxap) {
			//docxap.setAttributeNS('http://www.w3.org/2000/xmlns/', 'xmlns:xim', 'http://www.ximdex.com/');

			docxap.setAttribute('transformer', 'xEDIT');

			// Temporal measure
			$('semantic', docxap).remove();

			var nodeid = docxap.getAttribute('uid');
			nodeid = nodeid.split('.');
			this._nodeId = nodeid[0];
			this._rootNode = this._parseNode(docxap, null);
			this._showErrors();

		}
                console.timeEnd('loadXMLXimDocument');
	};

	
	/**
 	 * Method which alert the errors found after parse the document 
	 * @private  
	 * Create at 2012-11-20 
	 **/
	this._showErrors = function(){
		var result="";
		if (this._errors.length){
			result +=this.ELEMENT_NOT_FOUND_MESSAGE;
			for (var i = 0; i < this._errors.length; i++){
				result +="<br/>- "+this._errors[i];
			}
			this.editor.alert(result);
		}
	}

	/**
	 * Function which finds the root node to start to parse from it.
	 * @private
	 * @param {DOMNode} node
	 */
	this._findDocxapElement = function(node) {
		var docxap = node.getElementsByTagName('docxap');
		docxap = docxap[0];
		return docxap;
	};

	this._findGrammarElement = function(node) {
		var grammar = node.getElementsByTagName('grammar');
		grammar = grammar[0];
		return grammar;
	};

	/**
	 * Recursive. Function which parses a Ximdoc DOMNode.
	 * @private
	 * @param {DOMNode} node Node tobe parsed
	 * @param {XimElement} parent Parent of the node that will be parsed
	 * @returns {XimElement}
	 */
	this._parseNode = function(node, parent) {

		if (!node || node.nodeType != 1) return;

		var parentUID = parent ? parent['uid'] : null;
		var ximElement = this.importXmlElement(node);
		ximElement = this.appendChild(ximElement, parent);
		if (!ximElement){
			this._errors.push(node.tagName);
			return false;
		}
		ximElement.isRoot = parent ? false : true;

		var it = new DOMNodeIterator(node, 1);
		while (it.hasNext()) {
			var child = it.next();
			this._parseNode(child, ximElement);
		}

		return ximElement;
	};

	/**
	 * Function which parses the DOMNode attributes
	 * @private
	 * @param {DOMNode} node Node to be parsed
	 * @returns {Array}
	 */
	this._parseAttributes = function(node) {

		var nodeName = node.tagName.toLowerCase();
		var attributes = node.attributes;
		var l = attributes.length;
		var attrs = {};
		var rngElement = this._rngDoc.getElement(nodeName);

		for (var i=0; i<l; i++) {

			var name = attributes[i].nodeName;
			var value = attributes[i].nodeValue;
			var htmlName = null;

			if (rngElement
				&& rngElement.attributes
				&& rngElement.attributes[name]) {

				htmlName = rngElement.attributes[name];

			}

			attrs[name] = value;
		}

		return attrs;
	};

	/**
	 * Function which returns a string that represents the node value.
	 * @private
	 * @deprecated Use {@link XimDocument#_getNodeArrayValue} instead.
	 */
	this._getNodeValue = function(node) {

		var it = new DOMNodeIterator(node);
		var value = '';
		while (it.hasNext()) {
			var child = it.next();
			if (child.nodeType == 3) {
				value += child.nodeValue;
			}
			if (child.nodeType == 1 && child.getAttribute('content') == 'yes') {
				value.concat(this._getNodeValue(child));
				//value += this._getNodeValue(child);
			}
		}
		return value;
	};

	/**
	 * Function which returns an array that represents the node value.
	 * @private
	 * @param {DOMNode} domnode
	 * @returns {Array}
	 */
	this._getNodeArrayValue = function(domnode) {

		// An array of values should be returned, because where will be as pieces of "value" as
		// node number of children + 1

		var it = new DOMNodeIterator(domnode);
		var value = [];
		var isFirstNode=true;
		var findApplyElement = false;
		var previousChild = false;
		while (it.hasNext()) {
                        var child = it.next();
			//nodetype==1 => is a tag
                        if (child.nodeType==1 && isFirstNode && child.getAttribute("uid")){
                                findApplyElement = true;
                        }

			//nodetype==3 => is text
                        if (child.nodeType == 3 || (previousChild.nodeType && previousChild.nodeType == 1)) {
                                if (findApplyElement){
                                        value.push("");
                                        findApplyElement = false;
                                }

                                value.push(child.nodeValue);
                        }

                        if (isFirstNode && (child.nodeType==3 || child.getAttribute("uid")))
                                isFirstNode=false;

                        // TODO: If child is editable and has children
                        // we have to return a structure instead a value.
                        var editable = child.nodeType == 1 ? (child.getAttribute('editable') || 'yes') : 'yes';

                        // TODO: Not working yet!
                        editable = 'no';

                        if (child.nodeType == 1 && editable.toLowerCase() != 'no') {
                                value = value.concat(this._getNodeArrayValue(child));
                        }

			previousChild = child;
                }
		// Correcting bug with apply elements when they are at the start of the string
		/*if (domnode.childNodes[0] && domnode.childNodes[0].nodeType != 3) {
			value.splice(0, 0, '');
		}*/

		return value;
	};


	// ---- API ----

	/**
	 * Function which returns the next unused UID for a new element.
	 * @private
	 * @returns {int}
	 */
	this._getNewUID = function(nodeId) {
		if (!nodeId)
			nodeId = this._nodeId;
		var uid = (this._lastUID[nodeId] === null || typeof(this._lastUID[nodeId]) == "undefined")
					? -1 : parseInt(this._lastUID[nodeId]);
		this._lastUID[nodeId] = ++uid;
		return nodeId + '.' + (uid);
	};

	/**
	 * Function which recursively assigns a UID to an element and all of his childrens.
	 * @param {XimElement} ximElement
	 */
	this.setElementUID = function(ximElement, parent) {
		if (!ximElement.uid) {
			// It is a new element
			var nodeId = ximElement.getIdNodeForUid(this._nodeId, parent);
			ximElement.uid = this._getNewUID(nodeId);
			ximElement.attributes.uid = ximElement.uid;
		}

		var count = ximElement.childNodes.length;
		for (var i=0; i<count; i++) {
			//if(!ximElement.attributes['ximlet_id'])
				this.setElementUID(ximElement.childNodes[i]);
		}
	};

	/**
	 * Function which returns an element of the ximModel structure with a specific UID.
	 * @param {int} uid
	 * @return {XimElement}
	 */
	this.getElement = function(uid) {
		var node = this._ximModel[uid] || null;
		return node;
	};

	/**
	 * Function which returns the root element of this Ximdoc
	 * @return {XimElement}
	 */
	this.getRootElement = function() {
		return this._rootNode;
	};

	/**
	 * Function which exports a XimElement to a DOMNode.
	 * Shortcut for {@link XimElement#toDomElement}.
	 * @param {int} uid
	 * @return {DOMNode}
	 */
	this.createElement = function(uid) {
		var elem = this.getElement(uid);
		return elem.toDomElement();
	};

	/**
	 * Function which transforms a XML DOMElement into a XimElement and returns it.
	 * @param {DOMNode} domElement XML node to transform.
	 * @param {boolean} importChilds If TRUE imports all domElement childrens.
	 * @returns {XimElement}
	 */
	this.importXmlElement = function(domElement, importChilds) {
		var tagName = domElement.tagName.toLowerCase();
		var rngElement = this._rngDoc.getElement(tagName);		
		if (!rngElement) {
			//console.error('Element <' + tagName + '/> not found in RNG Schema');
			return null;
		}

		var ximElement = new XimElement(rngElement);
		ximElement.uid = domElement.getAttribute('uid');
		ximElement.attributes = this._parseAttributes(domElement);

		var childs = rngElement.childNodes;
		var count = childs.length;
		ximElement.value = [];

		/**
		 * TODO: This method should not use a RNGElement element to obtain a node values because it is supposed to import a DOMElement.
		 *		 It should obtaing the values from XimDocument.importHtmlElement() or a specific function of de XimElement.
		 *		 The method XimDocument._getNodeArrayValue() returns the values of the children, but it should returns also the value of the element passed as argument.
		 *		 The current solution is using a RngElement to obtain this value.
		 */

		/*if (count == 0) {
			// Sol A
			// If the item has no children is assumed that must have a default content
	    	ximElement.value = [rngElement.defaultContent];
	    	//ximElement.value = [domElement.nodeValue];
    	} else {
			// Sol B
			// The item has a default structure content defined in Rng Model
    		ximElement.value.push(rngElement.defaultContent);
    		ximElement.value = ximElement.value.concat(this._getNodeArrayValue(domElement));
    	}*/

    	ximElement.value = this._getNodeArrayValue(domElement);

		if (importChilds) {
			for (var i=0; i<count; i++) {
				var child = childs[i];
				child = this.getRngDocument().createDomElement(child.tagName.toLowerCase());
				child = this.importXmlElement(child, true);
				ximElement.appendChild(child);
			}
		}

		return ximElement;
	};

	/**
	 * Function which transforms a HTML DOMElement into a XimElement of the "rngTagName" type and returns it.
	 * If rngTagName is NULL try to obtain the tagName using the uid.
	 * @param {DOMNode} domElement HTML node to transform.
	 * @param {string} rngTagName RNG element in which the DOMNode will be transformed.
	 * @returns {XimElement}
	 */
	this.importHtmlElement = function(domElement, rngTagName) {

		if (!rngTagName) {
			var uid = domElement.getAttribute('uid');
			var elem = this.getElement(uid);
			if (elem) {
				rngTagName = elem.tagName;
			} else {
				return null;
			}
		}

		rngTagName = rngTagName.toLowerCase();
		var rngElement = this._rngDoc.getElement(rngTagName);
		var ximElement = new XimElement(rngElement);

		ximElement.uid = domElement.getAttribute('uid');
		if (rngElement.tagName == 'ximlet') {
			ximElement.value = (domElement.ximElement.value.length > 0) ? [domElement.ximElement.value[0].trim()] : [''];
			ximElement.macro = domElement.ximElement.macro;
		} else {
			ximElement.value = this._getNodeArrayValue(domElement);
		}

		ximElement.attributes = {};
		var count = domElement.attributes.length;

		for (var i=0; i<count; i++) {

			var attribute = domElement.attributes[i];

			if (rngElement.htmlAttributes[attribute.nodeName]) {

				/*var xmlName = rngElement.htmlAttributes[attribute.nodeName].xmlName;

				var newAttribute = {
					htmlName: attribute.nodeName,
					value: attribute.nodeValue
				};

				ximElement.attributes[xmlName] = newAttribute;*/

				//console.warn('TODO: Se esta usando aun htmlAttributes?');
			}
		}

		return ximElement;
	};

	/**
	 * Function which inserts a new node in the ximModel structure.
	 * @param {XimElement} ximElement The element to insert.
	 * @param {XimElement} parent The parent node or NULL if ximElement is the root element.
	 * @param {XimElement} brother Optional, the node in which ximElement will be inserted before or after.
	 * @param {int} position Optional, The operation to perform: insert last, before or after the brother node.
	 * @returns {XimElement}
	 */
	this.appendChild = function(ximElement, parent, brother, position) {

		if (!ximElement) {
			//console.error('XimDocument::appendChild needs a ximElement object!.');
			return null;
		}

		if (!position) position = this.POSITION_LAST;
		if (typeof(parent) != 'object') parent = this.getElement(parent);

		if (!ximElement.uid) {
			// It is a new element
			this.setElementUID(ximElement, parent);
		} else {
			// Updating the last used UID
			var uidParts = ximElement.uid.split('.');
			var auxNodeID = parseInt(uidParts[0]);
			var auxID = parseInt(uidParts[1]);
			if (typeof(this._lastUID[auxNodeID]) == "undefined" || this._lastUID[auxNodeID] === null ||
				auxID > this._lastUID[auxNodeID])
				this._lastUID[auxNodeID] = auxID;
		}

		var uid = ximElement.uid;
		if (!this._ximModel[uid]) {

			if (parent) {
				// Root node allready exists...
				switch (position) {
					case this.POSITION_LAST:
						parent.appendChild(ximElement);
						break;
					case this.POSITION_BEFORE:
						parent.insertBefore(ximElement, brother);
						break;
					case this.POSITION_AFTER:
						parent.insertAfter(ximElement, brother);
						break;
				}
			}

			//this._ximModel[uid] = ximElement;
			this._updateModelWithElement(ximElement);

		} else {
			ximElement = this._ximModel[uid];
			//console.warn('Ya existe el uid = ' + uid, this._ximModel[uid]);
		}

		return ximElement;
	};

	/**
	 * Function which recursively updates the UIDs and elements registered in the model.
	 * @private
	 * @param {XimElement} ximElement Element to update.
	 */
	this._updateModelWithElement = function(ximElement) {
		this._ximModel[ximElement.uid] = ximElement;
		var count = ximElement.childNodes.length;
		for (var i=0; i<count; i++) {
			// Being sure of adding all the UIDs of the childrens to the model
			this._updateModelWithElement(ximElement.childNodes[i]);
		}
	};

	/**
	 * Function which inserts a new node in the structure before 'brother' object.
	 * @param {XimElement} ximElement The element to insert.
	 * @param {XimElement} parent The parent node or NULL if ximElement is the root element.
	 * @param {XimElement} brother Optional, the node in which ximElement will be inserted before.
	 * @returns {XimElement}
	 */
	this.insertBefore = function(ximElement, parent, brother) {
		var ximNode = this.appendChild(ximElement, parent, brother, this.POSITION_BEFORE);
		return ximNode;
	};

	/**
	 * Function which inserts a new node in the structure after 'brother' object.
	 * @param {XimElement} ximElement The element to insert.
	 * @param {XimElement} parent The parent node or NULL if ximElement is the root element.
	 * @param {XimElement} brother Optional, the node in which ximElement will be inserted after.
	 * @returns {XimElement}
	 */
	this.insertAfter = function(ximElement, parent, brother) {
		var ximNode = this.appendChild(ximElement, parent, brother, this.POSITION_AFTER);
		return ximNode;
	};

	/**
	 * Function which updates the content and the attribute values of the XimElement especified by the uid param
	 * @param {int} uid UID of the element to be updated.
	 * @param {XimElement} newElement Element with the new content.
	 * @returns {XimElement} A reference to the updated node.
	 */
	this.updateElement = function(uid, newElement) {

		var ximElement = this.getElement(uid);
		if (!ximElement) return null;

		ximElement.value = newElement.value;
		for (attrName in newElement.attributes) {
			if (attrName != 'uid') {
				ximElement.attributes[attrName] = newElement.attributes[attrName];
			}
		}

		this._ximModel[uid] = ximElement;
		return this.getElement(uid);
	};

	/**
	 * Function which clones the specified ximElement and appends it to a parent
	 * @param {XimElement} ximElement Element to clone.
	 * @param {XimElement} ximParent Parent of the cloned element.
	 * @returns {XimElement} A reference to the cloned node.
	 */
	this.cloneElement = function(ximElement, ximParent) {

		//ximParent = ximParent || this.getRootElement();

   		var rngElement = this.getRngDocument().getElement(ximElement.tagName);
    	var clonedElement = new XimElement(rngElement);

    	if (ximParent) {
    		clonedElement = this.appendChild(clonedElement, ximParent);
			clonedElement = this.updateElement(clonedElement.uid, ximElement);
		} else {
			clonedElement.value = ximElement.value;
			for (attrName in ximElement.attributes) {
				if (attrName != 'uid') {
					clonedElement.attributes[attrName] = ximElement.attributes[attrName];
				}
			}
			clonedElement.uid = null;
		}

		// Cloning children recursivelly
		var l = ximElement.childNodes.length;
		for (var i=0; i<l; i++) {
			this.cloneElement(ximElement.childNodes[i], clonedElement);
		}

		return clonedElement;
	};

	/**
	 * Function which removes a node and return a instance of the removed node if successfull.
	 * @param {XimElement} ximElement Element to be removed.
	 * @returns {XimElement} The removed node.
	 */
	this.removeChild = function(ximElement) {
		ximElement.parentNode.removeChild(ximElement);
		delete this._ximModel[ximElement.uid];
		return ximElement;
	};

	/**
	 * Function which validates the XML with the associated schema.
	 * This work is performed in the server for now.
	 *
	 *
	 * The callback function receives two parameters:
	 *  {boolean} valid -> Indicates if validation was successfull.
	 *  {string} msg -> Message with errors if valid = false.
	 *
	 * @param {function} callback Callback function that will be called after the server validation.
	 */
    this.validateXML = function(callback) {

		if (!this._schemaValidatorIsActive) {
			callback(true, '');
			return;
		}

    	var content = this.saveXML({
			asString: true,
			hideXimlets: true
    	});

		var encodedContent = "content=" + encodeURIComponent(content);

		// XML validation on the server
		com.ximdex.ximdex.editors.ValidateHandler(kupu.getBaseURL(), encodedContent, {
			onComplete: function(req, json) {
				var msg = null;
				if (!json.valid) {
					msg = _("Document cannot be validated!");

					if (json.errors) {
						msg = msg+"\n\n"
						var l = json.errors.length;
						for (var i=0; i<l; i++) {
							msg += '-\n\n' + json.errors[i] + '\n';
						}
					}
				}
				if (typeof(callback) == 'function') callback(json.valid, msg);
			},
			onError: function(req) {
				if (typeof(callback) == 'function') callback(false, _("Document cannot be validated!"));
			}
		});
	};

	/**
	 * Function which exports a XimDocument object into a DOMDocument object or, optionally, to a XML string.
	 * @param {boolean} asString Exports to a XML string instead a DOMDocument.
	 * @returns {DOMDocument | string}
	 */
	this.saveXML = function(options) {

		options = Object.extend({
			asString: false,
			hideXimlets: false,
			resolveXimlinks: false,
			onCreateNode: null
		}, options);

		this._exportDoc = null;
		this._exportDoc = this.editor.createDomDocument();
		if (!this._exportDoc) return null;

		// getting the docxap element...
		var docxap = this.getRootElement();
		if (!docxap) return null;

		docxap = this._reverseParseNode(docxap, null, options);
		this._exportDoc.appendChild(docxap);

		var ret = this._exportDoc;
		if (options.asString) ret = new XMLSerializer().serializeToString(ret);

		return ret;
	};

	/**
	 * Called by {@link XimDocument#saveXML}.
	 * Function which exports a XimElement into a DOMNode.
	 * @private
	 * @param {XimElement} element
	 * @param {DOMNode} parent
	 */
	this._reverseParseNode = function(element, parent, options) {

		// NOTE: This way of exporting the document is the most correct but causes that the tagNames were in capitals ???
		//
		// Fixed: http://www.w3.org/TR/DOM-Level-2-Core/core.html#Namespaces-Considerations
		// "... For HTML, the tagName parameter may be provided in any case, but it must be mapped to the canonical uppercase form by the DOM (Level 1) implementation ..."
		//
		// Methods createElementNS() and createAttributeNS() "... are meant to be used by namespace aware applications ..."


		options = Object.extend({
			hideXimlets: false,
			resolveXimlinks: false,
			onCreateNode: null
		}, options);

		var node = element.toDomElement(this._exportDoc);
		var count = element.childNodes.length;

		if (options.resolveXimlinks && element.ximLink) {

			node.setAttribute('__ximlink_idnode__', element.ximLink.nodeid);
			node.setAttribute('__ximlink_idchannel__', element.ximLink.channel);
			node.setAttribute('__ximlink_name__', element.ximLink.name);
			node.setAttribute('__ximlink_url__', element.ximLink.url);
			node.setAttribute('__ximlink_text__', element.ximLink.text);
			node.setAttribute('__ximlink_folder__', element.ximLink.folder);

//			console.log(node);
		}

		for (var i=0; i<count; i++) {
			var child = element.childNodes[i];
			if(!options.hideXimlets || !child.isSectionXimlet())
				child = this._reverseParseNode(child, node, options);
		}

		if (parent) {

			// Mapping the ximElement "value" attribute with the "childNodes" array and obtaining the real content.
			var count = parent.childNodes.length;
			var nodeTypeAcum = 0;
			var nextBrother = null;
			for (var i=(count-1); i>=0; i--) {
				if(nodeTypeAcum != parent.childNodes[i].nodeType) {
					nodeTypeAcum = parent.childNodes[i].nodeType;
				} else if(nodeTypeAcum == 3) {
					nextBrother = parent.childNodes[i+1];
				}
			}

			if(!parent.attributes['ximlet_id'] || !options.hideXimlets) {
				parent.insertBefore(node, nextBrother);
			} else if (nextBrother && nextBrother.nodeType == 3) {
				parent.insertBefore(node, nextBrother);
			}
		}

		if (Object.isFunction(options.onCreateNode)) {
			node = options.onCreateNode(node, element, options);
		}
		return node;
	};

	/**
	 * @deprecated Called by {@link XimDocument#_reverseParseNode}.
	 * @private
	 */
	this._reverseParseAttributes = function(node, element) {

		var rngElement = this.getRngModel()[element.tagName];
		var attributes = element.attributes;

		for (var attrName in attributes) {
			// NOTE:
			//		MSIE attributes returns ALL the object attributes, user defined and language defined attributes.
			//		FF attributes only returns user defined attributes.
			//		We need to double check if the attribute exists as an "user attribute".
			//		The <docxap/> tag is a special case.
			if (rngElement.attributes[attrName] || rngElement.tagName == 'docxap') {
				var attrValue = attributes[attrName];
				try {
					node.setAttribute(attrName, attrValue);
				} catch(e) {
					//console.error('%s.setAttribute(%s, %s)', element.tagName, attrName, attrValue);
				}
			} else {
				//console.info('Attribute not defined in RNG schema: %s.%s = %s', rngElement.tagName, attrName, attributes[attrName].value);
			}
		}

		return node;
	};

	/**
	 * Function which scrolls up the element in the hierachy.
	 */
	this.scrollUp = function() {
		// implement me
	},

	/**
	 * Function which scrolls down the element in the hierachy.
	 */
	this.scrollDown = function() {
		// implement me
	}

}
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



/**
 * Representation of a XML ximdoc element, needs a RngElement as a template.
 * For the creation of an existing XML element use {@link XimDocument#importXmlElement}
 * For the creation of an existing HTML element use {@link XimDocument#importHtmlElement}
 * @constructor
 */
XimElement = function(rngElement, importChildElements, ancestors) {

	this.tagName = null;
	this.uid = null;
	this.parentNode = null;
	this.previousSibling = null;
	this.nextSibling = null;
	this.childNodes = [];
	this.attributes = {};
	this.defaultContent = '';
	this.value = [];
	this.schemaNode = null;
	this.isRoot = false;
	this._htmlElements = [];

	/**
	 * Function which initializes a new instance.
	 * @private
	 * @param {RngElement} rngElement A RngElement as a template for the new XimElement.
	 */
	this._initialize = function(rngElement, importChildElements, ancestors) {

		if (!rngElement) return;

		this.tagName = rngElement.tagName.toLowerCase();
		this.schemaNode = rngElement;
		this.defaultContent = rngElement.defaultContent;
		this.value = [rngElement.defaultContent];

		var attributes = rngElement.attributes;

		for (var attrName in attributes) {
			if (attributes[attrName] && typeof(attributes[attrName]) == 'object') {
				this.attributes[attrName] = '';
			}
		}

		if (importChildElements && (!ancestors || !ancestors.contains(rngElement.tagName))) {		
			this._importChildElements(this, rngElement, ancestors);
		}
	};

	this._importChildElements = function(ximElement, rngElement, ancestors) {
		var count = rngElement.childNodes.length;
		for (var i=0; i<count; i++) {
			if (ancestors) {
				var ancestorsbase = ancestors;
				if (!ancestors.contains(rngElement.tagName)) ancestorsbase.push(rngElement.tagName);
			} else {
				var ancestorsbase = [rngElement.tagName];
			}
			if (!rngElement.childNodes[i].isOptional){

			    var child = new XimElement(rngElement.childNodes[i], false, ancestorsbase);
			    ximElement.appendChild(child);
			}
		}
	};

	/**
	 * Function which inserts a XimElement as a child node of this instance.
	 * @param {XimElement} child The XimElement to insert.
	 */
	this.appendChild = function(child) {
		child.parentNode = this;
		this.childNodes.push(child);
		var childCount = this.childNodes.length;
		if (this.childNodes[childCount - 2]) {
			child.previousSibling = this.childNodes[childCount - 2];
			this.childNodes[childCount - 2].nextSibling = child;
		}
	};

	/**
	 * Function which inserts a XimElement as a child node of this instance and before the specified brother.
	 * @param {XimElement} child The XimElement to insert.
	 * @param {XimElement} brother The brother of the new child.
	 */
	this.insertBefore = function(child, brother) {
		child.parentNode = this;
		var newChildNodes = [];
		var count = this.childNodes.length;
		for (var i=0; i<count; i++) {
			var item = this.childNodes[i];
			if (item.uid == brother.uid) {
				newChildNodes.push(child);
				newChildNodes.push(item);
			} else {
				newChildNodes.push(item);
			}
		}
		child.nextSibling = brother;
		child.previousSibling = brother.previousSibling;
		if (brother.previousSibling) brother.previousSibling.nextSibling = child;
		brother.previousSibling = child;
		this.childNodes = newChildNodes;
	};

	/**
	 * Function which inserts a XimElement as a child node of this instance and after the specified brother.
	 * @param {XimElement} child The XimElement to insert.
	 * @param {XimElement} brother The brother of the new child.
	 */
	this.insertAfter = function(child, brother) {
		child.parentNode = this;
		var newChildNodes = [];
		var count = this.childNodes.length;
		for (var i=0; i<count; i++) {
			var item = this.childNodes[i];
			if (item.uid == brother.uid) {
				newChildNodes.push(item);
				newChildNodes.push(child);
			} else {
				newChildNodes.push(item);
			}
		}
		child.previousSibling = brother;
		child.nextSibling = brother.nextSibling;
		if (brother.nextSibling) brother.nextSibling.previousSibling = child;
		brother.nextSibling = child;
		this.childNodes = newChildNodes;
	};

	/**
	 * Function which removes a child node of this instance.
	 * @param {XimElement} child The XimElement to remove.
	 */
	this.removeChild = function(child) {
		var newChildNodes = [];
		var count = this.childNodes.length;
		for (var i=0; i<count; i++) {
			var item = this.childNodes[i];
			if (item.uid != child.uid) {
				newChildNodes.push(item);
			}
		}
		if(child.previousSibling) {
			child.previousSibling.nextSibling = child.nextSibling;
		}
		if(child.nextSibling) {
			child.nextSibling.previousSibling = child.previousSibling;
		}
		this.childNodes = newChildNodes;
	};

	/**
	 * Function which splits an element of the 'value' array in two elements based in a specific position.
	 * @param {int} position
	 */
	this.splitValue = function(position) {
		var key = this.getValueKeyByPosition(position);
		var relativePosition = position - this.getValueString(key).length;
		var pieces = [];
		pieces[0] = this.value[key].substring(0,relativePosition + 1);
		pieces[1] = this.value[key].substring(relativePosition + 1);
		this.value.splice(key, 1, pieces[1]);
		this.value.splice(key, 0, pieces[0]);
	}

	/**
	 * Function which returns a string that represents the real value of the element.
	 * If a key is given, returns string only since previous key.
	 * @param {int} key
	 * @returns {string}
	 */
	this.getValueString = function(key) {
		var val = '';
		var count = this.value.length;
		for (var i=0; i<count; i++) {
			if(i == key)
				return val;
			val += this.value[i];
		}
		return val;
	}

	/*
	 * Function which returns value key given a position.
	 * @param {int} position
	 * @returns {int}
	 */
	this.getValueKeyByPosition = function(position) {
		var length = 0;
		var count = this.value.length;
		for (var i=0; i<count; i++) {
			length += this.value[i].length;
			if(length > position)
				return i;
		}
		return (count - 1);
	}

	/*
	 * Function which returns position respect siblings.
	 * @returns {int}
	 */
	this.getSiblingPosition = function () {
		var position = 0;
		var sibling = this;
		while (sibling.previousSibling) {
			position ++;
			sibling = sibling.previousSibling;
		}
		return position;
	}

	/**
	 * Function which exports this XimElement instance into a DOMNode using the specified DOMDocument
	 * or the IFrame DOMDocument if not passed.
	 * @param {DOMDocument} doc Optional, DOMDocument to use for DOMNode creation.
	 * @returns {DOMNode}
	 */
	this.toDomElement = function(doc) {

		/** Export function **/
		doc = doc || document;
		var domelement = doc.createElement(this.tagName.toLowerCase());
		var attributes = this.attributes;
		for (var attrName in attributes) {
			var attrValue = attributes[attrName];
			try {
				domelement.setAttribute(attrName, attrValue);
			} catch(e) {
				//console.log(attrName, attrValue);
			}
		}

		var value = null;
		if (this.macro && this.schemaNode.type == 'ximlet') {
			value = [this.macro];
		} else {
			value = this.value ? this.value : '';
		}

		var l = value.length;
		for (var i=0 ; i<l; i++) {
			var textNode = doc.createTextNode(value[i] || '');
			domelement.appendChild(textNode);
		}

		return domelement;
	};

	/**
	 * Function which scrolls up the element in the hierachy.
	 * @returns {boolean} TRUE if scroll is allowed in the actual position.
	 */
	this.scrollUp = function() {
		var brotherPos = this.findNextAllowedPosition('up');
		if (brotherPos !== null) {
			var pos = this.getElementIndex();
			var aux = this.parentNode.childNodes[brotherPos];
			this.parentNode.childNodes[brotherPos] = this;
			this.parentNode.childNodes[pos] = aux;
			return true;
		}
		return false;
	},

	/**
	 * Function which scrolls down the element in the hierachy.
	 * @returns {boolean} TRUE if scroll is allowed in the actual position.
	 */
	this.scrollDown = function() {
		var brotherPos = this.findNextAllowedPosition('down');
		if (brotherPos !== null) {
			var pos = this.getElementIndex();
			var aux = this.parentNode.childNodes[brotherPos];
			this.parentNode.childNodes[brotherPos] = this;
			this.parentNode.childNodes[pos] = aux;
			return true;
		}
		return false;
	},

	/**
	 * Function which returns if an element can be copied or cutted.
	 * @returns {boolean} TRUE if ximElement can be copied or cutted.
	 */
	this.canBeCopied = function() {
		if(this.isSectionXimlet())
			return false;
		return true;
	},

	/**
	 * Function which returns if an element can be removed.
	 * @returns {boolean} TRUE if ximElement is removable.
	 */
	this.isRemovable = function() {
		if (this.isSectionXimlet() || this.isRoot) {
			return false;
		}
		return true;
	},

	/**
	 * Function which returns if an element is a 'section' ximlet.
	 * @returns {boolean} TRUE if ximElement is a 'section' ximlet.
	 */
	this.isSectionXimlet = function() {
		if(this.attributes['section_ximlet'] && this.attributes['section_ximlet'] == 'yes') {
			return true;
		}
		return false;
	},

	/**
	 * Function which returns if an element is selectable.
	 * @returns {boolean} TRUE if ximElement is selectable.
	 */
	this.isSelectable = function(docNodeId) {
		if(this.uid.indexOf(docNodeId) == -1)
			return false;
		return true;
	},

	/**
	 * Function which returns if an element is applyable.
	 * @returns {boolean} TRUE if ximElement is apply type.
	 */
	this.isApplyable = function() {
		if(this.schemaNode.type.contains('apply'))
			return true;
		return false;
	},

	this.disApply = function(preserveTextContent) {
		if(!this.isApplyable) return;

		// Joining previous and next string elements before disApplying ximElement

		var value = this.parentNode.value;
		var children = this.parentNode.childNodes;
		var length = value.length;
		var i = 0;
		while (i<length) {
			if (children[i] && children[i].uid == this.uid) {
				var val1 = value[i] || '';
				var val2 = value[i+1] || '';
				value.splice(i, 2, val1 + val2);

				var element = $('[uid="'+this.uid+'"]', kupu.getBody())[0];
				var parent = element.parentNode;
				var previous = element.previousSibling;
				var next = element.nextSibling;

				if ((previous && previous.nodeType == 3) || (next  && next.nodeType == 3)) {
					val1 = previous ? previous.nodeValue || '' : '';
					val2 = next ? next.nodeValue || '' : '';
					parent.insertBefore(document.createTextNode(val1 + (preserveTextContent ? this.value : '') + val2), previous);
					if (previous)
					    parent.removeChild(previous);
					if (next)
					    parent.removeChild(next);
				} //if the apply contains the whole word
                                else if(val1 == "" && val2 == ""){
                                        parent.insertBefore(document.createTextNode((preserveTextContent ? this.value : '')), previous);
                                        parent.removeChild(previous);
                                        parent.removeChild(next);
                                }
                                //Tree view FIX
                                else{
                                        element = $('[uid="'+this.uid+'"]', kupu.getBody())[0].parentNode;
                                        parent = element.parentNode;
                                        previous = element.previousSibling;
                                        next = element.nextSibling;

                                        if (previous && next && previous.nodeType == 3 && next.nodeType == 3) {
                                                val1 = previous.nodeValue;
                                                val2 = next.nodeValue;
                                                parent.insertBefore(document.createTextNode(val1 + (preserveTextContent ? this.value : '') + val2), previous);
                                                parent.removeChild(previous);
                                                parent.removeChild(next);
                                        }
                                }


				parent.removeChild(element);
				i = length;
			}
			i++;
		}

		return this;
	}

	/**
	 * Function which returns if an element is droppable.
	 * @returns {boolean} TRUE if ximElement is droppable.
	 */
	this.isDroppable = function(docNodeId) {
		return this.isSelectable(docNodeId);
	},

	/**
	 * Function which returns first selectable parent.
	 * @returns {ximElement} First selectable parent.
	 */
	this.getFirstSelectableParent = function(docNodeId) {
		if(!this.parentNode)
			return null;
		var parentNode = this.parentNode;
		if(!parentNode.isSelectable(docNodeId))
			return parentNode.getFirstSelectableParent(docNodeId);
		return parentNode;
	},

	/**
	 * Function which returns first parent with 'document' uid.
	 * @returns {ximElement} First parent with 'document' uid.
	 */
	this.getFirstParentWithDocumentUid = function(docNodeId) {
		if(!this.parentNode)
			return this;
		var parentNode = this.parentNode;
		var parentUid = parentNode.uid;
		if(!parentUid || parentUid.indexOf(docNodeId) == -1)
			return parentNode.getFirstParentWithDocumentUid(docNodeId);
		return parentNode;
	},

	/**
	 * Function which finds the next position where the XimElement is allowed, always under the same parent.
	 * TODO: It's needed an implementation of <choice/> and cardinallity in RngDocument!
	 * TODO: previousSibling and nextSibling is missed here
	 * @param {string} direction [up|down] string.
	 * @returns {int} The new position of the element.
	 */
	this.findNextAllowedPosition = function(direction) {
		if(this.isSectionXimlet())
			return null;

		if (!direction) direction = 'up';
		direction = direction.toLowerCase();

		var pos = this.getElementIndex();
		if (direction == 'up') {
			pos--;
		} else if (direction == 'down') {
			pos++;
		}

		var brother = this.parentNode.childNodes[pos];
		if(!brother || brother.isSectionXimlet())
			return null;
		var rngElement = this.schemaNode;
		var rngParent = this.parentNode.schemaNode;
		var rngBrother = brother ? brother.schemaNode : null;

		if (!brother || !rngElement.isAllowedUnder(rngParent, rngBrother)) {
			return null;
		}

		return pos;
	};

	/**
	 * Function which finds the index of this element in the parent childNodes array.
	 * NOTE: A replace for previousSibling and nextSibling???
	 * @returns {int}
	 */
	this.getElementIndex = function() {
		var parent = this.parentNode;
		var pos = -1;
		var i = 0;
		while (pos<0 && i<parent.childNodes.length) {
			if (parent.childNodes[i].uid == this.uid) pos = i;
			i++;
		}
		return pos;
	};

	this.getHtmlElements = function(editable) {
		// editable == undefined	-> All
		// editable == true			-> Editables
		// editable == false		-> No Editables
		var elems = $(this._htmlElements);
		if (editable === true) {
			elems = elems.not('[editable=no]');
		} else if (editable === false) {
			elems = elems.filter('[editable=no]');
		}
		return elems;
	};

	this.getIdNodeForUid = function(docNodeId, parent) {
		if(this.isRoot)
			return docNodeId;
		var parentNode = this.parentNode ? this.parentNode : parent;
		if(!parentNode)
			return docNodeId;
		var parentUid = parentNode.uid;
		if(!parentUid || parentUid.indexOf(docNodeId) == -1)
			return parentNode.getIdNodeForUid(docNodeId, (parentNode.parentNode) ? parentNode.parentNode : null);
		var ximletId = parentNode.attributes['ximlet_id'];
		return (ximletId) ? ximletId : docNodeId;
	}

	this._initialize(rngElement, importChildElements, ancestors);
};
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


/**
 *  Function which loads a RelaxNG schema into a javascript object.
 *	NOTE: XPath implementation: http://js-xpath.sourceforge.net/
 * @constructor
 */
RngDocument = function() {

	this.XMLNS_RNG = 'http://relaxng.org/ns/structure/1.0';
	this.VALID_XIM_ATTRS = ['type'];

	this._xmldoc = null;
	this._schemaModel = null;
	this._parsedRefs = [];

	/**
	 * Function which returns the RNG model object.
	 * @returns {object}
	 */
	this.getModel = function() {
		return this._schemaModel;
	};

	/**
	 * Function which returns the instance of the parsed RNG document.
	 * @returns {DOMDocument}
	 */
	this.getXmlDocument = function() {
		return this._xmldoc;
	};

	/**
	 * Function which starts to parse a new RNG document.
	 * @param {DOMDocument} xmldoc XML document
	 */
	this.loadXML = function(xmldoc) {

		// We need to map the default namespace to a prefix for XPath queries to work.
		// Use this method only if the document has a default namespace without a prefix.
		Sarissa.setXpathNamespaces(xmldoc, 'xmlns:rng="%s" xmlns:xim="%s"'.printf(this.XMLNS_RNG, X.XMLNS_XIM));

		// There is a problem using jQuery selectors over a XML DOM document on IE,
		// the solution is using the Sarissa XPath implementation.
		//
		// NOTE: The following two lines are needed for IE.
		// NOTE: The xmlns:xim namespace value MUST BE equal to what is defined in the RNG document.
		// Use setProperty() if you are not using setXpathNamespaces().
		xmldoc.setProperty('SelectionLanguage', 'XPath');
//		xmldoc.setProperty('SelectionNamespaces', 'xmlns:rng="%s" xmlns:xim="%s"'.printf(this.XMLNS_RNG, X.XMLNS_XIM));

		this._xmldoc = xmldoc.firstChild;
		this._schemaModel = {};

		var start = this._findStartElement(this._xmldoc);
		if (start !== null) this._parse_element(start, null,false);
	};

	/**
	 * Function wich finds the first element (or root node) in the document.
	 * @private
	 * @param {DOMNode} node
	 * @returns {DOMNode}
	 */
	this._findStartElement = function(node) {

		var xpath = '//rng:start/rng:element[@name="docxap"]';
		var docxap = this._xmldoc.selectNodes(xpath);
		docxap = docxap[0] || null;
		return docxap;
	};

	/**
	 * Recursive method that will parse a XML node.
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 * @param {boolean} isOptional
	 */
	this._parseNode = function(node, parent, isOptional) {

		if (!node) return;

		var it = new DOMNodeIterator(node, 1);
		while (it.hasNext()) {
			var child = it.next();
			// Replace the colons of namespaces
			var method = '_parse_' + child.tagName.replace(':', '_');
			if (this[method]) {
				this[method](child, parent, isOptional);
				this._parseNodeXimAttributes(child, parent, isOptional);
			} else {
				console.info("method '" + method + "' don't exists!");
			}
		}

		if (!['define', 'oneOrMore', 'zeroOrMore', 'optional'].contains(node.tagName)) this._parseNode(node.nextSibling, parent);
	};

	/**
	 * Function which parses attributes in the Ximdex namespace
	 * TODO: Improving this algorithm, now it is only processing successfully
	 * the tag attribute <attribute/>. It should process any tag attribute
	 * in order to give semantic to the RNG schema.
	 *
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parseNodeXimAttributes = function(node, parent) {

		for (var i=0,l=this.VALID_XIM_ATTRS.length; i<l; i++) {

			var attrName = this.VALID_XIM_ATTRS[i];
			var attr = node.attributes.getNamedItemNS(X.XMLNS_XIM, attrName);

			if (attr !== null) {
				var name = node.getAttribute('name');
				// Only if "name" is an attribute of an element.
				if (parent.attributes[name]) {
					parent.attributes[name][attrName] = attr.value;
				}
//				console.log(node.getAttribute('name'), attr, node, parent);
			}
		}
	};

	// Parsers

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_oneOrMore = function(node, parent, isOptional) {
		this._parseNode(node, parent, isOptional);
	};

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_zeroOrMore = function(node, parent, isOptional) {
		this._parseNode(node, parent, true);
	};

	this._parse_optional = function(node, parent, isOptional) {
		this._parseNode(node, parent, true);
	};

	this._parse_interleave = function(node, parent, isOptional) {
		this._parseNode(node, parent, isOptional);
	};

	this._parse_data = function(node, parent, isOptional) {
		this._parseNode(node, parent, isOptional);
	};

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_ref = function(node, parent, isOptional) {

		var defineName = node.getAttribute('name');

		if(!this._parsedRefs[parent.tagName])
			this._parsedRefs[parent.tagName] = [];
		if(this._parsedRefs[parent.tagName].contains(defineName))
			return null;
		this._parsedRefs[parent.tagName].push(defineName);

		var xpath = '/rng:grammar/rng:define[@name="%s"]'.printf(defineName);
		var define = this._xmldoc.selectNodes(xpath);
		define = define[0] || null;
//		console.log(xpath, define);

		if (define)
			this._parseNode(define, parent, isOptional);

	};

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_element = function(node, parent, isOptional) {

		if (node.nodeType != 1 || !node.getAttribute('name')) return;

		var name = node.getAttribute('name').toLowerCase().replace(":", "_");

		if (!this._schemaModel[name]) {

			//NOTE: It is controled if the element already exists to not being added to the father childNodes array more than once.
			//NOTE: With this correction, the "Named Patterns" would not be reused between different elements.
			//TODO: Locating the moment in which an element <ref/> nested to an element <define/> is called several times.
			//TODO: Fixing the previous point, this problem will be solved.
			this._schemaModel[name] = new RngElement(name, isOptional);
		}
		/*else{
                        this._schemaModel[name].isOptional == this._schemaModel[name].isOptional && isOptional;
                }*/

		if (parent != null) {
			this._schemaModel[name].parentNode = parent;
			this._schemaModel[name].parents.push(parent.tagName);
			parent.childNodes.push(this._schemaModel[name]);
		}

		this._parseNode(node, this._schemaModel[name], false);
	};

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_attribute = function(node, parent) {
		var name = node.getAttribute('name');
		parent.attributes[name] = {};
		parent.attributes[name]['values'] = {};
		parent.attributes[name]['type'] = null;
		this._parse_attribute_values(node, parent);
//		this._parse_xim_attributetype(node, parent);
	};

	/**
	 * Called by {@link RngDocument#_parse_attribute}
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_attribute_values = function(node, parent) {

		var name = node.getAttribute('name');
		var values = node.selectNodes('./rng:choice/rng:value/text()');
		parent.attributes[name]['values'] = $(values).map(function(index, node) {
			return node.nodeValue;
		});
//		console.log(parent.attributes[name]['values']);
	}

	/**
	 * function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_choice = function(node, parent, isOptional) {
		this._parseNode(node, parent, isOptional);
	}

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_interleave = function(node, parent, isOptional) {
		this._parseNode(node, parent, isOptional);
	}

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_text = function(node, parent, isOptional) {
		// nothing...
	};

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
//	this._parse_xim_attribute_relations = function(node, parent) {
//		// NOTE: ximdex namespace
//		this._parseNode(node, parent);
//	}

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_xim_attribute = function(node, parent, isOptional) {
		// NOTE: ximdex namespace
		var ptdName = node.getAttribute('name');
		var htmlName = node.getAttribute('value');
		if (parent.attributes[ptdName]) {
			parent.attributes[ptdName]['htmlName'] = htmlName;

			// NOTE: htmlAttributes array is not usefull at the moment!!!
			//parent.htmlAttributes[htmlName] = {xmlName: ptdName};
		}
	}

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_xim_default_content = function(node, parent, isOptional) {
		// NOTE: ximdex namespace
		var l = node.childNodes.length;
		if(l > 0) {
			parent.defaultContent = node.childNodes[0].nodeValue;
		}
	}

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
//	this._parse_xim_attributetype = function(node, parent) {
//		var name = node.getAttribute('name');
//		var value = node.selectSingleNode('./xim:attributetype/text()');
//		parent.attributes[name]['type'] = value ? value.data : null;
//	}

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_xim_type = function(node, parent, isOptional) {
		// NOTE: ximdex namespace
		var l = node.childNodes.length;
		if(l > 0) {
			parent.type = node.childNodes[0].nodeValue.split('|');
		}
	}

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_xim_description = function(node, parent, isOptional) {
		// NOTE: ximdex namespace
		var l = node.childNodes.length;
		if(l > 0) {
			//console.log(node.childNodes[0].nodeValue, "-->", window.i18n_message_catalog.translate(node.childNodes[0].nodeValue)  );
		//	parent.description = window.i18n_message_catalog.acents(window.i18n_message_catalog.translate(node.childNodes[0].nodeValue) );
			parent.description = node.childNodes[0].nodeValue;
		}
	}

	/**
	 * Function which parses a specific RNG tag
	 * @private
	 * @param {DOMNode} node Node to parse
	 * @param {RngElement} parent Parent element on the RNG model
	 */
	this._parse_xim_wizard = function(node, parent) {
		// NOTE: ximdex namespace
		parent.wizard = node.firstChild.nodeValue.trim();
	}

	// ----- API -----

	/**
	 * Function which returns the RngElement asociated with a tagName
	 * @param {string} tagName
	 * @returns {RngElement}
	 */
	this.getElement = function(tagName) {
		tagName = tagName.replace(':', '_');

		return this._schemaModel[tagName] || null;
	};

	/**
	 * Function which returns a DOMElement represented by the RngElement.<br>
	 * This is a shortcut for {@link RngElement#toDomElement}.
	 * @param {string} tagName
	 * @returns {DOMNode}
	 */
	this.createDomElement = function(tagName) {
		var elem = this.getElement(tagName);
		return elem.toDomElement();
	};

	/**
	 * Function which validates a XML document with this RNG.<br>
	 * Not implemented.
	 */
	this.validate = function(node) {
		// Create RNGValidator.class.js ......
	};

	/**
	 * Function which returns an array of rngElements tagNames with a specified type.
	 * @param {string} type
	 * @returns {array string}
	 */
	this.getRngElementNameByType = function(type) {

		var xpath = '//xim:type[contains(., "%s")]/ancestor::rng:element[1]'.printf(type);
		var nodes = this._xmldoc.selectNodes(xpath);

		nodes = $(nodes).map(function(index, node) {
			return node.getAttribute('name');
		});

		return nodes;
	};

	/**
	 * Function which returns an array of rngElements tagNames than can be parents of 'elementName'.
	 * @param {string} elementName
	 * @returns {array string}
	 */
	this.getAllowedParents = function(elementName) {

		if(this._schemaModel[elementName])
			return this._schemaModel[elementName].getAllowedParents();
		else
			return [];
	};

}
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


/**
 * Function which represents a RNG Element
 * @constructor
 * @param {string} tagName The name of the element we want to instantiate.
 */
RngElement = function(tagName, isOptional) {

	this.tagName = null;
	this.parentNode = null;
	this.childNodes = [];
	this.attributes = {};
	this.htmlAttributes = {};
	this.defaultContent = null;
	this.type = [];
	this.description = null;
	this.parents = [];
	this.isOptional = true;

	/**
	 * Function which initializes a new instance.
	 * @private
	 * @param {string} tagName The name of the element we want to instantiate.
	 */
	this._initialize = function(tagName, isOptional) {
		this.tagName = tagName.toLowerCase();
		this.description = this.tagName;
		this.isOptional = isOptional;
	};

	/**
	 * Function which exports this element to a DOMNode element.
	 * @returns {DOMNode}
	 */
	this.toDomElement = function() {

		var domelement = document.createElement(this.tagName.toLowerCase());
		var attributes = this.attributes;

		for (var attrName in attributes) {
			domelement.setAttribute(attrName, '');
		}

		return domelement;
	};

	/**
	 * Function which checks if this element is allowed under the specified parent node and after the specified brother.
	 * @param {RngElement} rngParent Parent node.
	 * @param {RngElement} rngBrother Brother node.
	 * @returns {boolean}
	 */
	this.isAllowedUnder = function(rngParent, rngBrother) {
		// TODO: It's needed an implementation of <choice/>, cardinallity and position restrictions in RngDocument!
		// TODO: Implement checks for rngBrother element...
		return (this.parents.contains(rngParent.tagName) && !(rngParent.type.contains('ximlet'))) ? true : false;
	};

	/**
	 * Function which checks if this element is allowed nearby the specified node.
	 * @param {RngElement} rngNode Parent node.
	 * @returns {boolean}
	 */
	this.isAllowedNearBy = function(rngNode) {
		var allowed = false;
		this.parents.each(function(index, elem) {
			if(rngNode.parents.contains(elem))
				allowed = true;
		});
		return allowed;
	};

	/**
	 * Function which returns an array of rngElements tagNames than can be parents of this element.
	 * @returns {array string}
	 */
	this.getAllowedParents = function() {

		return this.parents;
	};

	this._initialize(tagName, isOptional);
}
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


/*****************************************************************************
 *
 * Copyright (c) 2003-2005 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id$


//----------------------------------------------------------------------------
// ContextMenu
//----------------------------------------------------------------------------

contextmenu_selNode = null;
contextmenu_selection = null;
function ContextMenu() {
    /* the contextmenu */
    this.contextmenu = null;
    this.seperator = 1;

    this.initialize = function(editor) {
        /* setting the event handlers and such */
        this.editor = editor;
        // needs some work since it won't work for more than one editor
        addEventHandler(editor.getInnerDocument(), "contextmenu", this.createContextMenu, this);
        addEventHandler(editor.getInnerDocument(), "focus", this.hideContextMenu, this);
        addEventHandler(document, "focus", this.hideContextMenu, this);
        addEventHandler(editor.getInnerDocument(), "mousedown", this.hideContextMenu, this);
        addEventHandler(document, "mousedown", this.hideContextMenu, this);
    };

    this.createContextMenu = function(event) {
        /* Create and show the context menu

            The method will ask all tools for any (optional) elements they
            want to add the menu and when done render it
        */
        if (this.editor.getBrowserName() == 'IE') {
        	event.cancelBubble = true;
            this.editor._saveSelection();
        } else {
	        event.returnValue = false;
	        if (event.preventDefault)
	        	event.preventDefault();
			event.stopPropagation();
        }
        event.returnValue = false;
        // somehow Mozilla on Windows seems to generate the oncontextmenu event
        // several times on each rightclick, here's a workaround
        if (this.editor.getBrowserName() == 'Mozilla' && this.contextmenu) {
            return false;
        };
        var selNode = this.editor.getBrowserName() == 'IE'
        	? event.srcElement
        	: this.editor.getSelectedNode();

			contextmenu_selNode = selNode;
			contextmenu_selection =  this.getSelection();

			this.hideContextMenu();

        var elements = new Array();
        for (var id in this.editor.tools) {
            var tool = this.editor.tools[id];
            // alas, some people seem to want backward compatibility ;)
            if (tool.createContextMenuElements) {
                var els = tool.createContextMenuElements(selNode, event);
                elements = elements.concat(els);
            };
        };
        // remove the last seperator
        this._createNewContextMenu(elements, event);
        this.last_event = event;

        return false;
    };

    this.hideContextMenu = function(event) {

		 /* remove the context menu from view */
        if (this.contextmenu) {

            try {
					var iframe = this.editor.getDocument().getEditable();
					var left = event.clientX;
					var top = event.clientY;

					var currnode = iframe;
					if (this.editor.getBrowserName() == 'IE') {
						while (currnode) {
							left += currnode.offsetLeft + currnode.clientLeft;
							top += currnode.offsetTop + currnode.clientTop;
							currnode = currnode.offsetParent;
						};
					} else {
						while (currnode) {
							left += currnode.offsetLeft;
							top += currnode.offsetTop;
							currnode = currnode.offsetParent;
						};
					};


					var menu_left = $(this.contextmenu).position().left;
					var menu_top = $(this.contextmenu).position().top;
					var menu_width = $(this.contextmenu).width();
					var menu_height = $(this.contextmenu).height();
					var max_posX = menu_left +  menu_width + 15 /* scrollbar */;
					var max_posY = menu_top +  menu_height;

					if(  left > max_posX || left < menu_left || top < menu_top || top >  max_posY ||  event.type != "mousedown" ) //it is not scroll
                window.document.getElementsByTagName('body')[0].removeChild(this.contextmenu);
					else
						return null;
            } catch (e) {
                // after some commands, the contextmenu will be removed by
                // the browser, ignore those cases
            };
            this.contextmenu = null;
        };
    };

    this._createNewContextMenu = function(elements, event) {

        /* adding the elements to the contextmenu and showing it */
        var doc = window.document;
        var menu = doc.createElement('div');
        menu.contentEditable = false;
        menu.designMode = 'Off';
        this._setMenuStyle(menu);
        for (var i=0; i < elements.length; i++) {
            var element = elements[i];
            if (element !== this.seperator && element.label.indexOf('-----') == -1) {
                var div = doc.createElement('div');
                div.style.width = '100%';
                var label = doc.createTextNode('\u00a0' + element.label);
                div.appendChild(label);
                menu.appendChild(div);
                // setting a reference to the div on the element
                element.element = div;
                addEventHandler(div, "mousedown", element.action, element.context);
                // On Firefox there is a problem with this event, it hides the menu on the same click that initialy showed it
                addEventHandler(div, "mouseup", this.hideContextMenu, this);
            } else {
                var hr = doc.createElement('hr');
                menu.appendChild(hr);
            };
        };

        // now moving the menu to the right position
        var iframe = this.editor.getDocument().getEditable();

        var left = event.clientX;
        var top = event.clientY;

        var currnode = iframe;
        if (this.editor.getBrowserName() == 'IE') {
            while (currnode) {
                left += currnode.offsetLeft + currnode.clientLeft;
                top += currnode.offsetTop + currnode.clientTop;
                currnode = currnode.offsetParent;
            };
        } else {
            while (currnode) {
                left += currnode.offsetLeft;
                top += currnode.offsetTop;
                currnode = currnode.offsetParent;
            };
        };

		  var position_click = top;


        menu.style.left = left + 'px';
        menu.style.top = top + 'px';
        menu.style.visibility = 'visible';


        addEventHandler(menu, 'focus', function() {this.blur}, menu)
        doc.getElementsByTagName('body')[0].appendChild(menu);

        var wdim = this.getWindowSize();
        var mh = $(menu).height();

		  //If click in middle botton
		  var middle_win = wdim.h/2;
		  if(position_click > middle_win) {
			  var space_for_menu =  position_click - 50; /* others: toolbar */
			  if(mh > space_for_menu ) { //we need scroll
				  mh = space_for_menu;
				  $(menu).height(space_for_menu);
				  menu.style.top =  ( position_click - mh ) +  'px';
				  menu.style.overflowY = "scroll";
			  }else {
				  menu.style.top =  ( position_click - mh ) +  'px';
			  }
		  }else { //open botton menu
			  var space_for_menu =  wdim.h - position_click - 30; /* others: not paste final windows */
			  menu.style.top =   position_click  +  'px';
			  if(mh > space_for_menu ) { //we need scroll
					mh = space_for_menu;
					$(menu).height(space_for_menu);
					menu.style.overflowY = "scroll";
			  }
		  }


        this.contextmenu = menu;
    };

    this._setMenuStyle = function(menu) {
        /* setting the styles for the menu

            to change the menu style, override this method
        */
        $(menu).addClass('context-menu');
    };

    this._showOriginalMenu = function(event) {
        window.document.dispatchEvent(this._last_event);
    };

    this.getWindowSize = function() {
    	var dim = {
    		w: document.compatMode=='CSS1Compat' && !window.opera ? document.documentElement.clientWidth : document.body.clientWidth,
    		h: document.compatMode=='CSS1Compat' && !window.opera ? document.documentElement.clientHeight : document.body.clientHeight
    	}
    	return dim;
    }


    this.getSelection = function() {

		 var selNode = this.editor.selNode;
		 var selection = this.editor.getSelection();

		 // temporal asignement
		 var startPos = selection.startOffset();
		 var endPos = startPos + selection.getContentLength();

		 var focusNode = null;
		 var startNode = null;
		 var endNode = null;

		 if (IS_IE) {

			 // We need to find the element in which the selection has been made.
			 // This element is a "text node", child of range.parentElement(),
			 // but there isn't a direct way to do that.

			 var rng1 = selection.getRange();
			 var parent = rng1.parentElement();
			 var text = $(parent).text();
			 text = text.substring(0, startPos);

			 var child = null;
			 var it = new DOMNodeIterator(parent);
			 while ((child = it.next()) && focusNode === null) {

				 var childText = null;
				 if (child.nodeType == 3) {
					 childText = child.nodeValue;
				 } else {
					 childText = $(child).text();
				 }

				 var aux = text.substr(0, childText.length);
				 text = text.substr(childText.length);

				 if (aux.length < childText.length) {
					 focusNode = child;
					 // FIXME: Is range over more than one element?
					 startNode = focusNode;
					 endNode = focusNode;
					 startPos = aux.length;
					 endPos = startPos + selection.getContentLength();
				 }
			 }

		 } else {
			 startNode = selection.startNode();
			 startPos = selection.selection.anchorOffset;
			 endNode = selection.endNode();
			 endPos = selection.selection.focusOffset;
			 focusNode = startNode;
		 }

		 // TODO: Implement ranges between multiple elements?
		 if (startNode !== endNode) return null;

		 var it = new DOMNodeIterator(selNode, 3);
		 var child = null;
		 var childPos = -1;
		 while (it.hasNext() && child !== startNode) {
			 child = it.next();
			 childPos++;
		 }

		 /*if (selNode.childNodes[0] && selNode.childNodes[0].nodeType != 3) {
		  / / C*orrects bug with apply elements when they are at the start of the string
		  childPos++;
		 }*/

		 // If selection is done by dragging from right to left, start & end position must be switched
		 if(startPos > endPos) {
			 var oldEndPos = endPos;
			 endPos = startPos;
			 startPos = oldEndPos;
		 }

		 var oSel = {
			 focusNode: focusNode,
			 focusNodeIndex: childPos,
			 parentNode: selNode,
			 startPosition: startPos,
			 endPosition: endPos,
			 ranges: {
				 textBefore: focusNode.nodeValue==null? "" : focusNode.nodeValue.substring(0, startPos),
				 text: focusNode.nodeValue==null? "" : focusNode.nodeValue.substring(startPos, endPos),
				 textAfter: focusNode.nodeValue==null? "" : focusNode.nodeValue.substring(endPos)
			 }
		 };

		 return oSel;
		 };
};

function ContextMenuElement(label, action, context) {
    /* context menu element struct

        should be returned (optionally in a list) by the tools'
        createContextMenuElements methods
    */
    this.label = label; // the text shown in the menu
    this.action = action; // a reference to the method that should be called
    this.context = context; // a reference to the object on which the method
                            //  is defined
    this.element = null; // the contextmenu machinery will add a reference
                            // to the element here

    this.changeOverStyle = function(event) {
        /* set the background of the element to 'mouseover' style

            override only for the prototype, not for individual elements
            so every element looks the same
        */
        this.element.style.backgroundColor = 'blue';
        this.element.style.color = 'white';
    };

    this.changeNormalStyle = function(event) {
        /* set the background of the element back to 'normal' style

            override only for the prototype, not for individual elements
            so every element looks the same
        */
        this.element.style.backgroundColor = 'white';
        this.element.style.color = 'black';
    };
};

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




var IS_MOZ		= (document.implementation && document.implementation['createDocument'] && document.implementation['hasFeature']) || false;
var IS_SAFARI	= navigator.userAgent.toLowerCase().indexOf("applewebkit") != -1 || false;
var IS_IE		= document.all && window.ActiveXObject && navigator.userAgent.toLowerCase().indexOf("msie") > -1  && navigator.userAgent.toLowerCase().indexOf("opera") == -1 || false;
var IS_CHROME		= navigator.userAgent.toLowerCase().indexOf('chrome/') != -1 || false;


var toString = function(node) {
	return new XMLSerializer().serializeToString(node);
}

/**
 * Extends KupuEditor class
 * @constructor
 */
function XimdocEditor(options) {

	this.options = options;

    // attrs
    this.document = options.document; // the model
    this.config = null; //config; // an object that holds the config values
    this.log = options.logger; // simple logger object
    this.channels = options.channels;
    this.tools = {}; // mapping id->tool
    this.maintoolboxes = [];
    this.filters = new Array(); // contentfilters
    this.view = options.edition_view; // edition view: 'tree', 'normal', 'pro'
    this.rngEditorMode = options.rngEditorMode; // Editor Rng: true | false
    this.dotdotPath = options.dotdotPath; // macro dotdotPath base calculated on ximdex

    this._designModeSetAttempts = 0;
    this._initialized = false;

    // some properties to save the selection, required for IE to remember where in the iframe the selection was
    this._previous_range = null;

    // this property is true if the content is changed, false if no changes are made yet
    this.content_changed = false;

	this.actionId = null;
	this.nodeId = null;
    // Base URL for Ajax requests
    this._baseURL = null;

    // Base URL for external action requests
    this._loadActionURL = null;


    // -------------------------------------------------------

	/**
	 *	Browser constants (From Sarissa library)
	 */
	this.IS_MOZ		= IS_MOZ;
	this.IS_SAFARI	= IS_SAFARI;
	this.IS_IE		= IS_IE;

	this._ximdoc = null;
	this._rngdoc = null;

	this._xmlDom = null;
	this._hasTmp = null;
	this._rngDom = null;
	this._xslDom = null;
	this._i18n = null;
	this._noRenderizableElements = null;

	this.selNode = null;
	this.lastSelNode = null;
	this.selectedText = null;
	this.selectedTextLength = null;
	this.ximElement = null;
	this.ximParent = null;
	this.elements = null;	// Collection of elements with UID attribute (XML elements)
	this.loadErrors = null;


	this.getTools = function() {
		return this.tools;
	};

	this.getXmlDocument = function() {
		return this._xmlDom;
	};

	this.getXslDocument = function() {
		return this._xslDom;
	};

	this.getRngDocument = function() {
		return this._rngdoc;
	};

	this.getXimDocument = function() {
		return this._ximdoc;
	};

	this.getEditorConfig = function() {
		return this.config;
	};

	this.getBaseURL = function() {
		return this._baseURL;
	};

	this.getLoadActionURL = function() {
		return this._loadActionURL;
	};

	this.getBody = function() {
		return $('body', this.getInnerDocument())[0];
	};

	this.getNoRenderizableElements = function () {
		var noRenderizableElementsArr = [];
		$('element', this._noRenderizableElements).each( function(index, elem) {
			if($(elem).text() != 'docxap')
				noRenderizableElementsArr.push($(elem).text());
		});

		return noRenderizableElementsArr;
	}

	this.isRngEditionMode = function() {
		if(this.rngEditorMode == "")
			return false;
		else
			return true;
	};

	this.getDotDotPath = function() {
		return this.dotdotPath;
	};

	this.getView = function() {
		if(['tree', 'normal', 'pro'].contains(this.view))
			return this.view;
		else
			return 'normal';
	};

	this.setView = function(edition_view) {
		return this.view = edition_view;
	};

	this.toggleSchemaValidator = function() {
		this.getXimDocument().toggleSchemaValidator();
	};

	this.schemaValidatorIsActive = function() {
		return this.getXimDocument().schemaValidatorIsActive();
	};

	this.setSchemaValidator = function(validate) {
		this.getXimDocument().setSchemaValidator(validate);
	};

	this.initialize = function(callback) {

		// kupu initialize stuff

        	/* Should be called on iframe.onload, will initialize the editor */
        	//DOM2Event.initRegistration();

		this._rngDom = null;
		this._xmlDom = null;
		this._xslDom = null;
		this.config = null;
		this._i18n = null;

        	this._initializeEventHandlers();

		if (this.getBrowserName() == "IE") {
            		// provide an 'afterInit' method on KupuEditor.prototype
            		// for additional bootstrapping (after editor init)
            		this._initialized = true;
            		if (this.afterInit) {
                		this.afterInit();
            		};
            		this._saveSelection();
        	} else {
            		this._setDesignModeWhenReady();
        	};

        	this.elements = $([]);

		this.actionId = $('.kupu-fulleditor .kupu-ximparams #kupu-actionId').html().trim();
		this.nodeId = $('.kupu-fulleditor .kupu-ximparams #kupu-nodeId').html().trim();
		var xslIncludesOnServer = $('.kupu-fulleditor .kupu-ximparams #kupu-xslIncludesOnServer').html().trim();

		// ximdex initialize stuff
		//this._baseURL = url_root + '/xmd/loadaction.php?actionid=' + this.actionId + '&nodeid=' + this.nodeId;
		this._baseURL = url_root + '/xmd/loadaction.php?action=xmleditor2&nodeid=' + this.nodeId;
		this._baseActionURL = url_root + '/actions/xmleditor2/';
		this._loadActionURL = url_root + '/xmd/loadaction.php?nodeid=' + this.nodeId;
                var xmlI18N = url_root + '/extensions/kupu/i18n/kupu-'+locale+'.pox';
                var verifyTmpUrl = this._baseURL + '&ajax=json&method=verifyTmpFile';
		var includesInServer="";
		//Avoid includes tag in xsl when by configuration or when browser is in safari or chrome
		if (xslIncludesOnServer == 1 || IS_SAFARI || IS_CHROME)
		    includesInServer = "&includesInServer=1";
                
                var allUrl = this._baseURL + '&ajax=json&method=getAll'+ includesInServer +'&view=' + this.getView();

		// i18n request
		//this.fileRequest('_i18n', xmlI18N, callback);

		// Verify Tmp file request
		this.fileRequest('_hasTmp', verifyTmpUrl, callback);
           
                // 
                this.fileRequestAll(allUrl, callback);

	};

    	this.getActionDescription = function() {
    		return this._actionDescription || '';
    	};

    	this.setActionDescription = function(description) {
    		this._actionDescription = description || '';
    	};

        this.fileRequest = function(propertyName, url, callback, updateEditor, hideLoadingImage, method, content) {
		var method = (method) ? method : 'GET';
		var content = (content) ? content : null;
		new AjaxRequest(url, {
			method: method,
			content: content,
			onComplete: function(req, json) {

				if (json['error']) {
					callback(null, json.error);
					return;
				}

				if (json["result"] !== false){
					var data = json.data || req.responseText;
					
					if(json.method && json.method == 'verifyTmpFile') {
						this[propertyName] = json.result;
					}
					else if (url.indexOf("loadaction") == -1){
					    this[propertyName] = this.createDomDocument(data,0,true);
					}
					else {
						this[propertyName] = this.createDomDocument(data);
					}
	
					this._afterInitialize(callback);
				}
			}.bind(this),
			onError: function(req) {
				//console.error(req);
				loadingImage.hideLoadingImage();
			}.bind(this)
		});
	}
        
        this.fileRequestAll = function(url, callback, updateEditor, hideLoadingImage, method, content) {
		var method = (method) ? method : 'GET';
		var content = (content) ? content : null;

		new AjaxRequest(url, {
			method: method,
			content: content,
			onComplete: function(req, json) {

				if (json['error']) {
					callback(null, json.error);
					return;
				}

				if (json["result"] !== false){
					var data = json.data || req.responseText;
					
					if(json.method && json.method == 'verifyTmpFile') {
						this[propertyName] = json.result;
					}
					else if (url.indexOf("loadaction") == -1){
					    //this[propertyName] = this.createDomDocument(data,0,true);
					}
					else {
                                                this['_xmlDom'] = this.createDomDocument(json.xmlFile);
                                                this['_rngDom'] = this.createDomDocument(json.schemaFile);
                                                this['_xslDom'] = this.createDomDocument(json.xslFile);
                                                this['_noRenderizableElements'] = this.createDomDocument(json.noRenderizableElements);
						this['config'] = this.createDomDocument(json.config);
					}
	
					this._afterInitialize(callback);
				}
			}.bind(this),
			onError: function(req) {
				//console.error(req);
				loadingImage.hideLoadingImage();
			}.bind(this)
		});
	}
        
	/**
	 * Called from XimdocEditor.process()
	 */
	this._afterInitialize = function(callback) {
                console.time('afterinit');
		if (
			this._rngDom === null || this._xmlDom === null ||
			this._xslDom === null || this.config === null ||
			this._noRenderizableElements === null
			) return;

		//window.i18n_message_catalog.initialize(this._i18n);
                
		this.config = this._parseConfig(this.config);

		this._rngdoc = new RngDocument();
		this._rngdoc.loadXML(this._rngDom);

		this._ximdoc = new XimDocument(this.config);
		this._ximdoc.editor = this;
		this._ximdoc.loadXML(this._xmlDom, this._rngdoc);
		this._xslDom = this.BrowserCompatibility.parseXSLDocument(this._xslDom, this.getView(), this.getNoRenderizableElements());

		// 'callback' is an user defined function passed as a parameter to XimdocEditor.process()
		if (callback) callback(this);

		this.setActionDescription(_('Initialize editor'));
		this.updateEditor({caller: this});
        	this.logMessage(_('Editor initialized'));

        if (this._hasTmp && this.config.autosave_time > 0) {
        	var confirmCallback = {
        		'yes': function () {
        			// Recover doc with temp file
					new AjaxRequest(this._baseURL + '&ajax=json&method=recoverTmpFile&view=' + this.getView(), {
						method: 'POST',
						content: null,
						onComplete: function(req, json) {
							if(json.result === true) {
								this.fileRequest('_xmlDom', this._baseURL + '&ajax=json&method=getXmlFile', function () {this.tools.editorviewtool.setView(this.getView());this._hasTmp = false;}.bind(this));
								this.logMessage(_('Temporal file recovered and removed'));
							} else {
								this.logMessage(_('Error recovering temporal file'));
							}
						}.bind(this),
						onError: function(req) {
							this.logMessage(_('Error recovering temporal file'));
						}.bind(this)
					});
        		}.bind(this),
        		'no': function () {
        			// Delete tmp file
					new AjaxRequest(this._baseURL + '&ajax=json&method=removeTmpFile', {
						method: 'POST',
						content: null,
						onComplete: function(req, json) {
							if(json.result === true) {
								this._hasTmp = false;
								this.logMessage(_('Temporal file removed'));
							} else {
								this.logMessage(_('Error removing temporal file'));
							}
						}.bind(this),
						onError: function(req) {
							this.logMessage(_('Error removing temporal file'));
						}.bind(this)
					});
        		}.bind(this)
        	}
        	this.confirm(_('It is available a temporal version of the document with saving date more recent than the last one you saved. Do you want to recover it?'), confirmCallback);
        }
            console.timeEnd('afterinit');
	};

	this._parseConfig = function(confNode) {
		// Config XML already parsed
		if (confNode.nodeType != 9) return confNode;

	    var root = confNode.getElementsByTagName('kupuconfig');
	    root = root[0] || null;
	    if (!root) {
	        //this.log.log(_('No element found in the configuration'));
	        throw(_('No element found in the configuration'));
	    };

	    // _load_dict_helper() defined in kupuhelpers
	    root = _load_dict_helper(root);
	    return root;
	};

	/**
	 * Creates a XML Document and, optionally, loads it with a XML string
	 */
	this.createDomDocument = function(xml, ctype, forceNotParse) {

		ctype = ctype == 1 ? 'application/xhtml+xml' : 'text/xml';

		/** Using Sarissa library **/
		var xmldoc = Sarissa.getDomDocument();

		if (xml) {
			xml = this.BrowserCompatibility.parseXMLString(xml);
//console.log(xml);
			xmldoc = new DOMParser().parseFromString(xml, ctype);
			if (!forceNotParse){
			    xmldoc = this.BrowserCompatibility.parseXMLDocument(xmldoc);
			}
		}

		// IE doesn't allow to extend XML DOM documents.
		/*xmldoc.toString = function(node) {
			node = node || this;
			var str = new XMLSerializer().serializeToString(node);
			return str;
		}*/

		return xmldoc;
	};

	this.preSanitizeHTML = function(xsltResult) {
                console.time('presanitize');
		// Trying to remove the <transformiix:result /> node
		var t = toString($('html', xsltResult).get(0));
		xsltResult = this.createDomDocument(t);

		// Removing <script/> tags
		$('script', xsltResult).each(function(index, elem) {
			elem.parentNode.removeChild(elem);
		});

		if (!IS_IE) {

			// Trying to fix tags defined into CDATA blocks

			// Replacing entities with < > simbols
			var htmlString = toString(xsltResult);
			var pattern = /&lt;([^<]+?)&gt;/g;

			if (pattern.test(htmlString)) {

				htmlString = htmlString.replace(pattern, '<$1>');

				// Transforming all tags to lower case
				pattern = /<([^>\s]+)/g;
				var res = htmlString.match(pattern);
				var processed = [];
				for (var i=0; i<res.length; i++) {
					if (!processed[res[i]]) {
						var regex = new RegExp(res[i], 'g');
						htmlString = htmlString.replace(regex, res[i].toLowerCase());
						processed[res[i]] = true;
					}
				}

				xsltResult = this.createDomDocument(htmlString);
			}
		}

		// Throwing a warning message if any element has no UID attribute
		$('[uid="{@uid}"]', xsltResult).each(
			function(index, elem) {
				elem.attributes.removeNamedItem('uid');
				var msg = 'Element <' + elem.tagName + '/> has no UID attribute!';
				//this.logMessage(_(msg), 2);
				console.warn(_(msg));
			}.bind(this)
		);

		// This correction is needed because the fix of attributes on CDATA sections
		/*$('[uid]', xsltResult).each(
			function(index, elem) {
				elem.setAttribute('uid', elem.getAttribute('uid').trim());
			}
		);*/

		var createLink = function(href) {
			var link = xsltResult.createElement('link');
			link.setAttribute('rel', 'stylesheet');
			link.setAttribute('type', 'text/css');
			link.setAttribute('href', href);
			return link
		}

		var head = xsltResult.getElementsByTagName('head')[0];
		var css = this._baseActionURL + 'views/common/css/kupustyles.css';
		head.appendChild(createLink(css));

		css = this._baseActionURL + 'views/common/css/innerframe.css';
		head.appendChild(createLink(css));
                console.timeEnd('presanitize');
		return xsltResult;
	};

	this.postSanitizeHTML = function(xslResult, htmlDoc) {
                console.time('postsanitize');
		// Fixing the UID attribute for <body/> element
		// <body/> element maybe is not present in docxap template
		// A better way to resolve this problem is to assign the first possible uid directly
		htmlDoc.setAttribute('uid', this.nodeId + ".1");

		$('img[uid]', htmlDoc).each(
			function(i, e) {
				var uid = e.getAttribute('uid');
				var elem = $('[uid="'+uid+'"]', xslResult)[0];
				// IE sets default width and height of an image to 1px,
				// the only way to get the real default size is to remove both attributes.
				if (e.getAttribute('width') != elem.getAttribute('width')) {
					e.attributes.removeNamedItem('width');
				}
				if (e.getAttribute('height') != elem.getAttribute('height')) {
					e.attributes.removeNamedItem('height');
				}
			}.bind(this)
		);

		// We don't want working links
		$('a', htmlDoc).each(function(index, elem) {
			if (elem.getAttribute('href')) elem.attributes.removeNamedItem('href');
			if (elem.getAttribute('target')) elem.attributes.removeNamedItem('target');
		});

                console.timeEnd('postsanitize');
		return htmlDoc;
	};

	this.updateEditor = function(options) {
                console.time('updateeditor');
		options = options || {
			updateContent: true,
			caller: null,
			hideXimlets: false
		};

		options.updateContent = (options['updateContent'] == undefined)
			? true
			: (options.updateContent ? true : false);
		/*options.caller = options['caller']
			? options.caller
			: this;*/

		if (options.updateContent) this.updateEditorContent();

		var oldBody = this.getBody();
		var xmldoc = this._ximdoc.saveXML({
			asString: false,
			hideXimlets: options.hideXimlets ? options.hideXimlets : false
    	});

		if (!xmldoc) return false;

		this._xmlDom = xmldoc;

		if(!this._xslDom || this._xslDom.documentElement == null) {
			this.alert(_('No docxap template detected. Changing back to tree view.'));
			selectView('tree');
			return false;
		}

		var xslResult = xslt.xsltTransform(this._xmlDom, this._xslDom,this);
		if (!xslResult) return false;

		xslResult = this.preSanitizeHTML(xslResult);

		options.xslResult = xslResult;
		this.beforeUpdateContent(options);

		$('head', this.getInnerDocument()).html(toString($('head', xslResult)[0]));
		$('body', this.getInnerDocument()).html(toString($('body', xslResult)[0]));

		this.postSanitizeHTML(xslResult, this.getBody());


		// If extended view is choosen, previewInServer is active and there are preview servers:
		// get preview
		if(this.getView() == 'pro') {
			// TODO: Are there preview servers? Choose one.

			var newBodyString = $('html', this.getInnerDocument()).html();

			var content = encodeURIComponent(newBodyString);

			this._ximdoc.editor.tools.ximdoctool.toolboxes.channelstoolbox.getChannelId();

			var encodedContent = "&nodeid=" + this.nodeId +
								 "&content=" + content +
								 "&channelid=" + this._ximdoc._channelId;

			com.ximdex.ximdex.editors.PreviewInServerHandler(this.getBaseURL(), encodedContent, {
				onComplete: function(req, json) {
					switch(req.responseText) {
						case '1':
							this.alert(_('Cannot show Remote View') + '. ' + _('PreviewInServer mode is disabled'));
							selectView('normal');
							break;
						case '2':
							this.alert(_('Cannot show Remote View') + '. ' + _('No Preview Servers for this channel'));
							selectView('normal');
							break;
						case '3':
							this.alert(_('Cannot show Remote View') + '. ' + _('Error accessing remote server. Please, verify permissions and synchro base path'));
							selectView('normal');
							break;
						case '4':
							this.alert(_('Cannot show Remote View') + '. ' + _('Error connecting remote server. Please, verify synchro data (IP, access keys)'));
							selectView('normal');
							break;
						case '5':
							this.alert(_('Cannot show Remote View') + '. ' + _('Unknown error'));
							selectView('normal');
							break;
						default:
							var rgx = new RegExp("<head[^>]*>(.*)</head>", "g");
							var head = req.responseText.match(rgx);
							var rgx = new RegExp("<body(.*[^>])*>(.*)</body>", "g");
							var body = req.responseText.match(rgx);
							$('head', this.getInnerDocument()).html(head[0]);
							$('body', this.getInnerDocument()).html(body[0]);

							this.afterUpdateContent(options);
							loadingImage.hideLoadingImage();
					}
				}.bind(this),
				onError: function(req) {
					this.alert(_('Error obtaining preview file in server.'));
				}.bind(this)
			});
		}

		this.afterUpdateContent(options);
		loadingImage.hideLoadingImage();

		this.selNode = (options.selNode) ? options.selNode : this.getSelectedNode();
        this.updateState(options.event);

        if(options.callback) {
        	var callback = options.callback;
        	callback();
        }

                console.timeEnd('updateeditor');
		return true;
	};

	/**
	 * NOTE: It's not needed to traverse DOM tree hierarchic.
	 * We only need a list of nodes with 'uid' attribute setted.
	 * First solution: using getElementsByTagName.
	 * TODO: Explore XPATH use from browser.
	 * a) http://code.google.com/p/ajaxslt/
	 * b) sarissa
	 */
	this.updateEditorContent = function() {
                console.time('updateeditorcontent');
		var domElement = this.getBody();

		this.removeCheckSpellingTags(domElement);
		this.removeAnnotationTags(domElement);

		// TODO: There will be problems with the content if XSL template renderize more than one element per UID
		var items = $('[uid]', domElement);
		var i = items.length;
		var item = null;
		while (item = items[i-1]) {
			var uid = item.getAttribute('uid');
			if (item.isEditable) {
				var ximElement = this._ximdoc.importHtmlElement(item);
				this._ximdoc.updateElement(uid, ximElement);
			}
			i--;
		}
                
                console.timeEnd('updateeditorcontent');
	};


	this.alert = function (msg) {
		var dialog = $('<div id="kupu-jdialog">' + window.i18n_message_catalog.acents ( msg)  + '</div>',
			$('.kupu-editorframe'));
		$('.kupu-editorframe').append(dialog);

		var check = $("#kupu-jdialog").data("dialog");

		if(check) {
			$("#kupu-jdialog").dialog("destroy");
		}


		$("#kupu-jdialog").dialog({
			modal: true,
			maxHeight: 400,
			height: 400,
			buttons: {
				Ok: function() {
					$(this).dialog('close');
				}
			}
		});
	}


	this.alertvideo = function (msg) {


		var dialog = $('<div class="video" id="kupu-jdialog">' + window.i18n_message_catalog.acents( msg ) + '</div>',
                        $('.kupu-editorframe'));
                $('.kupu-editorframe').append(dialog);


			var check = $("#kupu-jdialog").data("dialog");

			if(check) {
				$("#kupu-jdialog").dialog("destroy");
			}


                $("#kupu-jdialog").dialog({
                        modal: true,
                        maxHeight: 450,
                        height: 450,
			width: 500,
                        buttons: {
                                Ok: function() {
                                        $(this).dialog('close');
                                }
                        }
                });
        }

	this.confirm = function (msg, callback) {
		var dialog = $('<div id="kupu-jdialog">' + window.i18n_message_catalog.acents ( msg)   + '</div>',
			$('.kupu-editorframe'));
		$('.kupu-editorframe').append(dialog);


		var check = $("#kupu-jdialog").data("dialog");

		if(check) {
			$("#kupu-jdialog").dialog("destroy");
		}



		$("#kupu-jdialog").dialog({
			resizable: false,
			height:300,
			width: 400,
			modal: true,
			buttons: {
				_('Yes'): function() {
					callback.yes();
					$(this).dialog('close');
				},
				_('No'): function() {
					callback.no();
					$(this).dialog('close');
				}
			}
		});
	}

	this.setDefaultImages = function() {
		$('img[uid]', this.getBody()).each(
			function(index, elem) {
				// Image source defaults to iframe URL
				var img_url = elem.src.replace(this._baseActionURL, '');

				if (!img_url || "index.html" == img_url || !elem.src ) {
					elem.src = url_root + '/xmd/images/insert_img.png';
				}
			}.bind(this)
		);
	};

	this.removeCheckSpellingTags = function(domItem) {
		$('font[owner="spellchecker"]', domItem).each(function(index, elem) {
        	$(elem).after(elem.textContent);
        	$(elem).remove();
		}.bind(this));
	};

	this.removeAnnotationTags = function(domItem) {
		$('font[owner="annotator"]', domItem).each(function(index, elem) {
        	$(elem).after(elem.textContent);
        	$(elem).remove();
		}.bind(this));
	};

	this.setDinamicContentImages = function() {
		var bodyText = $(this.getBody()).html();
		var rgx = new RegExp("&lt;php?([^<>]*)?&gt;", "g");
		bodyText = bodyText.replace(rgx, "<div style='background-color: gray; padding-left: 25px; border: 1px solid black; color: white; font-weight: bold; text-decoration: italic; height: 16px; background-repeat: no-repeat; background-image: url(" + url_root + "/actions/xmleditor2/gfx/page_white_php.png);'>Non XHTML Code</div>");
		$(this.getBody()).html(bodyText);
	};

    // -------------------------------------------------------


    this.prepareForm = function(form, id) {
        /* adding a field to the form and placing the contents in it

            it can be used for simple POST support where Kupu is part of a form
        */

        // making sure people can't edit or save during saving
        if (!this._initialized) {
            return;
        }
        this._initialized = false;

        // setting the window, status so people can see we're actually saving
        window.status= _("Please wait while saving document...");

        // call (optional) beforeSave() method on all tools
        for (var tid in this.tools) {
            var tool = this.tools[tid];
            if (tool.beforeSave) {
                try {
                    tool.beforeSave();
                } catch(e) {
                    this.alert(e);
                    this._initialized = true;
                    return;
                };
            };
        };

        // setting a default id
        if (!id) {
            id = 'kupu';
        };

        // passing the content through the filters
        this.logMessage(_("Starting HTML cleanup"));
        var transform = this._filterContent(this.getInnerDocument().documentElement);

        // XXX need to fix this.  Sometimes a spurious "\n\n" text
        // node appears in the transform, which breaks the Moz
        // serializer on .xml
        var contents =  this._serializeOutputToString(transform);

        this.logMessage(_("Cleanup done, sending document to server"));


        // now create the form input, since IE 5.5 doesn't support the
        // ownerDocument property we use window.document as a fallback (which
        // will almost by definition be correct).
        var document = form.ownerDocument ? form.ownerDocument : window.document;

		var kupuForm = document.getElementsByName(id);

		// Don't create same element twice!
		if (kupuForm.length == 0) {
	        var ta = document.createElement('textarea');
	        ta.style.visibility = 'hidden';
	        var text = document.createTextNode(contents);
	        ta.appendChild(text);
	        ta.setAttribute('name', id);
	        // and add it to the form
	        form.appendChild(ta);
        } else {
        	kupuForm[0].value = contents;
        }

        // letting the calling code know we have added the textarea
		this._initialized = true;
        return true;
    };

    this.getClickedNode = function() {
        /* returns the selected node (read: parent) or none */
        return this.getSelection().parentElement();
    };

    this.getNearestParentWithAttribute = function(node, attrName, tagName) {
        while (node) {
    		var it = new DOMAttrIterator(node);
    		while (it.hasNext()) {
    			var attr = it.next();
    			if (attr.nodeName.toLowerCase() == attrName.toLowerCase()) return node;
    		}
            var node = node.parentNode;
        }

        return false;
    };

    this._restoreSelection = function() {
        /* re-selects the previous selection in IE. We only restore if the current selection is not in the document.*/
        /*if (this._previous_range && !this._isDocumentSelected()) {
            try {
                this._previous_range.select();
            } catch (e) {
                //this.alert("Error placing back selection");
                this.logMessage(_('Error placing back selection'));
            };
        };*/
    };

    this.updateState = function(event) {
        /* let each tool changes state if required */
        // first seeing if the event is interesting enough to trigger the whole updateState machinery

        if(event && event.type == 'mouseup') {
        	this.fireMouseupEvent(event);
        	return;
        }

		// Cursors Keys events
		if (event && event.type == 'keyup' && event.keyCode >= 37 && event.keyCode <= 40) {
			var positionNode = this.getSelection().selection.anchorNode.parentNode;
			if(this.selNode && positionNode && this.selNode.getAttribute('uid') != positionNode.getAttribute('uid')) {
				this.selNode = positionNode;
			}
		}

		// If user presses the enter key we create a new element of the same type
		if (event && event.type == 'keyup' && event.keyCode == 13) {
			var elems = $('[uid="'+this.selNode.getAttribute('uid')+'"]', this.getInnerDocument());
			var ximElement = elems[elems.length-1].ximElement;
			if (ximElement) {
				var newElement = new XimElement(ximElement.schemaNode, false);
				var htmlNodeAdded = this.getSelection().selection.anchorNode;
				if(htmlNodeAdded) {
					var htmlNodeSplited = htmlNodeAdded.previousSibling;
					if(htmlNodeSplited) {
						newElement.value = (htmlNodeAdded.textContent && htmlNodeSplited.textContent
											&& htmlNodeAdded.textContent != '')
											? htmlNodeAdded.textContent
											: newElement.value;
						ximElement.value = (htmlNodeSplited.textContent
											&& htmlNodeSplited.textContent != '')
											? htmlNodeSplited.textContent
											: ximElement.value;
						this.getXimDocument().insertAfter(newElement, ximElement.parentNode, ximElement);
						this.setActionDescription(_('Splited element'));
						this.selNode = newElement;
						this.updateEditor({caller: this, updateContent: false, selNode: newElement});
					}
				}
				return;
			}
		}

		var target = (event && !['keyup', 'keydown'].contains(event.type))
			? (event.target || event.srcElement)
			: (this.selNode || null);

        this._setSelectionData(target);
		if (!this.selNode) return;

        for (var id in this.tools) {
            try {
                if (this.tools[id]['updateState']) this.tools[id].updateState({caller: this, selNode: this.selNode, event: event});
            } catch (e) {
                if (e == UpdateStateCancelBubble) {
                    this.updateState(event);
                    break;
                } else {
                 /*   this.logMessage(
                        _('Exception while processing updateState on ' +
                            '${id}: ${msg}', {'id': id, 'msg': e.message}), 2); */
                }
            }
        }
    };

    this.fireMouseupEvent = function(event) {

    	var target = (event.target || event.srcElement);
    	this._setSelectionData(target);
		if (!this.selNode) return;

    	for (var id in this.tools) {
            try {
                if (this.tools[id]['mouseUp']) this.tools[id].mouseUp({caller: this, selNode: this.selNode, event: event});
            } catch (e) {
                if (e == UpdateStateCancelBubble) {
                    this.fireMouseupEvent(event);
                    break;
                } else {
                    this.logMessage(
                        _('Exception while processing mouseUp on ' +
                            '${id}: ${msg}', {'id': id, 'msg': e.message}), 2);
                }
            }
        }
    };

    this.getSelectedNode = function() {
        return this.selNode ? this.selNode : this.lastSelNode;
    };

    this._setSelectionData = function(target) {

    	this.lastSelNode = this.selNode;

    	var ximdoc = this.getXimDocument();
		this.selNode = target || this.getSelection().parentElement();

		if(this.selNode.uid)
			this.selNode = $('[uid="' + this.selNode.uid + '"]', this.getInnerDocument())[0];

		// If function getAttribute does not exist, nothing to set.
		if(this.selNode && !this.selNode['getAttribute']) {
			this.selNode = null;
			return;
		}

		// being sure to get the correct element (UID)
		while (this.selNode && !this.selNode.getAttribute('uid')) {
			this.selNode = this.getParentWithUID(this.selNode);
		}

		if (!this.selNode) return;

		// All the editable elements with the same UID
		var elements = this.selNode.ximElement.getHtmlElements(true);

		// If selected element is a "no editable" element try to obtain the editable part of the element.
		if (!this.selNode.ximElement.isRoot && this.selNode.getAttribute('editable') == 'no') {
			if (elements[0]) this.selNode = elements[0];
		}

		this.selectedText = this.getSelection();
		this.selectedTextLength = this.selectedText.getContentLength();

		// Checking if node is selectable
		if(this.selNode.ximElement && !this.selNode.ximElement.isSelectable(this.nodeId)) {
			var firstSelectableParent = this.selNode.ximElement.getFirstSelectableParent(this.nodeId);
			if(!firstSelectableParent) {
				this.selNode = null;
				return;
			}
			var selectableParentElements = firstSelectableParent.getHtmlElements(true);
			this._setSelectionData(selectableParentElements[0]);
		}

		this.ximElement = this.selNode.ximElement;
		this.ximParent = this.ximElement.parentNode;

    };

	/**
	 * Function which returns a DOMElement object, parent of selNode
	 */
    this.getParentWithUID = function(selNode) {
    	var parent = selNode;
    	var uid = null;

		while (uid == null && parent != null) {
			parent = parent.parentNode;
			if (parent && parent.nodeType == 1) {
				// TODO: Check the existence of UID attribute
				uid = parent.getAttribute('uid');
			}
		}

		// If we can't find a parent with UID we assumed that is the body element
		if (!parent) parent = this.getBody();
		if (!parent.getAttribute('uid')) parent = null;

    	return parent;
    };

    this.beforeUpdateContent = function(options) {

    	// Called before the document is updated with the new content

        var selNode = this.getSelectedNode();
		options.selNode = selNode;

        for (var id in this.tools) {
            try {
                if (this.tools[id]['beforeUpdateContent']) this.tools[id].beforeUpdateContent(options);
            } catch (e) {
                this.logMessage(_('Exception while processing beforeUpdateContent on ${id}: ${msg}', {'id': id, 'msg': e.message}), 2);
                console.error(_('Exception while processing beforeUpdateContent on ${id}: ${msg}', {'id': id, 'msg': e}));
            }
        }
    	this.elements = $([]);

		// noscript
		/*$("noscript", $('body', xslResult)[0]).each(function(index, elem) {
			console.info(elem);
			elem.tagName = 'span';
			//$(elem).attr('src', path);
		});*/

    };

    this.afterUpdateContent = function(options) {
        console.time('afterupdatecontent');
    	// Called after the document is updated with the new content

		this.setDinamicContentImages();
		this.setDefaultImages();

    	$('br[uid]', this.getBody()).each(
    		function(i, e) {
    			var div = this.getInnerDocument().createElement('div');
    			div.innerHTML = '&para;';
    			div.setAttribute('uid', e.getAttribute('uid'));
    			div.setAttribute('editable', 'no');
    			e.parentNode.insertBefore(div, e);
    			e.parentNode.removeChild(e);
    		}.bind(this)
    	);

    	this.extendElements();

		if (this.getView() == 'tree' || this.isRngEditionMode()) {
			$('.folding', this.getBody()).dblclick(
				function(event) {
					var target = event.currentTarget || event.target;
					var ctrl = $(target).siblings('div').toggle().siblings('.ctrl');
					if ($(ctrl).hasClass('minus')) {
						$(ctrl).attr('src', '../../xmd/images/tree/Lplus.png').toggleClass('minus');
						$('.folder', $(target).parent()).attr('src', '../../xmd/images/tree/folder.png');
					} else {
						$(ctrl).attr('src', '../../xmd/images/tree/Lminus.png').toggleClass('minus');
						$('.folder', $(target).parent()).attr('src', '../../xmd/images/tree/openfolder.png');
					}
				}
			);
		}

    	// Called after the XSL transformation and the iframe content update
        var selNode = this.getSelectedNode();
        options.selNode = selNode;

		options.editor = this;

        for (var id in this.tools) {
            try {
                if (this.tools[id]['afterUpdateContent']) this.tools[id].afterUpdateContent(options);
            } catch (e) {
                this.logMessage(_('Exception while processing afterUpdateContent on ${id}: ${msg}', {'id': id, 'msg': e.message}), 2);
                console.error(_('Exception while processing afterUpdateContent on ${id}: ${msg}', {'id': id, 'msg': e}));
            }
        }

        this.setEditableContent(this.getBody());
        console.timeEnd('afterupdatecontent');

    };

    this.extendElements = function() {

		// ximdoc elements
    	this.elements = $('[uid]', this.getInnerDocument()).each(
    		function(index, elem) {
    			var ximElement = this.getXimDocument().getElement(elem.getAttribute('uid'));
    			elem.ximElement = ximElement;
    			elem.rngElement = ximElement.schemaNode;
    			ximElement._htmlElements.push(elem);
    			elem.isEditable = (
			    		elem['getAttribute'] &&
			    		elem.getAttribute('uid') &&
			    		elem.getAttribute('uid') != this.nodeId + '.1' &&
			   		elem.getAttribute('editable') != 'no'
				    	);
    		}.bind(this)
    	)
    	.addClass('xedit-rngelement');

    	// no ximdoc elements
    	$(':not([uid])', this.getInnerDocument()).each(
			function(index, elem) {
				elem.isEditable = false;
			}.bind(this)
		);
    };

    this.setEditableContent = function(node) {

		// TODO: Restore selected element before setting "no editable content"?
		// NOTE: Firefox3 will suport contentEditable attribute: http://starkravingfinkle.org/blog/2007/07/firefox-3-contenteditable/

		var mode = node.isEditable;

    	if (this.getBrowserName() == "IE") {
			this.this._setEDitableContent_IE(mode);
		} else {
		// FF sets design mode on documents.
		// mode values: on, off
		mode = mode ? 'Off' : 'On';
			if (this.getInnerDocument().designMode.toUpperCase() != mode.toUpperCase()) this.getInnerDocument().designMode = mode;
		}
    };

	 this._setEDitableContent_IE = function(mode) {
		 if (this.lastSelected) {
			 // This is an improvement for usability.
			 // It avoids multiple clicks for selecting an apply element.
			 this.lastSelected.setAttribute('contentEditable', 'false');
		 }

		 // MSIE can set design mode per elements.
		 // mode values: true, false, inherit, ?
		 mode = mode ? 'true' : 'false';
		 var editable = new String(node.getAttribute('contentEditable')).toUpperCase();

		 if (editable != mode.toUpperCase())
				node.setAttribute('contentEditable', mode);
		 this.lastSelected = node;

	 };

    this.enableButtonFF3 = function(elem) {
		// Workaround!
		// Firefox 3 disables the "Update Attribute" button, why?

		var buttons = null;
		if (elem['tagName'] && elem.tagName.toLowerCase() == 'button') {
			buttons = [elem];
		} else if (elem['length'] && elem['push']) {
			buttons = elem;
		} else {
			buttons = $('button', elem);
		}

		for (var i=0; i<buttons.length; i++) {
			var button = buttons[i];
			if (button.attributes.getNamedItem('disabled')) {
				button.attributes.removeNamedItem('disabled');
			}
		}
    };

	this.reloadXml = function() {
		var savebutton = getFromSelector('kupu-save-button');
		loadingImage.showLoadingImage();
	    var drawer = window.document.getElementById('kupu-librarydrawer');
	    if (drawer) {
	        drawer.parentNode.removeChild(drawer);
	    }
	    this.prepareForm(savebutton.form, 'kupu');

		var ximdoc = kupu.getXimDocument();
		var content = ximdoc.saveXML({
			asString: true,
			hideXimlets: true,
			resolveXimlinks: true
		});

		var encodedContent = "&content=" + encodeURIComponent(content);

		var xmlUrl = this._baseURL + '&ajax=json&method=getXmlFile';

		// XML request
		this.fileRequest(
			'_xmlDom', xmlUrl,
			this.updateEditor.bind(this),
			null, null, 'POST', '&content=' + content
		);
	};

};

XimdocEditor.prototype = new KupuEditor();

function initKupuTools(kupu) {

    var contextmenu = new ContextMenu();
    kupu.setContextMenu(contextmenu);

    // now we can create a UI object which we can use from the UI
    // var ui = new KupuUI('kupu-tb-styles');

    // the ui must be registered to the editor like a tool so it can be notified
    // of state changes
    // kupu.registerTool('ui', ui); // XXX Should this be a different method?

    // function that returns a function to execute a button command
    var execCommand = function(cmd) {
        return function(button, editor) {
            editor.execCommand(cmd);
        };
    };

    var removeelementbutton = new XimdocRemoveElementButton('kupu-remove-button');
	kupu.registerTool('removebutton', removeelementbutton);

//    var proptool = new PropertyTool('kupu-properties-title', 'kupu-properties-description');
//    kupu.registerTool('proptool', proptool);

    var showpathtool = new ShowPathTool();
    kupu.registerTool('showpathtool', showpathtool);

	// ximdoc tools

	// Base tool
	var ximdoctool = new XimdocTool();
	kupu.registerTool('ximdoctool', ximdoctool);

	var imagestool = new ImagesTool();
	kupu.registerTool('imagestool', imagestool);

	var editorviewtool = new EditorViewTool();
	kupu.registerTool('editorviewtool', editorviewtool);

	var hovertool = new HoverTool();
	kupu.registerTool('hovertool', hovertool);

	if (kupu.getXimDocument().expertModeIsAllowed()) {
	    var schemavalidatorbutton = new SchemaValidatorButton('kupu-schemavalidator-button');
	    kupu.registerTool('schemavalidatorbutton', schemavalidatorbutton);
    } else {
    	$('#kupu-schemavalidator-button').remove();
    }

	var ximdoceditablecontenttool = new XimdocEditableContentTool();
	kupu.registerTool('ximdoceditablecontenttool', ximdoceditablecontenttool);

	var ximdoccontextmenutool = new XimdocContextMenuTool();
	kupu.registerTool('ximdoccontextmenutool', ximdoccontextmenutool);

	var ximdocspellcheckertool = new XimdocSpellCheckerTool();
	kupu.registerTool('ximdocspellcheckertool', ximdocspellcheckertool);

	var ximdocpreviewtool = new XimdocPreviewTool();
	kupu.registerTool('ximdocpreviewtool', ximdocpreviewtool);

	var tablemanagertool = new TableManagerTool();
	kupu.registerTool('tablemanagertool', tablemanagertool);

	var listmanagertool = new ListManagerTool();
	kupu.registerTool('listmanagertool', listmanagertool);

	var attributestool = new AttributesTool();
	kupu.registerTool('attributestool', attributestool);

	var toolcontainertoolbox = new ToolContainerToolBox({});
	ximdoctool.registerToolBox('toolcontainertoolbox', toolcontainertoolbox);


	/********* TOOLBOX FOR THE RIGHT PANEL ************/

	/**Tools and toolbox declaration**/

	// Annotation tool
	var ximdocannotationtool = new XimdocAnnotationTool();
	kupu.registerTool('ximdocannotationtool', ximdocannotationtool);

	// Annotation toolbox
    var annotationstoolbox = new AnnotationsToolBox({
		toolboxId: 'xedit-annotations-toolbox',
		ctrlButtonId: 'xedit-annotations-toolbox-button',
		buttonActiveClass: 'xedit-annotations-toolbox-button',
		buttonInactiveClass: 'xedit-annotations-toolbox-button-closed',
		visible: new Boolean(kupu.config.toolboxes.annotations)
	});
    
    //Channel Toolbox 
    if(!kupu.isRngEditionMode()) {
		var channelstoolbox = new ChannelsToolBox({
			toolboxId: 'xedit-channels-toolbox',
			ctrlButtonId: 'xedit-channels-toolbox-button',
			buttonActiveClass: 'xedit-channels-toolbox-button',
			buttonInactiveClass: 'xedit-channels-toolbox-button-closed',
			visible: new Boolean(kupu.config.toolboxes.channels)
		});
		
	}

	//Availables elements for the selected element toolbox
	var rngelementstoolbox = new RNGElementsToolBox({
		toolboxId: 'xedit-rngelements-toolbox',
		ctrlButtonId: 'xedit-rngelements-toolbox-button',
		buttonActiveClass: 'xedit-rngelements-toolbox-button',
		buttonInactiveClass: 'xedit-rngelements-toolbox-button-closed',
		visible: new Boolean(kupu.config.toolboxes.rngelements)
	});

	//Selected element attributes toolbox
	var attributestoolbox = new AttributesToolBox({
		toolboxId: 'xedit-attributes-toolbox',
		ctrlButtonId: 'xedit-attributes-toolbox-button',
		buttonActiveClass: 'xedit-attributes-toolbox-button',
		buttonInactiveClass: 'xedit-attributes-toolbox-button-closed',
		visible: new Boolean(kupu.config.toolboxes.attributes)
	});

	//Changeset in the current doc
	var changesettoolbox = new ChangesetToolBox({	
		toolboxId: 'xedit-changeset-toolbox',
		ctrlButtonId: 'kupu-toolbox-undolog-button',
		buttonActiveClass: 'kupu-toolbox-undolog-button',
		buttonInactiveClass: 'kupu-toolbox-undolog-button-closed',
		maxlength: kupu.config.history_max_changes,
		visible: new Boolean(kupu.config.toolboxes.history)
	});
	
	//Current document's info toolbox
	var infotoolbox = new InfoToolBox({
		toolboxId: 'xedit-info-toolbox',
		ctrlButtonId: 'xedit-info-toolbox-button',
		buttonActiveClass: 'xedit-info-toolbox-button',
		buttonInactiveClass: 'xedit-info-toolbox-button-closed',
		visible: new Boolean(kupu.config.toolboxes.info)
	});
	/**END OF Tools and toolbox declaration**/

	/**TOOLBOX REGISTER. In the reverse order*/

	/**
		1. Tag (fixed, in Smarty)
		2. Annotation Tool Box
		3. Availables Element.
		4. Attributes for the current element
		5. Info
		6. Channels
		7. Change set
		8. Log.
	*/
	ximdoctool.registerToolBox('changesettoolbox', changesettoolbox);	
	ximdoctool.registerToolBox('channelstoolbox', channelstoolbox);
	ximdoctool.registerToolBox('infotoolbox', infotoolbox);
	attributestool.registerToolBox('attributestoolbox', attributestoolbox);
	ximdoctool.registerToolBox('rngelementstoolbox', rngelementstoolbox);
	ximdocannotationtool.registerToolBox('annotationstoolbox', annotationstoolbox);
	
	/**END OF TOOLBOX REGISTER.**/

    var highlighttoolbox = new HighlightToolBox();
    hovertool.registerToolBox('highlighttoolbox', highlighttoolbox);

    var draggabletoolbox = new DraggablesToolBox();
    hovertool.registerToolBox('draggabletoolbox', draggabletoolbox);

    // Drawers...

    // Function that returns function to open a drawer
    var opendrawer = function(drawerid) {
        return function(button, editor) {
            drawertool.openDrawer(drawerid);
        };
    };

    // Function that returns function to open a ximdocdrawer
    var openximdocdrawer = function(drawerid) {
        return function(button, editor) {
            ximdocdrawertool.openDrawer(drawerid);
        };
    };

    var spellchecker = new KupuButton('kupu-spellchecker-button', function() {
    	$(this.button).toggleClass('kupu-spellchecker-pressed').toggleClass('kupu-spellchecker');
    	ximdocspellcheckertool.doCheck();
    });
    kupu.registerTool('spellchecker', spellchecker);

    var annotation = new KupuButton('kupu-annotation-button', function() {ximdocannotationtool.doAnnotate();});
    kupu.registerTool('annotation', annotation);

    var previewbutton = new KupuButton('kupu-prevdoc-button', function() {ximdocpreviewtool.preview();});
    kupu.registerTool('previewbutton', previewbutton);

    // create some drawers, drawers are some sort of popups that appear when a
    // toolbar button is clicked
    var drawertool = new DrawerTool();
    kupu.registerTool('drawertool', drawertool);

    var ximdocdrawertool = new XimdocDrawerTool();
    kupu.registerTool('ximdocdrawertool', ximdocdrawertool);

    var toolbartool = new ToolbarTool();
    kupu.registerTool('toolbartool', toolbartool);

	var rmximdextool = new RMXimdexTool();
	kupu.registerTool('rmximdextool', rmximdextool);

	// MAIN TOOLBOXES
    kupu.maintoolboxes['xedit-attributes-toolbox'] 	= attributestoolbox;

//    kupu.maintoolboxes['xedit-toolbar-toolbox'] = toolbartoolbox;
    	kupu.maintoolboxes['xedit-rngelements-toolbox'] 	= rngelementstoolbox;
    	kupu.maintoolboxes['xedit-annotations-toolbox'] 	= annotationstoolbox;
    	kupu.maintoolboxes['xedit-changeset-toolbox'] 		= changesettoolbox;
    	kupu.maintoolboxes['xedit-channels-toolbox'] 		= channelstoolbox;
	kupu.maintoolboxes['xedit-info-toolbox'] 		= infotoolbox;
    	kupu.maintoolboxes['xedit-ximdexlogger-toolbox'] 	= kupu.log;


    // XIMLETS

    // Ximlet Tool
    var ximlettool = new ximletTool();
    kupu.registerTool('ximlettool', ximlettool);

    // Ximlet Drawer
    var ximletdrawer = new ximletDrawer('kupu-ximletdrawer', ximlettool);
    ximdocdrawertool.registerDrawer('ximletdrawer', ximletdrawer);

    // Ximlet Drawer Button
    var ximletdrawerbutton = new KupuButton('kupu-ximletdrawer-button',
                                          openximdocdrawer('ximletdrawer'));
    kupu.registerTool('ximletdrawerbutton', ximletdrawerbutton);

	var ximlinkdrawer = new XimlinkDrawer('kupu-ximlinkdrawer', attributestool);
	ximdocdrawertool.registerDrawer('ximlinkdrawer', ximlinkdrawer);

	var tabledrawer = new TableDrawer('kupu-tabledrawer', attributestool);
	ximdocdrawertool.registerDrawer('tabledrawer', tabledrawer);

    // Disabling ximlet drawer button
    var button = getFromSelector('kupu-ximletdrawer-button');
	KupuButtonDisable(button);


    //Navbar Tools
    var navbartagtool = new NavBarTool({});
	kupu.registerTool('navbartagtool',navbartagtool);

	var navbartagtoolbox = new NavBarToolBox({});
	navbartagtool.registerToolBox("navbartagtoolbox",navbartagtoolbox);    

    // making the prepareForm method get called on form submit
    // some bug in IE makes it crash on saving the form when a lib drawer was added to the page at some point, remove it on form submit
    var savebutton = getFromSelector('kupu-save-button');
	addEventHandler(savebutton, 'click', prepareForm, kupu);

    // making the prepareForm method get called on publicated button clicked with extra publication options
    var publicatebutton = getFromSelector('kupu-publicate-button');
	addEventHandler(publicatebutton, 'click', function () {prepareForm(false, true);}, kupu);

    // Button: Open Xedit on new window
    var newwindowbutton = getFromSelector('kupu-newwindow-button');
	addEventHandler(newwindowbutton, 'click', function () {
		if (kupu.config.confirm_on_new_window == 1) {
			kupu.confirm(_('You have applied to open the editor in a new window. Changes not saved will be lost. Do you want to continue?'), {
				'yes': function() {
					window.open(document.URL);
				},
				'no': function() {
				}
			});
		} else {
			window.open(document.URL);
		}
	}, kupu);

	// making the prepareForm method get called every minute for saving content
	// on ximdex temp directory
	if (kupu.config.autosave_time > 0) {
		var xTimer = XimTimer.getInstance();
		xTimer.addObserver(function () {prepareForm(true);}, kupu.config.autosave_time);
		xTimer.start();
	}

    // registering some cleanup filter
    // removing tags that aren't in the XHTML DTD
    var nonxhtmltagfilter = new NonXHTMLTagFilter();
    kupu.registerFilter(nonxhtmltagfilter);

//    if (window.kuputoolcollapser) {
//        var collapser = new window.kuputoolcollapser.Collapser('kupu-toolboxes');
//        collapser.initialize();
//    };


	/*for (var i=0, l=window.kupuToolHandlers.length; i<l; i++) {
		window.kupuToolHandlers[i].handler(window.kupuToolHandlers[i]);
	}*/

	$('#kupu-toolboxes').unbind().remove();

	try {
		var tagslist = $('.xim-tagsinput-container');
		$(tagslist).tagsinput();
	}catch(e) {
		//ximTAGS module needed
	}

    return kupu;
};

function continueStartKupu(kupu) {

    if (kupu.getXimDocument().expertModeIsAllowed()) {
	    var schemavalidatorbutton = kupu.getTool('schemavalidatorbutton');
    	schemavalidatorbutton.setSchemaValidator(!kupu.config.expert_mode_active);
    } else {
    	kupu.setSchemaValidator(true);
   	}

   	if(!kupu.getXimDocument().publicationIsAllowed())
	   	KupuButtonDisable(getFromSelector('kupu-publicate-button'));

	kupu.getXimDocument().validateXML(function(valid, msg) {
    		if (!valid) kupu.alert(msg);
    });

	loadingImage.hideLoadingImage();
        console.timeEnd('editor');
        
    return kupu;
};



function prepareForm(autoSave, publicate) {

	if(autoSave && autoSave.type)
		autoSave = false;

	var savebutton = getFromSelector('kupu-save-button');

	if(autoSave === false)
		loadingImage.showLoadingImage();

    var drawer = window.document.getElementById('kupu-librarydrawer');
    if (drawer) {
        drawer.parentNode.removeChild(drawer);
    }

    kupu.prepareForm(savebutton.form, 'kupu');
    //savebutton.form.submit();

    // First step is refreshing the XML document content
    if(autoSave === false)
	    kupu.updateEditor();

	var xmlfile = "";
	//var content = savebutton.form.kupu.value;

	var ximdoc = kupu.getXimDocument();
	var content = ximdoc.saveXML({
		asString: true,
		hideXimlets: true,
		resolveXimlinks: true
	});
	var lang = "es";

	var encodedContent = "XML=" + encodeURIComponent(xmlfile) +
						 "&content=" + encodeURIComponent(content) +
						 "&lang=" + encodeURIComponent(lang);

	// NOTE: XML validation on the server
	var validate = ximdoc.schemaValidatorIsActive();
	ximdoc.setSchemaValidator(false);

	ximdoc.validateXML(function(valid, msg) {

		if(autoSave === false) {
			if (!valid) {
				kupu.alert(msg);
			}
			loadingImage.showLoadingImage();
			ximdoc.setSchemaValidator(validate);
		}

		if(publicate === true) {
			com.ximdex.ximdex.editors.PublicateHandler(kupu.getBaseURL(), encodedContent, {
				onComplete: function(req, json) {
					if(autoSave === false) {
						kupu.alert(_('The document has been saved and sent to be published.'));
						loadingImage.hideLoadingImage();
					} else {
						kupu.logMessage(_('The document has been saved and sent to be published.'));
					}
				},
				onError: function(req) {
					if(autoSave === false) {
						kupu.alert(_('An error occurred while saving and/or sending the document to publish.\n\n' + 'State: ' + req.status + '\nError: ' + req.statusText));
						loadingImage.hideLoadingImage();
					} else {
						kupu.alert(_('An error occurred while saving and/or sending the document to publish.\n\n' + 'State: ' + req.status + '\nError: ' + req.statusText));
					}
				}
			}, autoSave);
		} else {
			com.ximdex.ximdex.editors.SaveHandler(kupu.getBaseURL(), encodedContent, {
				onComplete: function(req, json) {
					if(autoSave === false) {
						kupu.alert(_('The document has been successfully saved.'));
						loadingImage.hideLoadingImage();
						//kupu.reloadXml();
					} else {
						kupu.logMessage(_('The document has been successfully saved.'));
					}
				},
				onError: function(req) {
					if(autoSave === false) {
						kupu.alert(_('An error occurred while saving the document.\n\n' + 'State: ' + req.status + '\nError: ' + req.statusText));
						loadingImage.hideLoadingImage();
					} else {
						kupu.alert(_('An error occurred while saving the document\n\n' + 'State: ' + req.status + '\nError: ' + req.statusText));
					}
				}
			}, autoSave);
		}
	});
}


/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



/*****************************************************************************
 *
 * Copyright (c) 2003-2005 Kupu Contributors. All rights reserved.
 *
 * This software is distributed under the terms of the Kupu
 * License. See LICENSE.txt for license text. For a list of Kupu
 * Contributors see CREDITS.txt.
 *
 *****************************************************************************/

// $Id$


window.kupu = null;

function startKupu(options) {

	options.showOverlayOnFirstEdition = options.showOverlayOnFirstEdition || false;
	options.availableViews = options.availableViews || ['tree', 'normal', 'pro'];

	$('#kupu-editor').load(function() {

		// Register the unload event.
		// If this document is a ximlet, the opener could refresh the ximlet content.
		// See ximletTool.ximletDblClick()

		var ximletid = 'unload_ximlet_' + $('.kupu-fulleditor .kupu-ximparams #kupu-nodeId').html().trim();
		if (window.opener && window.opener[ximletid]) {
			window.onunload = window.opener[ximletid];
		}

	    	// initializing the editor, initKupu groks 1 arg, a reference to the iframe
	    	var frame = getFromSelector('kupu-editor');

	    	// we create the document, hand it over the id of the iframe
	    	var doc = new KupuDocument(frame);

		// now we can create the controller
		options = $.extend(options, {
			document: doc,
			logger: null
		});

		var kupu = new XimdocEditor(options);
                
                console.time('kupuinitialize');
		kupu.initialize(startKupuCallback);
                console.timeEnd('kupuinitialize');

		    // $('#kupu-editor').show();
                
		this.kupu = kupu;

		if ((kupu.loadErrors == null || kupu.loadErrors == false)){
		    loadingImage.createLoadingImage();
		    if(options.showOverlayOnFirstEdition)
		    	loadingImage.showLoadingImage();
		}
		

		return kupu;
		

	}.bind(this));

	// This ensures that all posible scripts loaded in memory are unloaded ;)
	// $('#kupu-editor').hide();
	$('#kupu-editor')[0].src = url_root + '/actions/xmleditor2/index.html';
}

function startKupuCallback(kupu, errors) {

	// NOTE: If the beforeUnload callback returns anything (true, false, null, ...)
	// a confirm dialog will be displayed.
	// If the returned data is a string, that string will be shown in the confirm dialog.
	if (kupu){
	    if (kupu.config.confirm_on_exit == 1) {
		    window.onbeforeunload = function() {
			    return false;
		    };
	    }

	    $(window).unload(function() {
		    // None
	    }.bind(this));


	kupu.log = new XimdexLogger({
		    toolboxId: 'xedit-ximdexlogger-toolbox',
		    ctrlButtonId: 'kupu-toolbox-debuglog-button',
		    buttonActiveClass: 'kupu-toolbox-debuglog-button',
		    buttonInactiveClass: 'kupu-toolbox-debuglog-button-closed',
		    maxlength: kupu.config.logger_max_length,
		    tool: null,
		    editor: kupu,
		    visible: new Boolean(kupu.config.toolboxes.logger)
	    });

	}
	if (kupu && !errors) {
		initKupuTools(kupu);
		continueStartKupu(kupu);
		return kupu;
	} else {
		show_wMessage($('#wMessage')[0], errors);
		kupu.loadErrors = true;
		return false;
	}
        
	return true;
}


function show_wMessage(wMessage, errors) {

	var htmlmsg="";
	for (var i=0; i<errors.length; i++) {
		console.error(errors[i]);
		htmlmsg += '<br/>' + errors[i];
	}
	if (window.kupu){
	    window.kupu.alert(htmlmsg);
	}
	/*var htmlmsg = '<ul>';
	for (var i=0; i<errors.length; i++) {
		console.error(errors[i]);
		htmlmsg += '<li>' + errors[i] + '</li>';
	}
	htmlmsg += '</ul>';
	$('#wMessage').css({
		'margin-left': 'auto',
		'margin-right': 'auto',
		'padding-top': '4px',
		'padding-bottom': '4px',
		'padding-right': '10px',
		top: '20%',
		//width: '40%',
		height: (errors.length*4) + '%',
		'font-size': '14px'
	});
	$('#wMessage').html(htmlmsg);*/

    
}
/** ########################################## BrowserCompatibility ############################## */
/**
 *	Maintains compatibility between different browsers.
 *	This class is oriented to XML documents.
 */
XimdocEditor.prototype.BrowserCompatibility = {

	parseXMLString: function(xmlString) {
		/**
		 *	NOTE: Cleanup for MSIE!!!!
		 *	MSIE will fail if detect the following:
		 *		- a <xml/> tag.
		 *		- a line break.
		 *		- a DTD.
		 */
		if (IS_IE) {
			xmlString = xmlString.replace(/<\?xml(.*)\?>/ig, '');
			xmlString = xmlString.replace(/\n/ig, '');
			xmlString = xmlString.replace(/<!DOCTYPE(.*)\]>/g, '');
		}
		return xmlString;
	},

	parseXMLDocument: function(xmldoc) {
		/**
		 *	NOTE: sarissa implements parsererror detection
		 *	We use getParseErrorText sarissa method for IE
		 *       but not for FF, because parseerror attribute of documentElement is always setted to 0. (Sarissa emulates IE's parseError attribute)
		 */
		if (IS_IE) {
			this._parse_with_sarissa(xmldoc);
		} else {
			try {
				if(xmldoc.documentElement.tagName == "parsererror" ){
					console.error(xmldoc.documentElement.firstChild.nodeValue);
					throw(xmldoc.documentElement.firstChild.nodeValue);
				}
			}catch(e) {
					console.log("parserXMLDocument error ");
			}
		}

		return xmldoc;
	},

parseXSLString: function(xslString) {
	return xslString;
},

parseXSLDocument: function(xsldoc, view, noRenderizableElements) {


	$('output', xsldoc).remove(); 		// Being sure that the output is HTML for Firefox
	xsldoc = this.extendXSLDocument(xsldoc, view, noRenderizableElements);

	/**
	 *	NOTE:
	 *		MSIE needs a XML as a result of the XSL transformation, so it is included here the <xsl:output/> tag.
	 *		Firefox will crash if detect a <xsl:output/> tag.
	 */
	if (IS_IE) {
		return  this._create_xslOutput(xsldoc);
	}

	return xsldoc;
},

// TODO: Maintain a specific xsldoc for view, due to make xsldoc manipulation only once.
// NOTE: Using Jquery for xsldoc-dom manipulation is OK in FF, but not in IE
// NOTE: Jquery selectors fail for xsldoc-dom in IE
// NOTE: Creating namespaced elements in FF with createElement make xsltprocessor crash, not in IE
//       Correct way in FF is to use createElementNS
extendXSLDocument: function(xsldoc, view, noRenderizableElements) {

	if(view == 'tree' || noRenderizableElements.length == 0)
		return xsldoc;

	console.info(_('Found no renderizable elements: '), noRenderizableElements);

	var minusButton = this._create_minusButton(xsldoc);
	var folderIcon = this._create_folderIcon(xsldoc);
	var blankImage = this._create_blankImage(xsldoc);
	var spanTittle = this._create_spanTittle(xsldoc);
	var uidDiv = this._create_uidDiv(xsldoc);
	var containerDiv = this._create_containerDiv(xsldoc, minusButton, folderIcon, blankImage, spanTittle, uidDiv );

	return this._create_newTemplate(xsldoc, containerDiv, noRenderizableElements);
},

_create_xslOutput: function(xsldoc) {
	var xslOutput = xsldoc.createElement('xsl:output');
	xslOutput.setAttribute('method', 'xml');
	xslOutput.setAttribute('version', '1.0');
	xslOutput.setAttribute('encoding', 'UTF-8');
	xslOutput.setAttribute('indent', 'no');
	xslOutput.setAttribute('omit-xml-declaration', 'yes');	// MSIE will crash if detect a <xml/> tag.
	xsldoc.firstChild.insertBefore(xslOutput, xsldoc.firstChild.firstChild);

	return xsldoc;
},

_create_minusButton: function(xsldoc) {
	var minusButton = xsldoc.createElement('img');
	minusButton.setAttribute('src', url_root + '/xmd/images/tree/Lminus.png');
	minusButton.setAttribute('align', 'absmiddle');
	minusButton.setAttribute('class', 'minus folding');

	return minusButton;
},

_create_folderIcon: function(xsldoc) {
	var folderIcon = xsldoc.createElement('img');
	folderIcon.setAttribute('src', url_root + '/xmd/images/tree/openfolder.png');
	folderIcon.setAttribute('align', 'absmiddle');
	folderIcon.setAttribute('class', 'folder folding');

	return folderIcon;
},

_create_blankImage: function(xsldoc) {
	var blankImage = xsldoc.createElement('img');
	blankImage.setAttribute('src', url_root + '/xmd/images/tree/blank.png');
	blankImage.setAttribute('align', 'absmiddle');
	blankImage.setAttribute('width', '10px');

	return blankImage;
},

_create_spanTittle: function(xsldoc) {
	var spanTittle = xsldoc.createElement('span');
	spanTittle.setAttribute('uid', '{@uid}');
	spanTittle.setAttribute('editable', 'no');
	spanTittle.setAttribute('width', '10px');
	spanTittle.setAttribute('class', 'rngeditor_title folding');

	if (typeof xsldoc.createElementNS == 'undefined')
		var valueOf = xsldoc.createElement('xsl:value-of');
	else
		var valueOf = xsldoc.createElementNS('http://www.w3.org/1999/XSL/Transform', 'value-of');

	valueOf.setAttribute('select', 'local-name(.)');

	spanTittle.appendChild(valueOf);

	return spanTittle;
},

_create_uidDiv: function(xsldoc) {
	var uidDiv = xsldoc.createElement('div');
	uidDiv.setAttribute('uid', '{@uid}');
	uidDiv.setAttribute('id', 'tg_{@uid}');

	if (typeof xsldoc.createElementNS == 'undefined')
		var applyTemplates = xsldoc.createElement('xsl:apply-templates');
	else
		var applyTemplates = xsldoc.createElementNS('http://www.w3.org/1999/XSL/Transform', 'apply-templates');

	uidDiv.appendChild(applyTemplates);

	return uidDiv;
},

_create_containerDiv: function(xsldoc,minusButton, folderIcon, blankImage, spanTittle, uidDiv ) {
	var containerDiv = xsldoc.createElement('div');
	containerDiv.setAttribute('class', 'rngeditor_block');

	containerDiv.appendChild(minusButton);
	containerDiv.appendChild(folderIcon);
	containerDiv.appendChild(blankImage);
	containerDiv.appendChild(spanTittle);
	containerDiv.appendChild(uidDiv);

	return containerDiv;
},

_create_newTemplate: function(xsldoc, containerDiv, noRenderizableElements) {

	if (typeof xsldoc.createElementNS == 'undefined')
		var newTemplate = xsldoc.createElement('xsl:template');
	else
		var newTemplate = xsldoc.createElementNS('http://www.w3.org/1999/XSL/Transform', 'template');
	newTemplate.setAttribute('name', 'no_ptd_element');
	newTemplate.appendChild(containerDiv);

	var attrMatchValue = '';
	var numElements = noRenderizableElements.length;
	for(var i = 0; i < numElements; i++) {
		if(i != 0)
			attrMatchValue += ' | ';
		attrMatchValue += noRenderizableElements[i] + ' | ' + noRenderizableElements[i] + '//*';
	}
	newTemplate.setAttribute('match', attrMatchValue);

	xsldoc.firstChild.appendChild(newTemplate);

	return xsldoc;
},

_parse_with_sarissa: function(xmldoc) {
	var parserErrors = Sarissa.getParseErrorText(xmldoc);
	if(parserErrors != Sarissa.PARSED_OK) {
		console.error(parserErrors);
		throw(parserErrors);
	}

}

};

/**
 * Base class for all ximdex actions
 * @class
 */
function XimdocTool() {
    /*
        Tools must implement at least an initialize method and an
        updateState method, and can implement other methods to add
        certain extra functionality (e.g. createContextMenuElements).

        XimdocTool knowns how to operate with XML and RNG documents.
    */

	this.toolboxes = {};

	this.updateState = function(options) {
		/*
			Is called when user moves cursor to other element

			Calls the updateState for all toolboxes and may want perform
			some actions itself
		*/
		for (id in this.toolboxes) {
			try {
				if (this.toolboxes[id]['updateState']) this.toolboxes[id].updateState(options);
			} catch (e) {
				this.editor.logMessage(_('Exception while processing updateState on ${id}: ${msg}', {'id': id, 'msg': e.message}), 2);
			}
		}
	};

	this.beforeUpdateContent = function(options) {
		// Called before the XSL transformation
		for (id in this.toolboxes) {
			if (this.toolboxes[id]['beforeUpdateContent']) this.toolboxes[id].beforeUpdateContent(options);
		}
	};

	this.afterUpdateContent = function(options) {
		// Called before the XSL transformation
		for (id in this.toolboxes) {
			if (this.toolboxes[id]['afterUpdateContent']) this.toolboxes[id].afterUpdateContent(options);
		}
	};

	/**
	 * <p>Function that is called before creating an element.</p>
	 * <p>Each subclass of XimdocTool can override this behaviour
	 * 	  when it calls the inherited createElement method</p>
	 *
	 */
	this.beforeCreateElement = function() {
		loadingImage.showLoadingImage();
	};
	
	/**
	 * <p>Function that is called after creating an element.</p>
	 * <p>Each subclass of XimdocTool can override this behaviour
	 * 	  when it calls the inherited createElement method</p>
	 *
	 */
	this.afterCreateElement = function(options) {
		loadingImage.hideLoadingImage();    		
	};

    	// Deactivates all ximdex buttons
    	this.disableAllButtons = function() {
		var model = this.editor.getRngDocument().getModel();
		for(var rngElement in model) {
			if(rngElement != "docxap") {
				rngElement = rngElement.replace(":", "_");
				var button = this.editor.getTool('%s_rngbutton'.printf(rngElement));
				button.disable();
			}
		}
    	};

    	this.getActionDescription = function() {
    		return this._actionDescription || '';
    	};

    	this.setActionDescription = function(description) {
    		this._actionDescription = description || '';
    	};

	this.createElementWrapper = function(nodeType, parent, brother) {
		// Function which returns a function reference that will be used in events calls (ie: ContentMenu)
		return function() {
			this.createElement(nodeType, parent, brother);
		}.bind(this);
	};

	/**
	 * nodeType is the tagName of the element we want to create
	 * parent and brother are instances of XimElement
	 */
    	this.createElement = function(nodeType, parent, brother, oSel) {
		this.beforeCreateElement();

    	/**

    	 TODO:
	 The system to create elemetns should be improved in several points:

    	 1.	An XimElement element should be created when calling this funcion, following instructions indicated in (1), from RNG
    	 2.	The cardinality should be taken into account when instantiating an XimElement from RNG. Create its children depending on it.
    	 3.	The previous step is not valid if the XimElement element already exists in the XML. In this case, only the childen defined by the XML will be created.
		In fact, the XimElelment doesn't have to be instantiated, but DOMElement via XimDocument.importXmlElement() should.
	 4.	In the XimElement, it should be distinguished between 'defaultValue', 'value' and the HTML representation of the element.
    	 	a.	The attribute 'defaultValue' is a string obtained from the RNG while creating the element; it will be used just whe instantiating a new XimElement.
    	 	b.	The attribute 'value' es string type value which represents the current 'nodeValue' of the HTML node.
    	 	c.	The HTML representation will be obtained by calling a specific function of XimElement or XimDocument.importHtmlElement().
			This would return a HTML node tree wich root is the XimElement element. This methos would be used in the XML exportation (XimDocument.saveXML())
    	 5.     The method XimDocument.importXmlElement() should not use any RNGElement to obtain values, just as it's being done now.
    	 */
   		var ximdoc = this.editor.getXimDocument();
   		var rngElement = ximdoc.getRngDocument().getElement(nodeType);
	    	var ximElement = new XimElement(rngElement, true);

		if (this.editor.selectedTextLength > 0) {

			var selection = oSel ? oSel : this.getSelection();
			if (selection === null) {
				this.editor.logMessage(_('ERROR: Trying to apply an element to more than one selected elements.'));
				return;
			}

			var res;
			res = this.wrapTextElement(ximElement, parent, selection);
			ximElement=res[0];
			brother=res[1];
			/*if (selection.startPosition == 0) {
				// Correcting bug with apply elements when they are at the start of the string
				parent.value.splice(0, 0, '');
			}*/
		}

    		// If brother = null append the element as the last child node
    		if (!brother) {
    			//console.log('appendChild(%s, %s)', ximElement.tagName, parent.tagName);
    			ximdoc.appendChild(ximElement, parent);
    		} else if (this.editor.selectedTextLength > 0) {
 			/*console.log('insertBefore(%s, %s, %s)',
    			ximElement.tagName + ' (' + ximElement.uid + ')',
    			parent.tagName + ' (' + parent.uid + ')',
    			brother.tagName + ' (' + brother.uid + ')');*/
    			ximdoc.insertBefore(ximElement, parent, brother);
    		} else {
			//console.log('insertAfter(%s, %s, %s)', ximElement.tagName, parent.tagName, brother.tagName);
	    		ximdoc.insertAfter(ximElement, parent, brother);
		}

		var tagName = ximElement.tagName || _("element");
		this.setActionDescription(_('Create ')+" "+tagName);
		this.editor._setSelectionData( ximElement );
    		this.editor.updateEditor({caller: this, target: ximElement});
		this.afterCreateElement();
    		return ximElement;
    	};

    	this.getSelection = function() {

		var selNode = this.editor.selNode;
		var selection = this.editor.getSelection();


		if (!selNode){
         	       var arraySelNode = this.editor.ximElement.getHtmlElements();
                	for(var i=0; i< arraySelNode.length;i++){
                        	if (arraySelNode[i].className.indexOf("-selected") > -1){
                                	selNode = arraySelNode[i];
	                        }
        	        }
        	}	

		// temporal asignement
		var startPos = selection.startOffset();
		var endPos = startPos + selection.getContentLength();

		var focusNode = null;
		var startNode = null;
		var endNode = null;

		if (IS_IE) {

			// We need to find the element in which the selection has been made.
			// This element is a "text node", child of range.parentElement(),
			// but there isn't a direct way to do that.

			var rng1 = selection.getRange();
			var parent = rng1.parentElement();
			var text = $(parent).text();
			text = text.substring(0, startPos);

			var child = null;
			var it = new DOMNodeIterator(parent);
			while ((child = it.next()) && focusNode === null) {

				var childText = null;
				if (child.nodeType == 3) {
					childText = child.nodeValue;
				} else {
					childText = $(child).text();
				}

				var aux = text.substr(0, childText.length);
				text = text.substr(childText.length);

				if (aux.length < childText.length) {
					focusNode = child;
					// FIXME: Is range over more than one element?
					startNode = focusNode;
					endNode = focusNode;
					startPos = aux.length;
					endPos = startPos + selection.getContentLength();
				}
			}

		} else {
			startNode = selection.startNode();
			startPos = selection.selection.anchorOffset;
			endNode = selection.endNode();
			endPos = selection.selection.focusOffset;
			focusNode = startNode;
		}

		// TODO: Implement ranges between multiple elements?
		if (startNode !== endNode) return null;

		//Iterating for every node. We are interesting in text (nodetype=3)
		//and nodes with uid attribute
		var it = new DOMNodeIterator(selNode);
		var child = null;
		var childPos = -1;
		while (it.hasNext() && child !== startNode) {
			child = it.next();
			if (child.nodeType == 3 || child.getAttribute("uid"))
			    childPos++;
			childPos++;
		}

		if (selNode.childNodes[0] && selNode.childNodes[0].nodeType != 3 && selNode.childNodes[0].getAttribute("uid")) {
			// Corrects bug with apply elements when they are at the start of the string
			childPos++;
		}

		// If selection is done by dragging from right to left, start & end position must be switched
		if(startPos > endPos) {
			var oldEndPos = endPos;
			endPos = startPos;
			startPos = oldEndPos;
		}

		var oSel = {
			focusNode: focusNode,
			focusNodeIndex: childPos,
			parentNode: selNode,
			startPosition: startPos,
			endPosition: endPos,
			ranges: {
				textBefore: focusNode.nodeValue.substring(0, startPos),
				text: focusNode.nodeValue.substring(startPos, endPos),
				textAfter: focusNode.nodeValue.substring(endPos)
			}
		};

		return oSel;
    	};

    	this.wrapTextElement = function(ximElement, parent, selection) {

		if(null != contextmenu_selection ) {
			var selection = contextmenu_selection;
			contextmenu_selection = null;
		}
		var selNode = this.editor.getSelectedNode() || contextmenu_selNode;


    		// Needed for editor.updateEditorContent()
		var pre = this.editor.getInnerDocument().createTextNode(selection.ranges.textBefore);
		var post = this.editor.getInnerDocument().createTextNode(selection.ranges.textAfter);


		selNode.insertBefore(pre, selection.focusNode);
		selNode.insertBefore(post, selection.focusNode);
		selNode.removeChild(selection.focusNode);

		brother = parent.childNodes[selection.focusNodeIndex];
		ximElement.value = [selection.ranges.text];


		return [ximElement,brother];
    	};

    	this.removeElementWrapper = function(ximElement) {
    		// Returns a function reference that will be used in events calls (ie: ContentMenu)
    		return function() {
    			this.removeElement(ximElement);
    		}.bind(this);
    	};

	/**
	 * ximElement is the node we want to remove.
	 */
	this.removeElement = function(ximElement) {
		if(!ximElement.isRemovable())
			return;

		if (ximElement.schemaNode.type.contains('apply')) {
			ximElement.disApply();
		}

		this.setActionDescription(_('Remove element'));
		this.editor.getXimDocument().removeChild(ximElement);
		this.editor.selNode = ximElement.getFirstSelectableParent(this.editor.nodeId);
    		this.editor.updateEditor({caller: this});
	};

    	this.disApplyElementWrapper = function(ximElement) {
    		// Returns a function reference that will be used in events calls (ie: ContentMenu)
    		return function() {
    			this.disApplyElement(ximElement);
    		}.bind(this);
    	};

	/**
	 * ximElement is the node we want to disApply.
	 */
	this.disApplyElement = function(ximElement) {
		if(!ximElement.isApplyable())
			return;

		ximElement.disApply(true);

		this.setActionDescription(_('Disapply element'));
		this.editor.getXimDocument().removeChild(ximElement);
		this.editor.selNode = ximElement.getFirstSelectableParent(this.editor.nodeId);
    		this.editor.updateEditor({caller: this});
	};

    	this.cutElementWrapper = function(ximElement) {
    		return function() {
    			return this.cutElement(ximElement);
    		}.bind(this);
    	};

	this.cutElement = function(ximElement) {
		this.editor.clipboard = this.editor.getXimDocument().cloneElement(ximElement);
		this.removeElement(ximElement);
		return this.editor.clipboard;
	};

    	this.copyElementWrapper = function(ximElement) {
    		return function() {
    			return this.copyElement(ximElement);
    		}.bind(this);
    	};

	this.copyElement = function(ximElement) {
		this.editor.clipboard = this.editor.getXimDocument().cloneElement(ximElement);
		return this.editor.clipboard;
	};

    	this.pasteElementWrapper = function(parent, brother) {
    		return function() {
    			return this.pasteElement(parent, brother);
    		}.bind(this);
    	};

	this.pasteElement = function(parent, brother) {
		if (!this.editor.clipboard) return;
		var newElement = this.editor.getXimDocument().cloneElement(this.editor.clipboard);
		newElement = this.editor.getXimDocument().insertAfter(newElement, parent, brother);
		this.setActionDescription(_('Paste element'));
		this.editor.updateEditor({caller: this});
		return newElement;
	};

};

XimdocTool.prototype = new KupuTool();

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision: 7842 $
 */



/**
 * Base prototype for ximdex buttons tools
 * Implements KupuButton and extends XimdocTool
 */
var XimdocButton = Object.xo_create(new XimdocTool(), {

	_init: function(buttonid, commandfunc, tool) {
		this.buttonid = buttonid;
		this.button = getFromSelector(buttonid);
		this.commandfunc = commandfunc || this.commandfunc;
		this.tool = tool;
		this._enable = true;
	},

	initialize: function(editor) {
		this.editor = editor;
		this._fixTabIndex(this.button);
		addEventHandler(this.button, 'click', this.execCommand, this);
	},

	execCommand: function() {
		/* exec this button's command */
		if (this._enable) {
			this.commandfunc(this, this.editor, this.tool);
		}
	},

	commandfunc: function(button, editor, tool) {
		// do nothing
	},

	disable: function() {
		$(this.button).addClass('disabled');
		this._enable = false;
	},

	enable: function() {
		$(this.button).removeClass('disabled');
		this._enable = true;
	},

	isEnable: function() {
		return this._enable;
	}

});

/**
 * Base prototype for ximdex tool boxes
 * Extends KupuToolBox
 */
function XimdocToolBox() {
    	this.getActionDescription = function() {
    		return this._actionDescription || '';
    	};
    	this.setActionDescription = function(description) {
    		this._actionDescription = description || '';
    	};
};

XimdocToolBox.prototype = new KupuToolBox();

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision: 8084 $
 */





/**
 * A tool that knows how to add menu items to the context menu depending on the selected element
 */
function XimdocContextMenuTool() {

    	this.initialize = function(editor) {
        	this.editor = editor;
        	this.editor.logMessage(_('XimdocContextMenuTool tool initialized'));
    	};

    	this.createContextMenuElements = function(selNode, event) {
    	/**
    	 * Allowed elements:
    	 * 1.	Elements of the same type than the selected one.
    	 * 2.	Elements of the same type than the first descendent of the selected one.
    	 * 3.	Elements of the same type than the next brother of the selected one.
    	 *
    	 * TODO: Also, it would be needed to verify the cardinality with the schema... in future
    	 *
    	 * a) It should be kept the posibility of creating brothers of the same nodetype than the current one, but allowing to insert before or later.
    	 * b) The children insertion should be allowed checking against the schema.
    	 * c) The brother insertion should be allowed checking against the schema, otherwise, we should be as permissive as possible about order and cardinality.
    	 */

		var ret = new Array();

		if (this.editor.ximElement) {

			var rngElement = this.editor.ximElement.schemaNode;
			var rngParent = null;
			if (this.editor.ximParent) {
				rngParent = this.editor.ximParent.schemaNode;
			} else if (!this.editor.ximElement.isRoot) {
				return;
			}

			// Cutting, copying, pasting items
			this.createEditItems(ret, rngElement, rngParent);

			// If some text is selected: show "apply" type items.
			if (this.editor.selectedTextLength > 0) {
				// Create 'Apply' context menu elements.
				this.createApplyItems(ret, rngElement, rngParent);

			} else {

				// Creating 'Correct Spelling' context menu elements.
				this.createSpellcheckItems(ret, rngElement, rngParent);

				// Creating 'Annotation' context menu elements.
				this.createAnnotationItems(ret, rngElement, rngParent);

				// Creating 'Remove' context menu element.
				this.createRemoveItems(ret, rngElement, rngParent);

				// Creating 'Add Sibling' context menu elements.
				this.createSiblingItems(ret, rngElement, rngParent);

				// Creating 'Add Child' context menu elements.
				this.createChildItems(ret, rngElement, rngParent);

				// Creating 'ximlets' context menu elements.
				this.createXimletItems(ret, rngElement, rngParent, this.editor.ximElement.uid);

				// Creating 'dis-apply' context menu element.
				this.createDisapplyItems(ret, rngElement, rngParent);
			}
		}

		return ret;
    	};

	// Cutting, copying, pasting items
    	this.createEditItems = function(menu, rngElement, rngParent) {
    		if(this.editor.ximElement.isRoot) return;

		if(this.editor.ximElement.canBeCopied()) {
			menu.push(new ContextMenuElement(
							_('Cut') + ' ' + this.editor.ximElement.tagName,
							this.cutElementWrapper(this.editor.ximElement),
							this
							));
			menu.push(new ContextMenuElement(
							_('Copy') + ' ' + this.editor.ximElement.tagName,
							this.copyElementWrapper(this.editor.ximElement),
							this
							));
		}

		if (this.editor.clipboard) {
			menu.push(new ContextMenuElement(
							_('Paste') + ' ' + this.editor.clipboard.tagName,
							this.pasteElementWrapper(this.editor.ximParent, this.editor.ximElement),
							this
							));
		}

    	};

	// Creating 'Apply' context menu elements.
    	this.createApplyItems = function(menu, rngElement, rngParent) {
		var i = 0;
		var count = rngElement.childNodes.length;
		while (i < count) {
			if (i == 0) menu.push(new ContextMenuElement(_('-----'), function(){}, this));
			childElement = rngElement.childNodes[i];
			if (childElement.type.contains('apply')) {
				childName = childElement.tagName;
				menu.push(new ContextMenuElement(_('Apply:') + ' ' + childName, this.createElementWrapper(childName, this.editor.ximElement, null), this));
			}
			i++;
		}
    	};

	// Create 'Correct Spelling' context menu elements.
    	this.createSpellcheckItems = function(menu, rngElement, rngParent) {
		var clickedNode = this.editor.getClickedNode();
		var clickedNodeParent = this.editor.getClickedNode().parentNode;
		var clickedNodeParentText = clickedNodeParent.innerHTML;
		var owner = clickedNode.getAttribute('owner');
		if (owner == 'spellchecker') {
			menu.push(new ContextMenuElement(_('--------------'), function(){}, this));
			menu.push(new ContextMenuElement(_('Spell checking'), function(){}, this));
			menu.push(new ContextMenuElement(_('--------------'), function(){}, this));

			var word = clickedNode.textContent;
			count = this.editor.tools.ximdocspellcheckertool._spellCheckWordsArray.length;
			var checker = null;
			for (var i = 0; i < count; i ++) {
				if (this.editor.tools.ximdocspellcheckertool._spellCheckWordsArray[i].nodeValue == word) {
					checker = this.editor.tools.ximdocspellcheckertool._spellCheckWordsArray[i];
					break;
				}
			}

			menu.push(new ContextMenuElement(_('Leave word') + ' ' + word + ' ' + _('as it.'), this.editor.tools.ximdocspellcheckertool.replaceWord(word, word, clickedNodeParentText, clickedNodeParent, 'leave'), this.editor.tools.ximdocspellcheckertool));

			var suggestion = checker.parentNode.nextSibling;
			while(suggestion) {
				menu.push(new ContextMenuElement(_('Replace') + ' ' + word + ' ' + _('by') + ' ' + suggestion.textContent, this.editor.tools.ximdocspellcheckertool.replaceWord(word, suggestion, clickedNodeParentText, clickedNodeParent), this.editor.tools.ximdocspellcheckertool));
				suggestion = suggestion.nextSibling;
			}
		}
    	};

	// Create 'Annotation' context menu elements.
    	this.createAnnotationItems = function(menu, rngElement, rngParent) {
		//TODO: fundir con spellchecker?
		var clickedNode = this.editor.getClickedNode();
		var clickedNodeParent = this.editor.getClickedNode().parentNode;
		var clickedNodeParentText = clickedNodeParent.innerHTML;
		var owner = clickedNode.getAttribute('owner');
		if (owner == 'annotator') {
			menu.push(new ContextMenuElement(_('--------------'), function(){}, this));
			menu.push(new ContextMenuElement(_('ANNOTATION MENU'), function(){}, this));
			menu.push(new ContextMenuElement(_('--------------'), function(){}, this));

			var word = clickedNode.textContent;
			count = this.editor.tools.ximdocannotationtool._annotationWordsArray.length;
			var checker = null;
			for (var i = 0; i < count; i ++) {
				if (this.editor.tools.ximdocannotationtool._annotationWordsArray[i].nodeValue == word) {
					checker = this.editor.tools.ximdocannotationtool._annotationWordsArray[i];
					break;
				}
			}

			// TODO: Ofrecer info e interaccin con las anotaciones de la palabra word. See this.createSpellcheckItems
			if(checker) {
				menu.push(new ContextMenuElement(_('Annotate word ') + ' \'' + word + '\'', this.editor.tools.ximdocannotationtool.annotateWord(word)));
			}
		}
    	};

	// Create 'Remove' context menu element.
    	this.createRemoveItems = function(menu, rngElement, rngParent) {
    		if (this.editor.ximElement.isRoot || !this.editor.ximElement.isRemovable()) return;
		menu.push(new ContextMenuElement(_('-----'), function(){}, this));
		menu.push(new ContextMenuElement(_('Remove') + ': ' + this.editor.ximElement.tagName, this.removeElementWrapper(this.editor.ximElement), this));
    	};

	// Create 'Dis-Apply' context menu element.
    	this.createDisapplyItems = function(menu, rngElement, rngParent) {
    		if (this.editor.ximElement.isRoot || !this.editor.ximElement.isApplyable()) return;
		menu.push(new ContextMenuElement(_('-----'), function(){}, this));
		menu.push(new ContextMenuElement(_('Do not apply:') + ' ' + this.editor.ximElement.tagName, this.disApplyElementWrapper(this.editor.ximElement), this));
    	};

	// Create 'Add Sibling' context menu elements.
    	this.createSiblingItems = function(menu, rngElement, rngParent) {
    		if (this.editor.ximElement.isRoot) return;
		var i = 0;
		var count = rngParent.childNodes.length;
		if(count == 0)
			return;
		menu.push(new ContextMenuElement(_('-----'), function(){}, this));
		while (i < count) {
			var childElement = rngParent.childNodes[i];
			var childName = childElement.tagName;
			var button = this.editor.tools[childName + '_rngbutton'];
			menu.push(new ContextMenuElement(_('Add sibling:') + ' ' + childName, button.commandfunc, button));
			i++;
		}
    	};

	// Create 'Add Child' context menu elements.
    	this.createChildItems = function(menu, rngElement, rngParent) {
		var i = 0;
		var count = rngElement.childNodes.length;
		if(count == 0)
			return;
		menu.push(new ContextMenuElement(_('-----'), function(){}, this));
		while (i < count) {
			childElement = rngElement.childNodes[i];
			childName = childElement.tagName;
			var button = this.editor.tools[childName + '_rngbutton'];
			menu.push(new ContextMenuElement(_('Add child:') + ' ' + childName, button.addchildfunc, button));
			i++;
		}
    	};

	// Create 'ximlets' context menu elements.
    	this.createXimletItems = function(menu, rngElement, rngParent, uid) {
		if(!rngElement.type.contains('ximlet'))
			return;
		var ximElement = this.editor.getXimDocument().getElement(uid);
		//var button = this.editor.tools['ximletdrawerbutton'];
		menu.push(new ContextMenuElement(_('-----'), function(){}, this));
		menu.push(new ContextMenuElement(_('Toggle') + ' ' + _('ximlet'), this.editor.tools['ximlettool'].toggleXimlet(uid)));
		//menu.push(new ContextMenuElement(_('Edit') + ' ' + _('ximlet') + ' ' + _('content'), this.editor.tools['ximlettool'].openEditWindow(ximElement)));
		menu.push(new ContextMenuElement(_('Edit ximlet content'), this.editor.tools['ximlettool'].openEditWindow(ximElement)));
		//if(!this.editor.ximElement.isSectionXimlet())
		//	menu.push(new ContextMenuElement(_('Edit') + ' ' + _('ximlet') + ' ' + _('id'), button.commandfunc, button));
	};
};

XimdocContextMenuTool.prototype = new XimdocTool();

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */





var FloatToolbarToolBox = Object.xo_create(new XimdocToolBox(), {

	toolbar: null,
	buttons: null,

	initialize: function(tool, editor) {

		this.toolbarId = 'float-toolbar';
	    	this.buttons = [];
	    	this.tool = tool;
	        this.editor = editor;
		this.afterUpdateContent(null);
	        this.editor.logMessage(_('FloatToolbarToolBox tool initialized'));
	
	        this.registerButton(new ScrollDownButton({id: 'scrolldown-button', className: 'kupu-scrolldown', title: _('Scroll Down')}));
	        this.registerButton(new ScrollUpButton({id: 'scrollup-button', className: 'kupu-scrollup', title: _('Scroll Up')}));
	        this.registerButton(new PasteButton({id: 'paste-button', className: 'kupu-paste', title: _('Paste')}));
	        this.registerButton(new CopyButton({id: 'copy-button', className: 'kupu-copy', title: _('Copy')}));
	        this.registerButton(new CutButton({id: 'cut-button', className: 'kupu-cut', title: _('Cut')}));
	},

	_elementIsallowed: function(element) {
		var rngElement = element['rngElement'] || element['schemaNode'];
		if (!rngElement) return false;
		var allowed = (!rngElement.type.contains('apply')) && (rngElement.tagName != 'docxap');
		//allowed = allowed && element.getAttribute('editable') != 'no';
		return allowed;
	},

	getToolbar: function() {
		return $('#'+this.toolbarId, this.editor.getBody())[0];
	},

	hasButtons: function() {
		return this.buttons.length > 0 ? true : false;
	},

	registerButton: function(button) {
		if ($('#'+button.id, this.toolbar).length > 0) return;
		button.initialize(this, this.editor);
		this.buttons.push(button);
	},

	unregisterButton: function(button) {
		var l = this.buttons.length;
		while (l--) {
			if (this.buttons[l].id == button.buttonid) {
				$(this.buttons[l].getButton()).unbind().remove();
				delete this.buttons[l];
				break;
			}
		}
	},

	beforeUpdateContent: function(options) {
		var l = this.buttons.length;
		while (l--) {
			this.buttons[l].beforeUpdateContent(options);
		}
		this.toolbar.unbind().empty().remove();
		this.toolbar = null;
	},

	/**
	 * Function which updates the events handlers after updating the editor content
	 */
	afterUpdateContent: function(options) {

		var body = this.editor.getBody();

		var html = '<div class="kupu-tb kupu-float-toolbar" id="'+this.toolbarId+'">' +
			'<span id="kupu-tb-floatbuttons" class="kupu-tb-buttons">' +
			'	<span id ="kupu-tb-floatbuttonsgroup" class="kupu-tb-buttongroup">' +
			'	</span>' +
			'</span>' +
		'</div>';

		// Appending the toolbar to the document body, it will be positioned later
		this.toolbar = $(html, body).appendTo(body);
		this.toolbar.mouseout(
			function(event) {
				this.onMouseOut({selNode: this.toolbar[0].ximElement, event: event});
			}.bind(this)
		);

		var l = this.buttons.length;
		while (l--) {
			$(this.buttons[l].renderize(), body).appendTo($('#kupu-tb-floatbuttonsgroup', this.toolbar));
			$(this.buttons[l].getButton())
				.click(
					function(event) {
						this.commandfunc(event);
					}.bind(this.buttons[l])
				)
				.mouseout(
					function(event) {
						this.onMouseOut({selNode: this.toolbar[0].ximElement, event: event});
					}.bind(this)
				);
		}

		// This doesn't works for images
		this.toolbar.designMode = 'Off';
		this.toolbar.hide();
	},

	/**
	 * Function which changes the menu position
	 */
	_moveToolbar: function(options) {

		var _elem = $(options.selNode);
		
//		var top = _elem.position().top; // + _elem.height() - 5;
//		var left = _elem.position().left + _elem.width(); // - this.toolbar.width();
		var top = options.event.pageY;
		var left = options.event.pageX;

		this.toolbar.css({
			position: 'absolute',
			top: top+'px',
			left: left+'px'
		});

		this.toolbar[0].ximElement = _elem[0].ximElement;
	},
	
	/**
	 * Function which returns if there is paste job pending
	 */
	pendingPaste: function() {
		if (!this.editor.clipboard) 
			return false;
		return true;
	},
	
	/**
	 * Function which makes visible all buttons
	 */
	showAllButtons: function() {
		$('.xedit-floatbutton', this.toolbar).show();
	},
	
	/**
	 * Function which hides all buttons
	 */
	hideAllButtons: function() {
		$('.xedit-floatbutton', this.toolbar).hide();
	},
	
	/**
	 * Function which hides buttons with no effect
	 */
	toggleButtons: function() {
		if(!this.toolbar[0].ximElement.isSelectable(this.editor.nodeId)) {
			this.hideAllButtons();
			return;
		}
		
		if(!this.toolbar[0].ximElement.findNextAllowedPosition('up'))
			$('#scrollup-button', this.toolbar).hide();
		if(!this.toolbar[0].ximElement.findNextAllowedPosition('down'))
			$('#scrolldown-button', this.toolbar).hide();
		if(!this.toolbar[0].ximElement.canBeCopied()) {
			$('#copy-button', this.toolbar).hide();
			$('#cut-button', this.toolbar).hide();
		}
		if(!this.pendingPaste())
			$('#paste-button', this.toolbar).hide();
	},

	/**
	 * Function which shows the scroller menu
	 */
	onMouseOver: function(options) {
		if (!this.toolbar || !this._elementIsallowed(options.selNode) || !this.hasButtons())
			return;
		this._moveToolbar(options);
		this.toggleButtons();
		this.toolbar.show();
	},

	/**
	 * Function which hides the scroller menu
	 */
	onMouseOut: function(options) {

		if (!this.toolbar || !this._elementIsallowed(options.selNode) || !this.hasButtons()) return;

		var hide = true;
		try {
			var related = options.event.relatedTarget;
			hide = $(related).parents('#'+this.toolbarId).length == 0;
		} catch (e) {
			//console.error(e);
		}

		if (!hide) return;
		
		this.showAllButtons();
		this.toolbar.hide();
		this.toolbar[0].isVisible = false;
	}

});


var FloatButton = Object.xo_create(new XimdocButton(), {
    
    _init: function(options) {
    	this.options = options;
	this.editor = null;
	this.toolbox = null;
	this.buttonid = null;
	this.className = null;
	this.title = null;
    },

    initialize: function(toolbox, editor) {
	    this.toolbox = toolbox;
	    this.editor = editor;
	    this.buttonid = this.options.id;
	    this.className = this.options.className;
	    this.title = this.options.title;
    },

    commandfunc: function(event) {
		this.editor.alert(_('Implement commandfunc method!'));
    },

    getButton: function() {
    	return $('#'+this.buttonid, this.toolbox.getToolbar())[0];
    },

    renderize: function() {
    	return '<button type="button" class="'+this.className+' xedit-floatbutton" id="'+this.buttonid+'" title="'+this.title+'">&#xA0;</button>';
    }
});


var ScrollUpButton = Object.xo_create(FloatButton, {

	commandfunc: function(event) {
		var ximElement = this.toolbox.getToolbar().ximElement;
		if (ximElement.scrollUp()) {
			this.setActionDescription(_('Scroll up'));
			this.editor.updateEditor({caller: this});
		}
    }
});

var ScrollDownButton = Object.xo_create(FloatButton, {

	commandfunc: function(event) {
		var ximElement = this.toolbox.getToolbar().ximElement;
		if (ximElement.scrollDown()) {
			this.setActionDescription(_('Scroll down'));
			this.editor.updateEditor({caller: this});
		}
    }
});

var CutButton = Object.xo_create(FloatButton, {

    commandfunc: function(event) {
		var ximElement = this.toolbox.getToolbar().ximElement;
		this.cutElement(ximElement);
    }
});

var CopyButton = Object.xo_create(FloatButton, {

    commandfunc: function(event) {
		var ximElement = this.toolbox.getToolbar().ximElement;
		this.copyElement(ximElement);
    }
});

var PasteButton = Object.xo_create(FloatButton, {

    commandfunc: function(event) {
		var ximElement = this.toolbox.getToolbar().ximElement;
		this.pasteElement(ximElement.parentNode, ximElement);
    }
});


function XimdocEditableContentTool() {
	this.updateState = function(options) {
		if (!options.selNode || !options.event || !['click', 'keyup'].contains(options.event.type)) return;
		options.selNode = this.editor.selNode;
		this.editor.setEditableContent(options.selNode);
    	};
};

XimdocEditableContentTool.prototype = new XimdocTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


function HoverTool() {

	this.editor = null;
	this._body = null;
	this._dispatchEvents = false;

    	this.initialize = function(editor) {
        	this.editor = editor;
        	this.toolboxes = {};
        	this._body = editor.getBody();
		this.afterUpdateContent(null);
	};

    	this.beforeUpdateContent = function(options) {
    		this._dispatchEvents = false;
		this.editor.elements.unbind('hover');
		for (id in this.toolboxes) {
			if (this.toolboxes[id]['beforeUpdateContent']) this.toolboxes[id].beforeUpdateContent(options);
		};
    	};

    	this.afterUpdateContent = function(options) {

    		// Important!
    		this._body = this.editor.getBody();

    		this.editor.elements = $('[uid]', this._body);
        	this.editor.elements.each(function(index, elem) {
        		$(elem).hover(
	        		function(e) {
		        		var target = e.currentTarget || e.target;
					this.updateState({caller: this, selNode: target, event: e});
	        		}.bind(this),
	        		function(e) {
		        		var target = e.currentTarget || e.target;
					this.updateState({caller: this, selNode: target, event: e});
	        		}.bind(this)
			);
	    	}.bind(this));
		
		for (id in this.toolboxes) {
			if (this.toolboxes[id]['afterUpdateContent']) this.toolboxes[id].afterUpdateContent(options);
		};
		this._dispatchEvents = true;
    	};

    	this.updateState = function(options) {

    		// NOTE: jQuery uses 'mouseenter' and 'mouseleave' ... ???
		if (!this._dispatchEvents || !options.selNode)
			return;
		if(options.event && 
			//!['mouseover', 'mouseenter', 'mouseout', 'mouseleave', 'click', 'keyup'].contains(options.event.type))
			!['mouseover', 'mouseout', 'click', 'keyup'].contains(options.event.type))
			return;

		// NOTE: event will be the jQuery event object at this point.
		// Registered object can obtain the original event object using event.originalEvent
		var ids=["draggabletoolbox","highlighttoolbox"];
		for (var i=0;i<ids.length;i++) {
			var toolbox = this.toolboxes[ids[i]];
			try {
				if (toolbox['updateState']) {
					toolbox.updateState(options);
				}
			} catch (e) {
				this.editor.logMessage(_('Exception while processing updateState on ${id}: ${msg}', {'id': id, 'msg': e.message}), 2);
			}
		};
    	};
};

HoverTool.prototype = new XimdocTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




function EditorViewTool() {

   	this.VIEW_TREE = 'tree';
   	this.VIEW_DESIGN = 'normal';
   	this.VIEW_REMOTE = 'pro'; //Why is not called as "remote"?

	this.editor = null;
	this._body = null;

	this.treeButton = null;
	this.designButton = null;
	this.remoteButton = null;

    this.initialize = function(editor) {

        this.toolboxes = {};
        this.editor = editor;
        this._body = editor.getBody();

        this.treeButton = new KupuButton('kupu-treeview-button', this._getSetViewWrapper(this.VIEW_TREE));
		editor.registerTool('treeview', this.treeButton);
        this.designButton = new KupuButton('kupu-designview-button', this._getSetViewWrapper(this.VIEW_DESIGN));
		editor.registerTool('designview', this.designButton);
        //this.remoteButton = new KupuButton('kupu-remoteview-button', this._getSetViewWrapper(this.VIEW_REMOTE));
		//editor.registerTool('remoteview', this.remoteButton);

		this.activateButtons();
    };

    this._getSetViewWrapper = function(view) {
    	return function() {
    		this.setView(view);
    	}.bind(this);
    };

    this.setView = function(view) {

		 loadingImage.showLoadingImage();
		this.editor.setView(view);

		$(this.treeButton.button).removeClass('kupu-treeview-pressed').addClass('kupu-treeview');
		$(this.designButton.button).removeClass('kupu-designview-pressed').addClass('kupu-designview');
		//$(this.remoteButton.button).removeClass('kupu-remoteview-pressed').addClass('kupu-remoteview');

		switch (view) {
			case this.VIEW_TREE:
				$(this.treeButton.button).addClass('kupu-treeview-pressed').removeClass('kupu-treeview');
				break;
			case this.VIEW_DESIGN:
				$(this.designButton.button).addClass('kupu-designview-pressed').removeClass('kupu-designview');
				break;
			case this.VIEW_REMOTE:
				//$(this.remoteButton.button).addClass('kupu-remoteview-pressed').removeClass('kupu-remoteview');
				break;
		}

		// XSLT request
		var xslIncludesOnServer = $('.kupu-fulleditor .kupu-ximparams #kupu-xslIncludesOnServer').html().trim();
		var includesInServer="";
		//Avoid includes tag in xsl when by configuration or when browser is in safari or chrome
		if (xslIncludesOnServer == 1 || IS_SAFARI || IS_CHROME)
		    includesInServer = "&includesInServer=1";
		var xslUrl = this.editor.getBaseURL() + '&ajax=json&method=getXslFile'+includesInServer+'&view=' + this.editor.getView();
		this.editor.fileRequest('_xslDom', xslUrl, function() {
			this.editor.logMessage(_('View changed to') + ' ' + _(view));
		}.bind(this), true);
    };

    this.activateButtons = function() {
    	var views = this.editor.options.availableViews;
        if (!views.contains(this.VIEW_TREE)) this.treeButton.disable();
		if (!views.contains(this.VIEW_DESIGN)) this.designButton.disable();
		//if (!views.contains(this.VIEW_REMOTE)) this.remoteButton.disable();
    };
};

EditorViewTool.prototype = new XimdocTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */

/**
 * Checks document spelling.
 */

function XimdocSpellCheckerTool() {

	this._highlightStartTag = null;
	this._highlightEndTag = null;
	this._spellCheckWordsArray = [];
	this._spellCheckDoc = null;
	this.active = false;
	this.searchedTerms = '';

    	this.initialize = function (editor) {

        	this.editor = editor;
        	this._highlightStartTag = '<font owner="spellchecker" class="spellchecker">';
        	this._highlightEndTag = '</font>';
        	this.editor.logMessage(_('Spell checking tool initialized'));
    	};

    	this.beforeUpdateContent = function(options) {
		this.editor.removeCheckSpellingTags(this.editor.getBody());
		return;
	}

    	this.afterUpdateContent = function(options) {
		if(this.isActive()) {
			this._setSpellCheckDoc(this);
		}
		return;
    	};

    	this.doCheck = function () {
		this.toggle();
        	this.editor.updateEditor({updateContent: true});
		//calling loadingImage after updateEditor to show some feedback to the user.
		if(this.isActive())
			loadingImage.showLoadingImage();
    	}

    	this._setSpellCheckWordsArray = function () {
		var nodes = this._spellCheckDoc.evaluate("//name//text()", this._spellCheckDoc, null, XPathResult.ANY_TYPE,null);
		var result = nodes.iterateNext();
		this._spellCheckWordsArray = [];
		while (result) {
			this._spellCheckWordsArray.push(result);
			result = nodes.iterateNext();
		}
		this._setSearchedTerms();
    	}

    	this._setSearchedTerms = function () {
		var searchedTerm = "";
		var searchLength = this._spellCheckWordsArray.length;
		this.searchedTerms = "";
		if (searchLength == 0) return;
		for (var k = 0; k < searchLength; k ++) {
			searchedTerm = this._spellCheckWordsArray[k].textContent;
			searchedTerm = searchedTerm.replace("(", "\\\(");
			searchedTerm = searchedTerm.replace(")", "\\\)");
			searchedTerm = searchedTerm.replace("-", "\\\-");
			this.searchedTerms += searchedTerm;
			if(k < (searchLength - 1))
				this.searchedTerms += "|";
		}
    	}

    	this._setSpellCheckDoc = function (XimdocSpellCheckerTool) {
		// Calling SpellCheckingHandler
		var content = encodeURIComponent($('body', this.editor.getInnerDocument()).text());
		var lang = "es";
		var encodedContent = "&nodeid=" + this.editor.nodeId +
							 "&content=" + content +
							 "&lang=" + encodeURIComponent(lang);

		com.ximdex.ximdex.editors.SpellCheckingHandler(kupu.getBaseURL(), encodedContent, {
			onComplete: function(req, json) {
		        	this._spellCheckDoc = this.editor.createDomDocument(req.responseText);
		        	this._setSpellCheckWordsArray();
				this.applyCheckSpelling();
				loadingImage.hideLoadingImage();
			}.bind(this),
			onError: function(req) {
				loadingImage.hideLoadingImage();
				this.editor.alert(_('Error obtaining spell checking file.')+'<br/><br/>'+_('Maybe your text is too long and/or there are so much words to correct in your document.')+'<br/><br/>'+_('Be sure that your content and the base language of your document are the same.'));
				this.toggle();
				$(this.editor.tools.spellchecker.button).toggleClass('kupu-spellchecker-pressed').toggleClass('kupu-spellchecker');
			}.bind(this)
		});
    	}

	this.applyCheckSpelling = function (node) {

		var doc = this.editor.getInnerDocument();
		var searchedTerms = this.searchedTerms.split('|').unique().join('|');
//		var searchText = "([\\s\\.,\\n\\r\\t\\:])(" + this.searchedTerms + ")([\\s\\.,\\n\\r\\t\\:])";
		var searchText = "\\b(" + searchedTerms + ")\\b";
		var searchNode = node ? node : doc.getElementsByTagName('body')[0];
//		var replacement = "$1" + this._highlightStartTag + "$2" + this._highlightEndTag + "$3";
		var replacement = this._highlightStartTag + "$1" + this._highlightEndTag;

	    	var regex = typeof searchText === 'string'? new RegExp(searchText, 'g'): searchText;
		var childNodes = searchNode.childNodes;
	    	var cnLength = childNodes.length;
	    	var excludes = ['html', 'head', 'style', 'title', 'link', 'meta', 'script', 'object', 'iframe'];

	    while (cnLength--) {

	        var currentNode = childNodes[cnLength];

	        // ELEMENT_NODE == 1
	        // TEXT_NODE == 3

	        if (currentNode.nodeType === currentNode.ELEMENT_NODE && !excludes.contains(currentNode.nodeName.toLowerCase())) {
	            this.applyCheckSpelling(currentNode);
	            continue;
	        }

	        if (currentNode.nodeType !== currentNode.TEXT_NODE || !regex.test(currentNode.data)) {
	            continue;
	        }


	        var parent = currentNode.parentNode;
            var frag = (function() {

//            	console.log(currentNode.data.match(regex));

            	var html = currentNode.data.replace(regex, replacement);
                var wrap = document.createElement('div');
                var frag = document.createDocumentFragment();

                wrap.innerHTML = html;
                while (wrap.firstChild) {
                    frag.appendChild(wrap.firstChild);
                }

                return frag;
            })();

	        parent.insertBefore(frag, currentNode);
	        parent.removeChild(currentNode);
	    }

	}.bind(this);

    	this.replaceWord = function(word, suggestion, clickedNodeParentText, clickedNodeParent, mode) {
		return function () {
			if(mode == 'leave')
				clickedNodeParentText = clickedNodeParentText.replace(this._highlightStartTag + word + this._highlightEndTag, suggestion);
			else
				clickedNodeParentText = clickedNodeParentText.replace(this._highlightStartTag + word + this._highlightEndTag, suggestion.textContent);
			clickedNodeParent.innerHTML = clickedNodeParentText;
		}.bind(this);
    	}

    	this.isActive = function () {
    		return this.active;
    	}

    	this.enable = function () {
    		this.active = true;
    	}

    	this.disable = function () {
    		this.active = false;
    	}

    	this.toggle = function () {
    		if(this.isActive()){
    			this.disable();
		}
    		else{
    			this.enable();
		}
    	}
}

XimdocSpellCheckerTool.prototype = new XimdocTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




/**
 * Annotate document.
 */

function XimdocAnnotationTool() {

	this._highlightStartTag = null;
	this._highlightEndTag = null;
	this._annotationDoc = null;

    this.initialize = function (editor) {

        this.editor = editor;
        this._highlightStartTag = '<font owner="annotator" style="border: 2px solid yellow; background-color: red; color: white;">';
        this._highlightEndTag = '</font>';
        this.editor.logMessage(_('Annotation tool initialized'));
    };

//	this.beforeUpdateContent = function(options) {
//	    //this.editor.removeAnnotationTags(this.editor.getBody());
//		return;
//	}
//
//	this.afterUpdateContent = function(options) {
//		//this.showAnnotation();
//		return;
//	};

    this.doAnnotate = function () {
		 loadingImage.showLoadingImage();
		this._setAnnotationDoc(this);
    }

    this._setAnnotationDoc = function (XimdocAnnotationTool) {

		//Update content before send the info to stanbol and zemanta
		this.editor.updateEditorContent();
		// Calling AnnotationHandler
		//var content = encodeURIComponent(this.editor._ximdoc._xmldoc.documentElement.textContent);
		var content= this.editor._ximdoc.saveXML({
                        asString: true,
                        hideXimlets: false,
                        resolveXimlinks: false,
                        onCreateNode: null
		});
		content= encodeURIComponent(content);
		var lang = "es";
		var encodedContent = "&nodeid=" + this.editor.nodeId +
							 "&content=" + content +
							 "&lang=" + encodeURIComponent(lang);

		com.ximdex.ximdex.editors.AnnotationHandler(kupu.getBaseURL(), encodedContent, {
			onComplete: function(req, json) {
				if(req.responseText != '' && req.responseText !== null) {
//					var responseObj = eval('(' + req.responseText + ')');
					/*console.debug(req);
					console.debug(json)*/
					if(json.status == 'ok') {
						var options = {selNode: this.editor.getSelectedNode(), caller: this};
						this.editor.beforeUpdateContent(options);
						this._annotationDoc = json;

						//This method shows all the references marked on the text.
						//this.showAnnotation();

						this.editor.afterUpdateContent(options);
						loadingImage.hideLoadingImage();
					} else {
						loadingImage.hideLoadingImage();
						//this.editor.alertvideo(_('References could not be loaded.') + "<br/><br/>\n" + _('Reason: ') + json.status + json.videourl);
						this.editor.alertvideo(json.status + json.videourl);
					}
				} else {
					loadingImage.hideLoadingImage();
					this.editor.alert(_('Error while obtaining annotations. ') + _('No server answer.'));
				}
				if (this.toolboxes['annotationstoolbox']) {
					this.toolboxes['annotationstoolbox'].refreshInfo(this._annotationDoc);
				}
				}.bind(this),
			onError: function(req) {
				loadingImage.hideLoadingImage();
				//console.info(req);
				this.editor.alert('Error while obtaining annotation file.');
			}.bind(this)
		});
    }

    this.showAnnotation = function () {

		var doc = this.editor.getInnerDocument();
		var bodyText = $('body', doc).html();
		var searchedTerms = "";

		var searchLength = this._annotationDoc.zemanta.markup.links.length;
		if (searchLength == 0) return;
		for (var k = 0; k < searchLength; k ++) {
			searchedTerm = this._annotationDoc.zemanta.markup.links[k].anchor;
			searchedTerm = searchedTerm.replace("(", "\\\(");
			searchedTerm = searchedTerm.replace(")", "\\\)");
			searchedTerm = searchedTerm.replace("-", "\\\-");
			searchedTerms += searchedTerm;
			if(k < (searchLength - 1))
				searchedTerms += "|";
		}

		var rgx = new RegExp("([^a-zA-Z0-9_>]{1})(" + searchedTerms + ")([^a-zA-Z0-9_<]{1})", "g");
		bodyText = bodyText.replace(rgx, "$1" + this._highlightStartTag + "$2" + this._highlightEndTag + "$3");
		$('body', doc).html(bodyText);
		this.editor.extendElements();
    }

    this.annotateWord = function (word) {
    	//this.editor.updateEditor();
    	return null;
    }
}

XimdocAnnotationTool.prototype = new XimdocTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




/**
 * Previews document.
 */

function XimdocPreviewTool() {

	this.initialize = function (editor) {
	        this.editor = editor;
	};

	this.preview = function () {

    		var imagestool = this.editor.getTool('imagestool');
	    	imagestool.updateImagesSize(this.editor.getInnerDocument());

		// It's necessary to update editor content before previewing
		this.setActionDescription(_('Show preview'));
		this.editor.updateEditor({caller: this});

		var content = this.editor._ximdoc.saveXML({
			asString: true,
			hideXimlets: true
	 	});

		//Get selected channel
		var channelSelector = this.editor.tools.ximdoctool.toolboxes.channelstoolbox.select;
		var channelValue = channelSelector.options[channelSelector.selectedIndex].value;

		// Calling PreviewHandler
		var encodedContent = "&nodeid=" + this.editor.nodeId +
				 "&channelid="+ channelValue +
				 "&content=" + encodeURIComponent(content);

		com.ximdex.ximdex.editors.PreviewHandler(kupu.getLoadActionURL(), encodedContent, {
			onComplete: function(req, json) {
//				this.showPreviewByContent(req.responseText);
				this.showPreviewByUrl(json.prevUrl);
			}.bind(this),
			onError: function(req) {
				this.editor.alert(_('Error obtaining preview.'));
			}.bind(this)
		});
	};

	this.showPreviewByContent = function(content) {

        	var win = window.open();
			win.document.write(content);
			win.document.close();
			delete win;
		};

	
	this.showPreviewByUrl = function(url) {

        	var win = window.open(url);
			delete win;
	};
}

XimdocPreviewTool.prototype = new XimdocTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




/**
 * Function which detects Ximdex Ximlets and calls ximletdrawer for creating/editing them
 */

function ximletTool() {
    /* Adding and updating ximlet references */

	//executed when the tool is initialized
	this.initialize = function(editor) {
        	this.editor = editor;
        	this.editor.logMessage(_('Ximlet tool initialized'));
    	};

	//updating the ximlet IdNode, and then the editor
    	this.updateXimlet = function (ximletElement, ximletNodeId) {
        	ximletElement.ximElement.setMacroId(ximletNodeId);
        	ximletElement.ximElement.refresh(this._setXimletStyle.bind(this));
        	this.editor.reloadXml();
    	};

    	this.beforeSave = function () {
    		this._removeXimletsContent();
    	}

    	this.updateState = function (options) {
//		if (options.event && options.event.type != 'dblclick') return;
    	}

	//executed before update the iframe content
    	this.beforeUpdateContent = function(options) {
		//finding ximlets in the document
		$('[uid]', options.xslResult).each(
			function(index, elem) {
				var uid = elem.getAttribute('uid');
				try {
					var ximElement = this.editor.getXimDocument().getElement(uid);
					var rngElement = this.editor.getXimDocument().getElement(uid).schemaNode;
					if (rngElement.type.contains('ximlet')) {
		    				this._generateXimletElement(elem, options.xslResult);
					}
				} catch(e) {
					console.error(_("ERROR while finding Ximlets. "),rngElement);
				}
			}.bind(this)
		);
		return;
    	};

	//executed after the iframe content is updated
    	this.afterUpdateContent = function(options) {
		this.initialize(options.editor);
		var frameBody = this.editor.getBody();

		//finding ximlets in the document
		$('div.kupu-ximlet-box', frameBody).each(
			function(index, elem) {
				if (elem.rngElement.type.contains('ximlet')) {
			    		this._initializeXimletElement(elem);
				}
			}.bind(this) //change the context to the tool context
		);
		return;
    	};

	//called from beforeUpdateContent. Creates the html ximlet structure on the editor
    	this._generateXimletElement = function(ximlet, domdoc) {

		var uid = ximlet.getAttribute('uid');
		var ximElement = this.editor.getXimDocument().getElement(uid);

		var newXimlet = domdoc.createElement('div');
		newXimlet.setAttribute('class', '');

		var span = domdoc.createElement('span');
		span.setAttribute('editable', 'no');
		span.setAttribute('class', 'kupu-text');
		newXimlet.appendChild(span);

		var imgEdit = domdoc.createElement('span');
		imgEdit.setAttribute('editable', 'no');
		imgEdit.setAttribute('class', 'kupu-ximlet-edit');
		newXimlet.appendChild(imgEdit);

		var imgToggle = domdoc.createElement('span');
		imgToggle.setAttribute('editable', 'no');
		imgToggle.setAttribute('class', 'kupu-ximlet-toggle-opened');
		newXimlet.appendChild(imgToggle);

		var it = new DOMAttrIterator(ximlet);
		while (it.hasNext()) {
			var attr = it.next();
			newXimlet.setAttribute(attr.nodeName, attr.nodeValue);
			if(attr.nodeName == 'editable' && attr.nodeValue == 'no')
				return;
		}

		ximlet.parentNode.insertBefore(newXimlet, ximlet);

		newXimlet.setAttribute('class', 'kupu-ximlet-box');
		newXimlet.setAttribute('ximlet_macro', $(ximlet).text());

		if(!ximElement.status) ximElement.status='visible';

		if(ximElement.status == 'hidden') {
			$(ximlet).remove(); //delete from the DOM
			if($(imgToggle).hasClass('kupu-ximlet-toggle-opened')){
				$(imgToggle).attr('class','kupu-ximlet-toggle-closed');
			}
    		} else {
			if($(imgToggle).hasClass('kupu-ximlet-toggle-closed')){
				$(imgToggle).removeClass('kupu-ximlet-toggle-closed').addClass('kupu-ximlet-toggle-opened');
			}
    		}
    	};

    	this._initializeXimletElement = function(ximlet) {
		//$(ximlet).unbind('dblclick');

		$(ximlet).css('border', '1px dotted black');
		$(ximlet).css('padding', '5px');
		$(ximlet).css('background-color', '#999');
		$(ximlet).css('color', '#FFF');
		$(ximlet).css('position', 'relative');

		$(ximlet).fadeTo('fast', 0.6);

		$(ximlet).next().contents().filter(function() {return this.nodeType == Node.TEXT_NODE;}).remove();
		$(ximlet).next().filter('[uid="' + $(ximlet).attr('uid') + '"]').children().fadeTo('fast', 0.5);
		//$(ximlet).next().filter('[uid="' + $(ximlet).attr('uid') + '"]').children().css('background-color', 'orange');
		try {
			$(ximlet).next().filter('[uid="' + $(ximlet).attr('uid') + '"]').children().css('border', '1px dotted black');
			//$(ximlet).css('top', $($(ximlet).next().filter('[uid="' + $(ximlet).attr('uid') + ']'").children()[0]).position().top);
			$(ximlet).css('left', $($(ximlet).next().filter('[uid="' + $(ximlet).attr('uid') + '"]').children()[0]).position().left);
		} catch(e) {
			//console.warn(e); //Something is going wrong when getting in for second time
		}

		var macro = ximlet.getAttribute('ximlet_macro');
		if (macro) {
			ximlet.attributes.removeNamedItem('ximlet_macro');
		} else {
			macro = ximlet.ximElement.macro;
		}

		$.extend(ximlet.ximElement, {
			macro: macro,
			htmlElement: ximlet,

			refresh: function(callback) {
				this.setMacroId();
				this.setEditable(callback);
			},

			getMacroId: function() {
				var macroId = (this.attributes['ximlet_id']) ? this.attributes['ximlet_id'] : null;
				if (macroId === null || !macroId) {
					macroId = '00000';
				}
		    	return macroId;
			},

			setMacroId: function(id) {
				// TODO: Validate ximletId (integer, positive)
				id = id || this.getMacroId();
		        this.attributes['ximlet_id'] = id;
		        this.macro = '@@@GMximdex.ximlet(' + id + ')@@@';
		        this.value = [this.macro];
		        $(this.htmlElement).children('span.kupu-text').text('Ximlet ID:' + id);
		        this.isEditable = undefined;
			},

			setEditable: function(callback) {

				if (this.isEditable != undefined) {
					callback(this.htmlElement);
				} else {
					if(this.editor) {
						$.getJSON(
				    		window.url_root + '/xmd/loadaction.php',
				    		{actionid: this.editor.actionId, nodeid: this.getMacroId(), ajax: 'json', method: 'canEditNode'},
				    		function(data, textStatus) {
				    			if (textStatus == 'success') {
				    				this.isEditable = data.editable;
						    		callback(this.htmlElement);
						    	}
				    		}.bind(this)
				    	);
			    	}
				}

			}
		});
		ximlet.ximElement.refresh(this._setXimletStyle.bind(this));

    	};

    	this.ximletDblClick = function(event) {
		// Fix for IE. currentTarget is NULL and target is the span element
		var target = event.currentTarget || event.target;
		if (!target['ximElement']) {
			target = target.parentNode;
		}

		//confirm dialog functions: Yes pressed, go on.
		var cbYes = function() {
			var macroId = target.ximElement.getMacroId();
			var url = window.url_root + '/xmd/loadaction.php?actionid='+this.editor.actionId+'&nodes[]='+macroId;
			var win = window.open(url);

			// Register unload event so we can refresh the ximlet content
			// See startKupu()
			var ximletid = 'unload_ximlet_'+macroId;
			window[ximletid] = function(event) {
				// do things, refresh, stuff, whatever...
				delete window[ximletid];
			};
		}.bind(this);

		//confirm dialog functions: No pressed, cancel action.
		var cbNo = function() {
		}

		if(target.ximElement.isSectionXimlet()){
			this.editor.confirm(_('WARNING: You are going to edit a ximlet which is linked to a section.\n\n This action will affect to all the section documents. Are you sure you want to continue?'), {"yes": cbYes, "no": cbNo});
		}
		else{
			this.editor.confirm(_('Do you want to edit the Ximlet in a new tab?'), {"yes": cbYes, "no": cbNo});

		}

    	};

	//called from ximdextools.js. It's executed to edit a ximlet in another browser tab
    	this.openEditWindow = function(ximElement) {
    		return function () {
    			this.ximletDblClick({ //event launch by the user, not the browser
    				target: {
    					ximElement: ximElement
    				}
    			});
    		}.bind(this);
    	}

    	this._setXimletStyle = function(divXimlet) {
		var editable = divXimlet.ximElement.isEditable;
		var showable= divXimlet.ximElement.status;
		var isSectionXimlet = divXimlet.ximElement.isSectionXimlet();

		if(editable) {	$(divXimlet).addClass('kupu-ximlet-editable');}
		else{$(divXimlet).addClass('kupu-ximlet-noeditable');}

		if(showable=="visible"){ $(divXimlet).addClass('kupu-ximlet-visible');}
		else{ $(divXimlet).addClass('kupu-ximlet-hidden');}

		if(isSectionXimlet) {$(divXimlet).addClass('kupu-ximlet-section');}

		//$('.kupu-ximlet-edit').click(this.ximletDblClick.bind(this).bind(this));
		$('.kupu-ximlet-edit').click(this.ximletDblClick.bind(this));
		//$('.kupu-ximlet-toggle-opened', divXimlet).click(this.toggleXimlet(divXimlet.ximElement.uid).bind(this));
//		$('.kupu-ximlet-toggle-opened').bind('dblclick', function(){window.alert("Pincho!!");});
//		$('.kupu-ximlet-toggle-closed', divXimlet).click(this.toggleXimlet(divXimlet.ximElement.uid).bind(this));

/*
$('.clickme').bind('click', function() {
  // Bound handler called.
});

*/

    	};

	//called from ximdextools.js. Executes when the context menu toggle options is clicked.
    	this.toggleXimlet = function(uid) {
		return function (event) {
			var ximElement = this.editor.getXimDocument().getElement(uid);

			if(!ximElement.status) ximElement.status='visible';

			if(ximElement.status == 'hidden') {
				ximElement.status = 'visible';
			} else {
				ximElement.status = 'hidden';
			}
			this.editor.updateEditor({caller: this});
		}.bind(this);
    	}

	this._removeXimletsContent = function() {
    		var ximModel = this.editor.getXimDocument().getXimModel();
    		for(var ximElement in ximModel) {
    			if(ximModel[ximElement].attributes['ximlet_id']) {
    				var childs = ximModel[ximElement].childNodes;
    				var length = childs.length;
    				for(var i = 0; i ++; i < length) {
	    				this.editor.getXimDocument().removeChild(childs[i]);
	    			}
    			}
    		}
	}

	this._existsXimlet = function(ximletId) {
    		var ximModel = this.editor.getXimDocument().getXimModel();
    		for(var id in ximModel) {
			var ximElement = ximModel[id];
			var rngElement = ximElement.schemaNode;
			if (rngElement.type.contains('ximlet') && ximElement.attributes['ximlet_id'] == ximletId) {
				return true;
			}
    		}
    		return false;
	}

}

ximletTool.prototype = new XimdocTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




/**
 * Base tool for tables and lists management
 */
function StructuredListTool() {

	this._current_uid = null;
	this._current_model = null;
	this._current_rngModel = null;
	this._allowed_uids = null;
	this._valid_tags = null;	// Overwrite in subclasses!

	this.initialize = function(editor) {
		this.editor = editor;
		this.parentClass.editor = editor;
		this._allowed_uids = [];
		this.afterUpdateContent(null);
	};

	this.updateState = function(options) {

		if (!options.selNode || !options.event || options.event.type != 'click') return;

		var ximElement = options.selNode.ximElement;
		var uid = ximElement.uid;
		var editable = options.selNode;
		var tagName = options.selNode.tagName.toLowerCase();

		// NOTE: Checking valid tags for this especific tool
		if (!editable || !this._valid_tags.contains(tagName) || (!this._allowed_uids.contains(uid) && !ximElement['structuredParent'])) {
			this._current_uid = null;
			this._current_model = null;
			this._current_rngModel = null;
			return;
		}

		// elem is the root node of the struct
		var elem = ximElement.structuredParent || ximElement;
		this._current_uid = elem.uid;
		this._current_model = {};
		this._parseModel(elem, 0);
		this._current_rngModel = ximElement.schemaNode;
	};

	/**
	 * Recursive
	 * Function which extracts the level from the hierachy for each element
	 */
	this._parseModel = function(item, level) {
		if (!level) level = 0;
		if (level > 2) return;
		this._current_model[item.tagName] = level;
		var childNodes = this.sanitizeChildNodes(item);
		var l = childNodes.length;
		for (var i=0; i<l; i++) {
			var child = childNodes[i];
			if(child.tagName != 'dextag')
				this._parseModel(child, level+1);
		}
	};

	/**
	 * Function which obtains the UIDs of all tables and lists
	 */
	this.afterUpdateContent = function(options) {

		this._allowed_uids = [];
		var frameBody = this.editor.getBody();

		$('table,ul,ol', frameBody).each(
			function(index, element) {
				var uid = element.getAttribute('uid')
				if (uid) {
					this._allowed_uids.push(uid);
					var ximElement = element.ximElement;
					this._parseChildrens(ximElement, ximElement);
				}
			}.bind(this)
		);
	};

	/**
	 * Recursive
	 * Function which sets the sctructuredParent attribute on all childrens of tables and lists
	 */
	this._parseChildrens = function(ximElement, ximParent) {
		var l = ximElement.childNodes.length;
		for (var i=0; i<l; i++) {
			var child = ximElement.childNodes[i];
			// Beware with elements already registered
			if (!child['structuredParent']) child.structuredParent = ximParent;
			this._parseChildrens(child, ximParent);
		}
	};


	// --- API ---

	this.getElement = function() {
		return this.editor.getXimDocument().getElement(this._current_uid);
	};

	this.getLevel = function(tagName) {
		return this._current_model[tagName];
	};

	this.getElementByLevel = function(level) {
		for (var elem in this._current_model) {
			if (this._current_model[elem] == level) return elem;
		}
		return null;
	};

	this.appendChild = function(ximElement, ximParent, updateEditor) {
		var elem = this.editor.getXimDocument().appendChild(ximElement, ximParent);
		this.setActionDescription(_('Insert element'));
		if (updateEditor) this.editor.updateEditor({caller: this});
		return elem;
	};

	this.insertBefore = function(ximElement, ximParent, ximBrother, updateEditor) {
		var elem = this.editor.getXimDocument().insertBefore(ximElement, ximParent, ximBrother);
		this.setActionDescription(_('Insert element'));
		if (updateEditor) this.editor.updateEditor({caller: this});
		return elem;
	};

	this.insertAfter = function(ximElement, ximParent, ximBrother, updateEditor) {
		var elem = this.editor.getXimDocument().insertAfter(ximElement, ximParent, ximBrother);
		this.setActionDescription(_('Insert element'));
		if (updateEditor) this.editor.updateEditor({caller: this});
		return elem;
	};

	this.removeChild = function(elem, ximElement, updateEditor) {
		var elem = this.editor.getXimDocument().removeChild(ximElement);
		this.setActionDescription(_('Remove element'));
		if (updateEditor) this.editor.updateEditor({caller: this});
		return elem;
	};


	// Events handlers that must be used from createContextMenuElements()

	this._appendChildHandler = function(elem, selNode) {
		var elem = elem;
		var selNode = selNode;
		return function() {
			this.appendChild(elem, selNode, true);
		};
	};

	this._removeChildHandler = function(elem, selNode) {
		var elem = elem;
		var selNode = selNode;
		return function() {
			this.removeChild(elem, selNode, true);
		};
	};

	this._showPropertiesHandler = function(selNode) {
		var selNode = selNode;
		return function() {
			this.showItemProperties(selNode);
		};
	};


	// --- abstract ---

	/**
	 * Returns an array of menu items. See kupubasetools.js
	 */
	this.createContextMenuElements = function(selNode, event) {
		this.editor.alert('overwrite me!');
	};

	this.showItemProperties = function(selNode) {
		this.editor.alert('showItemProperties: overwrite me!');
	};

	this._getFormalName = function(item) {
		this.editor.alert('_getFormalName: overwrite me!');
	};

	this.elementsForInsert = function(item) {
		this.editor.alert('elementsForInsert: overwrite me!');
	};

	this.elementsForRemove = function(item) {
		this.editor.alert('elementsForRemove: overwrite me!');
	};

};

StructuredListTool.prototype = new XimdocTool();


/**
 *  Class from tables management. Extends StructuredListTool
 */
function TableManagerTool() {

	// See levels on StructuredList._parseModel()
	this.ELEMENT_TABLE = 0;
	this.ELEMENT_ROW = 1;
	this.ELEMENT_CELL = 2;

	this.parentClass = TableManagerTool.prototype;
	this._valid_tags = ['table', 'tbody', 'tr', 'th', 'td'];
	this.editor = null;

	/**
	 * Calculates where to place the new element depending on the selected element.
	 * TODO: This method could be inteligent and add cells or colspans automatically.
	 */
	this.appendChild = function(tagName, selNode, updateEditor) {

		var ximTable = this.getElement();
		var selNodeLevel = this.getLevel(selNode.tagName);
		var itemLevel = this.getLevel(tagName);
		var newElem = null;

		if (itemLevel == this.ELEMENT_ROW) {

	   		var rngRow = this.editor.getRngDocument().getElement(tagName);
	    	var newRow = new XimElement(rngRow, true);

			if (selNodeLevel == this.ELEMENT_TABLE) {

				// Adding a new row from the table element
				newElem = this.parentClass.appendChild(newRow, selNode, updateEditor);

			} else {

				// Adding a new row from a row or cell element
				var ximRow = selNode;
				if (selNodeLevel == this.ELEMENT_CELL) ximRow = selNode.parentNode;
				newElem = this.parentClass.insertAfter(newRow, ximTable, ximRow, updateEditor);
			}

		} else if (itemLevel == this.ELEMENT_CELL) {

	   		var rngCell = this.editor.getRngDocument().getElement(tagName);
	    	var newCell = new XimElement(rngCell, true);

	    	if (selNodeLevel == this.ELEMENT_ROW) {

	    		// Adding a cell from a row element
	    		newElem = this.parentClass.appendChild(newCell, selNode, updateEditor);

	    	} else if (selNodeLevel == this.ELEMENT_CELL) {

	    		// Adding a cell from a cell element
	    		var ximRow = selNode.parentNode;
	    		newElem = this.parentClass.insertAfter(newCell, ximRow, selNode, updateEditor);
	    	}
		}

		//console.log(selNode);
		return newElem;
	};

	this.removeChild = function(elem, ximElement, updateEditor) {

		var selNodeLevel = this.getLevel(ximElement.tagName);
		var itemLevel = this.getLevel(elem);
		var newElem = null;

		if (itemLevel == this.ELEMENT_TABLE) {

			// Removing the table
			newElem = this.parentClass.removeChild(elem, this.getElement(), updateEditor);

		} else if (itemLevel == this.ELEMENT_ROW) {

			// Removing a row
			var ximCell = ximElement;
			if (selNodeLevel == this.ELEMENT_CELL) ximCell = ximElement.parentNode;
			newElem = this.parentClass.removeChild(elem, ximCell, updateEditor);

		} else if (itemLevel == this.ELEMENT_CELL && selNodeLevel == this.ELEMENT_CELL) {

			// Removing a cell
			newElem = this.parentClass.removeChild(elem, ximElement, updateEditor);
		}

		//console.log(ximElement);
		return newElem;
	};

	/**
	 * Function which creates a table with especific options
	 */
	this.createTable = function(rngTable, selNode, options) {

   		var rngTable = this.editor.getRngDocument().getElement(rngTable.tagName);
    	var newTable = new XimElement(rngTable, true);
		this._current_model = {};
		this._parseModel(rngTable, 0);
    	newTable = this.editor.getXimDocument().insertAfter(newTable, selNode.parentNode, selNode);

    	// ... so we have to complete rows and cells.
    	for (var r=0; r<options.rows; r++) {
			row = this.appendChild(this.getElementByLevel(this.ELEMENT_ROW), newTable, false);
    		for (var c=0; c<options.cols; c++) {
				col = this.appendChild(this.getElementByLevel(this.ELEMENT_CELL), row, false);
    		}
    	}

		this.setActionDescription(_('Create table'));
		// Be carefull, don't update the editor until all elements have been created, see FALSE on appendChild() calls.
		this.editor.updateEditor({caller: this});
	};

	this.sanitizeChildNodes = function(item) {
		var childNodes = [];
		var c = 0;
		for (var i=0; i<item.childNodes.length; i++) {
			if(item.childNodes[i].tagName == 'dextag')
				continue;
			childNodes[c] = item.childNodes[i];
			c++;
		}

		return childNodes;
	}


	/**
	 * Function which removes a table
	 */
	this.removeTable = function(selNode) {
		if (!selNode) return;
		var ximTable = selNode.structuredParent || selNode;
		this.removeChild(ximTable.tagName, ximTable, true);
	};

	/**
	 * selNode is a ximElement
	 */
	this.createContextMenuElements = function(selNode, event) {

		if (!selNode) return [];
		var ximNode = selNode.ximElement;
		if (!this._current_rngModel || !ximNode['structuredParent']) return [];

		var cm = [];
		cm.push(new ContextMenuElement(_('-----'), function(){}, this));
		cm.push(new ContextMenuElement(_('Remove table'), function() {this.removeTable(ximNode);}, this));
		cm.push(new ContextMenuElement(_('Table properties'), this._showPropertiesHandler(ximNode), this));
		cm.push(new ContextMenuElement(_('-----'), function(){}, this));

		var elements = this.elementsForInsert(ximNode.tagName);
		var l = elements.length;
		for (var i=0; i<l; i++) {
			var elem = elements[i];
			var name = this._getFormalName(elem);
			cm.push(new ContextMenuElement(_('Add item: ') + name, this._appendChildHandler(elem, ximNode), this));
			cm.push(new ContextMenuElement(_('Properties of ') +name, this._showPropertiesHandler(ximNode), this));
		}

		cm.push(new ContextMenuElement(_('-----'), function(){}, this));

		elements = this.elementsForRemove(ximNode.tagName);
		l = elements.length;
		for (var i=0; i<l; i++) {
			var elem = elements[i];
			var name = this._getFormalName(elem);
			cm.push(new ContextMenuElement(_('Remove item: ') + name, this._removeChildHandler(elem, ximNode), this));
		}

		return cm;
	};

	this._getFormalName = function(item) {
		var name = '';
		switch (this.getLevel(item)) {
			case this.ELEMENT_ROW:
				name = 'Row';
				break;
			case this.ELEMENT_CELL:
				name = 'Cell';
				break;
			default:
				name = '-- Unknown --';
		}
		return name;
	};

	/**
	 * Needs the ximElement tagName of the selected node for return the items allowed for insert.
	 * In a table, the elements permited are rows and cells, regardless of the selected item
	 * except a cell when selNode is the table element.
	 */
	this.elementsForInsert = function(selNodeTagName) {
		var elements = [];
		var itemLevel = this.getLevel(selNodeTagName);
		for (var o in this._current_model) {
			var level = this._current_model[o];
			// Can't insert a table
			// Can't insert a cell if selNode is a table element
			if (!(itemLevel == this.ELEMENT_TABLE && level == this.ELEMENT_CELL) && level > this.ELEMENT_TABLE) {
				elements.push(o);
			}
		}
		return elements;
	};

	/**
	 * Needs the ximElement tagName of the selected node for return the items allowed for remove.
	 * In a table, the elements permited are rows (if selected item is a row or cell)
	 * and cells (if selected item is a cell).
	 */
	this.elementsForRemove = function(selNodeTagName) {
		var elements = [];
		var itemLevel = this.getLevel(selNodeTagName);
		for (var o in this._current_model) {
			var level = this._current_model[o];
			if (itemLevel == this.ELEMENT_ROW && level == this.ELEMENT_ROW) {
				// selNode is a row, only allow to delete rows
				elements.push(o);
			} else if (itemLevel == this.ELEMENT_CELL && [this.ELEMENT_ROW, this.ELEMENT_CELL].contains(level)) {
				// selNode is a cell, we can delete the cell or the parent row
				elements.push(o);
			}
		}
		return elements;
	};

};

TableManagerTool.prototype = new StructuredListTool();


/**
 *  Class from lists management. Extends StructuredList
 */
function ListManagerTool() {

	// See levels on StructuredList._parseModel()
	this.ELEMENT_LIST = 0;
	this.ELEMENT_ITEM = 1;

	this.parentClass = ListManagerTool.prototype;
	this._valid_tags = ['ul', 'ol', 'li'];

	/**
	 * Calculates where to place the new element depending on the selected element.
	 */
	this.appendChild = function(tagName, selNode, updateEditor) {

		var ximList = this.getElement();
		var selNodeLevel = this.getLevel(selNode.tagName);
		var itemLevel = this.getLevel(tagName);
		var newElem = null;

		if (itemLevel == this.ELEMENT_ITEM) {

			var rngItem = this.editor.getRngDocument().getElement(tagName);
	    	var newItem = new XimElement(rngItem, true);

			if (selNodeLevel == this.ELEMENT_LIST) {

				// Adding a new item from the list element
				newElem = this.parentClass.appendChild(newItem, selNode, updateEditor);

			} else if (selNodeLevel == this.ELEMENT_ITEM) {

				// Adding a new item from a item element
				newElem = this.parentClass.insertAfter(newItem, ximList, selNode, updateEditor);
			}

		}

		//console.log(selNode);
		return newElem;
	};

	this.removeChild = function(elem, ximElement, updateEditor) {

		var selNodeLevel = this.getLevel(ximElement.tagName);
		var itemLevel = this.getLevel(elem);
		var newElem = null;

		if (itemLevel == this.ELEMENT_LIST) {

			// Removing the list
			newElem = this.parentClass.removeChild(elem, this.getElement(), updateEditor);

		} else if (itemLevel == this.ELEMENT_ITEM && selNodeLevel == this.ELEMENT_ITEM) {

			// Removing an item
			newElem = this.parentClass.removeChild(elem, ximElement, updateEditor);

		}

		//console.log(ximElement);
		return newElem;
	};

	/**
	 * Function which creates a list with a default list item
	 */
	this.createList = function(rngList, selNode, options) {
		this.createElement(rngList.tagName, selNode.parent, selNode, null).apply();
	};

	/**
	 * Function which removes a list
	 */
	this.removeList = function(selNode) {
		if (!selNode) return;
		var ximList = selNode.structuredParent || selNode;
		this.removeChild(ximList.tagName, ximList, true);
	};

	/**
	 * selNode is a ximElement
	 */
	this.createContextMenuElements = function(selNode, event) {

		if (!selNode) return [];
		var ximNode = selNode.ximElement;
		if (!this._current_rngModel || !ximNode['structuredParent']) return [];

		var cm = [];
		cm.push(new ContextMenuElement(_('-----'), function(){}, this));
		//cm.push(new ContextMenuElement(_('Remove List'), this._removeChildHandler(this._current_rngModel.tagName, ximNode), this));
		cm.push(new ContextMenuElement(_('Remove list'), function() {this.removeList(ximNode);}, this));
		cm.push(new ContextMenuElement(_('List properties'), this._showPropertiesHandler(ximNode), this));
		cm.push(new ContextMenuElement(_('-----'), function(){}, this));

		var elements = this.elementsForInsert(ximNode.tagName);
		var l = elements.length;
		for (var i=0; i<l; i++) {
			var elem = elements[i];
			var name = this._getFormalName(elem);
			cm.push(new ContextMenuElement(_('Add item: ') + name, this._appendChildHandler(elem, ximNode), this));
			cm.push(new ContextMenuElement(_('Properties of ') + name, this._showPropertiesHandler(ximNode), this));
		}

		cm.push(new ContextMenuElement(_('-----'), function(){}, this));

		elements = this.elementsForRemove(ximNode.tagName);
		l = elements.length;
		for (var i=0; i<l; i++) {
			var elem = elements[i];
			var name = this._getFormalName(elem);
			cm.push(new ContextMenuElement(_('Remove item: ') + name, this._removeChildHandler(elem, ximNode), this));
		}

		return cm;
	};

	this._getFormalName = function(item) {
		var name = '';
		switch (this.getLevel(item)) {
			case this.ELEMENT_ITEM:
				name = 'List item';
				break;
			default:
				name = '-- ERROR IN getFormalName() --';
		}
		return name;
	};

	/**
	 * Needs the ximElement tagName of the selected node for return the items allowed for insert.
	 * In a list, the elements permited are only list items
	 */
	this.elementsForInsert = function(selNodeTagName) {
		var elements = [];
		for (var o in this._current_model) {
			var level = this._current_model[o];
			// Can't insert a list...
			if (level == this.ELEMENT_ITEM) {
				elements.push(o);
			}
		}
		return elements;
	};

	/**
	 * Needs the ximElement tagName of the selected node for return the items allowed for remove.
	 * In a list, the elements permited are list items and the list itself
	 */
	this.elementsForRemove = function(selNodeTagName) {
		var elements = [];
		for (var o in this._current_model) {
			var level = this._current_model[o];
			// We can delete a list item
			if (level == this.ELEMENT_ITEM) {
				elements.push(o);
			}
		}
		return elements;
	};

};

ListManagerTool.prototype = new StructuredListTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



var AttributesTool = Object.xo_create(XimdocTool, {

	PROTECTED_ATTRIBUTES: ['uid'],
	SPECIAL_ATTRIBUTES_TYPES: ['ximlink'],

	specialAttributes: [],
	specialElements: {},

	initialize: function(editor) {

		AttributesTool._super(this, 'initialize', editor);

		this.selNode = null;
		this.attributes = null;

		this._parse_ximElements();
	},

	updateState: function(options) {

		if (this.selNode) {
			this._parse_ximElement(this.selNode);
		}

		if (!options.selNode || !options.selNode.getAttribute('uid') || (options.event && options.event.type != 'click')) return;

		var ximElement = options.selNode.ximElement;

		var attributes = this._parse_ximElement(ximElement);

		this.selNode = ximElement;
		this.attributes = attributes;

		AttributesTool._super(this, 'updateState', options);
	},

	beforeUpdateContent: function(options) {
//		this._parse_ximElements();
		AttributesTool._super(this, 'beforeUpdateContent', options);
	},

	afterUpdateContent: function(options) {
		this._parse_ximElements();
		AttributesTool._super(this, 'afterUpdateContent', options);
	},

	beforeTransform: function(xmldoc, xsldoc) {

		for (var itemUID in this.specialElements) {

			var ximElement = this.specialElements[itemUID];
			var domElement = $('[uid="%s"]'.printf(itemUID), xmldoc).get(0);

			if (Object.isEmpty(domElement)) {
				continue;
			}

			for (var i=0,l=this.specialAttributes.length; i<l; i++) {

				var attrName = this.specialAttributes[i];
				if (domElement.hasAttribute(attrName)) {
					domElement.setAttribute(attrName, ximElement.attributes[attrName]);
				}
			}
		}
	},

	saveAttributes: function(values) {

		var rngAttributes = this.selNode.rngElement
			? this.selNode.rngElement.attributes
			: this.selNode.schemaNode.attributes;

		for (var attrName in values) {

			if (!rngAttributes[attrName]) {
				continue;
			}

			var attrType = rngAttributes[attrName].type;

			if (this.PROTECTED_ATTRIBUTES.contains(attrName)) {
				continue;
			}

			if (this.specialAttributes.contains(attrName)) {

				var method = '_save_attribute_' + attrType;
				if (Object.isFunction(this[method])) {
					this[method](values[attrName]);
				} else {
					this.selNode.attributes[attrName] = values[attrName];
				}

			} else {

				this.selNode.attributes[attrName] = values[attrName];
			}
		}
	},

	_parse_ximElements: function() {

		var ximModel = this.editor.getXimDocument().getXimModel();
		var rngModel = this.editor.getRngDocument().getModel();
		this.specialElements = {};

		for (var elemName in rngModel) {

			var element = rngModel[elemName];
			for (var attrName in element.attributes) {

				var attr = element.attributes[attrName];
				if (this.SPECIAL_ATTRIBUTES_TYPES.contains(attr.type)) {

					this.specialAttributes.push(attrName);

					for (var itemUID in ximModel) {

						var ximElement = ximModel[itemUID];
						if (ximElement.schemaNode.tagName == elemName && ximElement.attributes[attrName]) {

							this.specialElements[itemUID] = ximElement;
							this._parse_ximElement(ximElement);
						}
					}
				}
			}
		}
	},

	_parse_ximElement: function(ximElement) {

		var attributes = {};
		var rngAttributes = ximElement.rngElement
			? ximElement.rngElement.attributes
			: ximElement.schemaNode.attributes;

		for (var attrName in rngAttributes) {

			var rngAttr = rngAttributes[attrName];
			var attrValue = null;
			var selectedValue = null;

			// If attribute has defined values in schema: print a combo box
			if (rngAttr.values.length > 1) {

				selectedValue = ximElement.attributes[attrName];
				attrValue = rngAttr.values;

			} else {

				attrValue = ximElement.attributes[attrName] || '';
			}

			attributes[attrName] = {
				type: rngAttr.type,
				value: attrValue,
				selectedValue: selectedValue
			};

			// Parsing specific attribute types
			var method = '_parse_attribute_' + (rngAttr.type || '');
			if (Object.isFunction(this[method])) {
				attributes[attrName] = this[method](attrName, attributes[attrName], ximElement);
			}
		}

		return attributes;
	},

	_parse_attribute_ximlink: function(attrName, attribute, ximElement) {

		if (ximElement.ximLink) {
			if (ximElement.tagName != 'image') {
				ximElement.ximLink.text = ximElement.getValueString();
			} else {
//				console.info(ximElement);
			}
			return attribute;
		}

		var value = attribute.value.split(',');
		var nodeid = value[0].trim();
		var channel = (value[1] || '').trim();

		ximElement.ximLink = {
			attrName: attrName,
			nodeid: nodeid,
			channel: channel,
			name: '',
			url: '',
			text: ximElement.getValueString(),
			descriptions: []
		};

		$.getJSON(
			X.restUrl + '?action=xmleditor2&method=resolveXimlinkUrl',
			{nodeid: nodeid, channel: channel},
			function(data, textStatus) {

				if (data.error) {

					this.editor.logMessage(data.error);

					var url = ximElement.ximLink.nodeid.length > 0
						? ximElement.ximLink.nodeid
						: ximElement.attributes[ximElement.ximLink.attrName];

					ximElement.ximLink.name = 'NewLink_' + ximElement.uid;
					ximElement.ximLink.text = ximElement.ximLink.name;
					ximElement.ximLink.url = url;
					ximElement.ximLink.nodeid = '';
//					console.log(data.error, ximElement);

				} else {

					ximElement.ximLink.url = data.url;
					ximElement.ximLink.name = data.name;
					ximElement.ximLink.descriptions = data.text;

					attribute.value = ximElement.ximLink.url;
					ximElement.attributes[attrName] = ximElement.ximLink.url;

//					console.log('AttributesTool::parse_ximlink', ximElement, attribute);
				}
			}.bind(this)
		);

		return attribute;
	},

	_save_attribute_ximlink: function() {

		var ximLinkInfo = this.selNode.ximLink;

		this.selNode.attributes[ximLinkInfo.attrName] = ximLinkInfo.url;
		this.selNode.value = [ximLinkInfo.text];

		if (this.selNode.tagName != 'image') {
			$('[uid="%s"]'.printf(this.selNode.uid), this.editor.getBody()).html(ximLinkInfo.text);
		}
	}

});
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




/**
 * Annotate document.
 */

function XimdocAnnotationRdfaTool() {

	this._highlightStartTag = null;
	this._highlightEndTag = null;
	this._annotationDoc = null;

    this.initialize = function (editor) {
//    	console.log('ximdoc anotation rdfa');
        this.editor = editor;
        this.editor.logMessage(_('Annotation Rdfa tool initialized'));
    },
    
/*    this.updateState = function (options) {
    	console.log('options', options);
    },*/
    this.doAnnotate = function () {
//    	console.log('doAnnotate', this);
    	selection = this.editor.getSelection().parentElement();
//    	console.log(selection);
//    	$(selection).html('asdfasdfasdfasdfasdf');
    	
    	
    	
    } 
}

XimdocAnnotationRdfaTool.prototype = new XimdocTool();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



var ToolbarTool = Object.xo_create(XimdocTool, {
	
	buttons: null,
	
//	_init: function(options) {
//		console.log(arguments);
//	},
	
	initialize: function(editor) {
		
		this.editor = editor;
		this.buttons = [];
		
		// NOTE: Buttons are defined in toolbar.tpl
		
		// Edition oprations
		this.registerButton('CutButton', 'kupu-cut-button');
		this.registerButton('CopyButton', 'kupu-copy-button');
		this.registerButton('PasteButton', 'kupu-paste-button');
		
//		this.registerButton('UndoButton', 'kupu-undo-button');
//		this.registerButton('RedoButton', 'kupu-redo-button');
		
		this.registerButton('ScrollUpButton', 'kupu-scrollup-button');
		this.registerButton('ScrollDownButton', 'kupu-scrolldown-button');
		
//		this.registerButton('RemoveButton', 'kupu-remove-button');
//		this.registerButton('SchemaValidatorButton', 'kupu-schemavalidator-button');
//		this.registerButton('XimletDrawerButton', 'kupu-ximletdrawer-button');
		
	},

	updateState: function(options) {
		
	},
	
	beforeUpdateContent: function(options) {
		
	},

	afterUpdateContent: function(options) {
		
	},
	
	registerButton: function(className, buttonId) {
		
		var buttonClass = null;
		try {
			buttonClass = eval(className);
			if (!Object.isFunction(buttonClass)) return;
		} catch(e) {
			return;
		}
		
		var button = new buttonClass(buttonId, this);
		
		if ($('#toolbar #'+button.buttonid).length == 0) return;
		button.initialize(this.editor);
		this.buttons.push(button);
	},
	
	getTool: function(toolName) {
//		console.log(this.editor);
	}

});


var ToolbarButton = Object.xo_create(XimdocButton, {

	_init: function(buttonid, tool) {
		ToolbarButton._construct(this, buttonid, this.commandfunc, tool);
	}
});

var CutButton = Object.xo_create(ToolbarButton, {

    commandfunc: function(event) {
		var ximElement = this.editor.getSelectedNode().ximElement;
		this.cutElement(ximElement);
    }
});

var CopyButton = Object.xo_create(ToolbarButton, {

    commandfunc: function(event) {
		var ximElement = this.editor.getSelectedNode().ximElement;
		this.copyElement(ximElement);
    }
});

var PasteButton = Object.xo_create(ToolbarButton, {

    commandfunc: function(event) {
		var ximElement = this.editor.getSelectedNode().ximElement;
		this.pasteElement(ximElement.parentNode, ximElement);
    }
});

var ScrollUpButton = Object.xo_create(ToolbarButton, {

	commandfunc: function(event) {
		var ximElement = this.editor.getSelectedNode().ximElement;
		if (ximElement.scrollUp()) {
			this.setActionDescription(_('Scroll up'));
			this.editor.updateEditor({caller: this});
		}
    }
});

var ScrollDownButton = Object.xo_create(ToolbarButton, {

	commandfunc: function(event) {
		var ximElement = this.editor.getSelectedNode().ximElement;
		if (ximElement.scrollDown()) {
			this.setActionDescription(_('Scroll down'));
			this.editor.updateEditor({caller: this});
		}
    }
});
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



var ImagesTool = Object.xo_create(XimdocTool, {
	
	initialize: function(editor) {
		
		ImagesTool._super(this, 'initialize', editor);
	},

	updateState: function(options) {
		this.updateImagesSize(this.editor.getInnerDocument());
	},

	afterUpdateContent: function(options) {
		this.updateImagesSize(options.xslResult);
	},
	
	beforeSave: function() {
		this.updateImagesSize(this.editor.getInnerDocument());
	},

	// Doesn't works fine...
//	mouseUp: function(options) {
//		
//		var images = [options.selNode];
//		
//		if (options.selNode.tagName.toUpperCase() != 'IMG') {
//			images = $('img[uid]', options.selNode);
//		}
//		
//		for (var i=0,l=images.length; i<l; i++) {
//			this.updateImageSize(images[i]);
//		}
//	},
	
	updateImageSize: function(image) {
		if($(image).length <1) return ;
		
		var width = 0, height = 0;
		if($(image).attr('width')   )
			width = $(image).width();

		if($(image).attr('height') )
			height = $(image).height();
		

		var dim = {
			'w': parseInt(width),
			'h': parseInt(height)
		};
		

		if (isNaN(dim.w) || isNaN(dim.h)) return;
		
		var ximElement = this.editor.getXimDocument().getElement(image.getAttribute('uid'));
		if(ximElement) {
			ximElement.attributes.width = dim.w;
			ximElement.attributes.height = dim.h;
		}
	},
	
	updateImagesSize: function(doc) {
		$('img[uid]', doc).each(function(index, item) {
			this.updateImageSize(item);
		}.bind(this));
	}

});
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



var RMXimdexTool = Object.xo_create(XimdocTool, {
	
	initialize: function(editor) {
		
		RMXimdexTool._super(this, 'initialize', editor);
	},

	updateState: function(options) {
		
	},
	
	beforeUpdateContent: function(options) {
		this.resolveMacros(options.xslResult);
	},
	
	resolveMacros: function(xslResult) {

		// dotdot macro
		$("[src*='@@@RMximdex.dotdot']", $('body', xslResult)[0]).each(function(index, elem) {
			var path = unescape($(elem).attr('src'));
			path = this.editor.getDotDotPath() + path.replace(/@@@RMximdex.dotdot\((.*)\)@@@/ig, "$1");
			$(elem).attr('src', path);
		}.bind(this));

		$("link[href*='@@@RMximdex.dotdot']", $('html', xslResult)[0]).each(function(index, elem) {
			var path = unescape($(elem).attr('href'));
			path = this.editor.getDotDotPath() + path.replace(/@@@RMximdex.dotdot\((.*)\)@@@/ig, "$1");
			$(elem).attr('href', path);
		}.bind(this));

		// pathto macro
		$("img[src*='@@@RMximdex.pathto']", $('body', xslResult)[0]).each(function(index, elem) {
			var targetid = unescape($(elem).attr('src'));
			targetid = targetid.replace(/@@@RMximdex.pathto\((.*)\)@@@/ig, "$1");
			var path = '%s?nodeid=%s&action=filemapper'.printf(X.restUrl, targetid);
			$(elem).attr('src', path);
		});
	}

});
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


var NavBarTool = Object.xo_create(XimdocTool,{

	initialize: function(editor){
	},
	
	updateState: function(options){
	},

	beforeUpdateContent: function(options) {
	},

	afterUpdateContent: function(options) {
	},

	beforeTransform: function(xmldoc, xsldoc) {
	},

	saveAttributes: function(values) {
	}
});


/**
 * The ximdex drawer tool
 * Implements DrawerTool, extends XimdocTool
 */
function XimdocDrawerTool() {
    /* a tool to open and fill drawers

        this tool has to (and should!) only be instantiated once
    */
    	this.drawers = null;
    	this.current_drawer = null;
    	this.current_id = null;

    	this.initialize = function(editor) {
        	this.editor = editor;
        	this.drawers = {};
        	this.isIE = this.editor.getBrowserName() == 'IE';
        	// this essentially makes the drawertool a singleton
        	window.ximdocdrawertool = this;
    	};

    	this.registerDrawer = function(id, drawer, editor) {
    		if (!this.drawers) this.drawers = {};
        	this.drawers[id] = drawer;
        	drawer.initialize(editor || this.editor, this);
    	};

    	this.openDrawer = function(id) {
        	/* open a drawer */
        	if (this.current_drawer) {
            		this.closeDrawer();
        	};
        	var drawer = this.drawers[id];
        	if (this.isIE) {
            		drawer.editor._saveSelection();
        	}
        	drawer.createContent();
        	//drawer.editor.suspendEditing();
        	this.current_drawer = drawer;
        	this.current_id = id;
    	};

    	this.isOpen = function(id) {
    		return this.current_id == id;
    	};

    	this.closeDrawer = function(button) {
        	if (!this.current_drawer) {
            		return;
        	};
        	this.current_drawer.hide();
        	//this.current_drawer.editor.resumeEditing();
        	this.current_drawer = null;
        	this.current_id = null;
    	};

    	this.updateState = function(options) {
    	};

    	this.beforeUpdateContent = function(options) {
    	};

    	this.afterUpdateContent = function(options) {
    	};
};

XimdocDrawerTool.prototype = new XimdocTool();

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




/**
 * Drawer for tables management
 */
function TableWizardDrawer(tool, rngElement, selXimElement) {
    /* Table drawer */
    this.element = getFromSelector('kupu-tabledrawer');
    this.tool = tool;
    this.rngElement = rngElement;
    this.selXimElement = selXimElement;

    this.addpanel = getBaseTagClass(this.element, 'div', 'kupu-tabledrawer-addtable');
    this.editpanel = getBaseTagClass(this.element, 'div', 'kupu-tabledrawer-edittable');
    var editclassselect = getBaseTagClass(this.element, 'select', 'kupu-tabledrawer-editclasschooser');
    var addclassselect = getBaseTagClass(this.element, 'select', 'kupu-tabledrawer-addclasschooser');
    var alignselect = getBaseTagClass(this.element, 'select', 'kupu-tabledrawer-alignchooser');
    var newrowsinput = getBaseTagClass(this.element, 'input', 'kupu-tabledrawer-newrows');
    var newcolsinput = getBaseTagClass(this.element, 'input', 'kupu-tabledrawer-newcols');
    var makeheadercheck = getBaseTagClass(this.element, 'input', 'kupu-tabledrawer-makeheader');

    this.createContent = function() {

        var editor = this.editor;
        var selNode = editor.getSelectedNode();

        /*function fixClasses(classselect) {
            if (editor.config.table_classes) {
                var classes = editor.config.table_classes['class'];
                while (classselect.hasChildNodes()) {
                    classselect.removeChild(classselect.firstChild);
                };
                for (var i=0; i < classes.length; i++) {
                    var classinfo = classes[i];
                    var caption = classinfo.xcaption || classinfo;
                    var classname = classinfo.classname || classinfo;

                    var option = document.createElement('option');
                    var content = document.createTextNode(caption);
                    option.appendChild(content);
                    option.setAttribute('value', classname);
                    classselect.appendChild(option);
                };
            };
        };
        fixClasses(addclassselect);
        fixClasses(editclassselect);*/

		// Workaround!: Firefox 3 disables the "Update Attribute" button, why?
		kupu.enableButtonFF3(this.element);

        var table = editor.getNearestParentOfType(selNode, 'table');
        //console.info(editor.getNearestParentWithAttribute(selNode, 'table'));

		table = selNode.ximElement;
		if (!table['structuredList']) table = false;

        if (!table) {
            // show add table drawer
            show = this.addpanel;
            hide = this.editpanel;
        } else {
            // show edit table drawer

            // TODO: May we connect this "edit panel" with AttributesTool?

            show = this.editpanel;
            hide = this.addpanel;
            /*var align = this.tool._getColumnAlign(selNode);
            selectSelectItem(alignselect, align);
            selectSelectItem(editclassselect, table.className);*/
        };

		  // For now, overriting to only creation:
		  show = this.addpanel;
		  hide = this.editpanel;

        hide.style.display = 'none';
        show.style.display = 'block';
        this.element.style.display = 'block';
        this.focusElement();
    };

    this.createTable = function() {
        //this.editor.resumeEditing();
        var options = {
        	rows: newrowsinput.value || 1,
        	cols: newcolsinput.value || 1
        };
		  this.tool.createTable(this.rngElement, this.editor.selNode.ximElement, options);
		  this.drawertool.closeDrawer();
    };
};

TableWizardDrawer.prototype = new Drawer();/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




/**
 * Drawer for ximlets management
 */

function ximletDrawer(elementid, tool, wrap) {

    this.element = getFromSelector(elementid);
    this.tool = tool;
    this.input = getBaseTagClass(this.element, 'input', 'kupu-ximletdrawer-input');
    this.selectedNode = null;
    this.ximletId = null;

    /*
    *	Display the drawer
    */
    this.createContent = function() {

		// Workaround!: Firefox 3 disables the "Update Attribute" button, why?
		kupu.enableButtonFF3(this.element);

        // TODO: take from this.selectedNode value from id
        this.selectedNode = this.editor.getSelectedNode();

        // Be sure that selectedNode is a ximlet
        var rngXimlet = this.selectedNode.rngElement;
        if (!rngXimlet || rngXimlet.type != 'ximlet') {
        	this.drawertool.closeDrawer();
        	return;
        }

        this.input.value = this.selectedNode.ximElement.getMacroId();
        this.ximletId = this.input.value;
        $(this.element).show();
        this.focusElement();
    };

    /*
    *	Add or modify a ximlet
    */
    this.save = function() {

        if(this.input.value != this.ximletId && this.tool._existsXimlet(this.input.value)) {
        	if(!confirm(_('The document already contains a ximlet with ID ') + this.input.value + '. ' + _('Do yo want to continue?')))
        		return;
        }
        
        if(this.input.value != this.ximletId) {
	        // Update Ximlet content
	        this.tool.updateXimlet(this.selectedNode, this.input.value);
		}

		// Close Drawer
        this.drawertool.closeDrawer();
    };

};

ximletDrawer.prototype = new Drawer();/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




var XimlinkDrawer = Object.xo_create(new Drawer(), {

	_init: function(elementid, tool) {

//		this.setTitle(_('Attributes'));

		this.element = getFromSelector(elementid);
	    this.tool = tool;
	    this.data = null;
		this.term_main = null;
		this.term = null;

		$('div.descriptions-list-options', this.element).empty();
	},

	setData: function(data) {
		this.data = Object.isArray(data) ? data : [];
	},

	setTerm: function(term) {
		this.term = term;
		$('input.ximlink-search', this.element).val(term);
	},

	setMainTerm: function(term) {
			this.term_main = term;
			this.setTerm(term);
	},

	deleteContent: function(){
		$('select.ximlink-list', this.element).empty();
	},

	addContent : function(){
		this.data.each(function(index, item) {
    	$('select.ximlink-list', this.element).append(this._createOption(item));
    	}.bind(this));

	},

    createContent: function() {
		$('div.descriptions-list-options', this.element).empty();
		this._addDescription(this.term_main, 1);


    	this.data.each(function(index, item) {
    		$('select.ximlink-list', this.element).append(this._createOption(item));
    	}.bind(this));

    	$('input.ximlink-search', this.element).keyup(function(event) {
    		this.filterXimlinks($(event.currentTarget).val());
    	}.bind(this));

    	$('button.save-button', this.element).click(this.save.bind(this));
    	$('button.close-button', this.element).click(this.close.bind(this));

    	$(this.element).show();
        this.focusElement();
    },

    _createOption: function(data) {
		this._addDescription(this.term_main, 1);

    	var opt = $('<option></option>')
    		.val(data.idnode)
    		.html('%s - %s'.printf(data.name, data.url))
    		.data('data', data)
    		.click(this._showXimlinkDescriptions.bind(this, data));

    	data.option = opt;

    	return opt;
    },

    _showXimlinkDescriptions: function(data,event) {
    	data.text.each(function(index, item) {
			this._addDescription(item);
    	}.bind(this));
    },

	_addDescription: function(text, init) {
			if(init) {
				$('div.descriptions-list-options', this.element).empty();
				this._addDescription(this.term_main);
				$('div.descriptions-list-options input:radio', this.element).eq(0).attr("checked", true );
				return ;
			}

			var description_exists = $('div.descriptions-list-options input[value="'+text+'"]', this.element).length;


			if(description_exists) return ;

			var opt = $('<input type="radio" />')
				.attr({name: "descriptions-list"})
	    		.val(text);

			var label =  $('<label></label>')
				.append(opt)
				.append(text);

    		$('div.descriptions-list-options', this.element).append(label);
	},

	_getXimLinkData: function(term){
		$.getJSON(
			X.restUrl + '?action=xmleditor2&method=getAvailableXimlinks&term='+term,
			{docid: this.tool.editor.nodeId},
			function(data, textStatus) {
				this.setData(data);
				this.deleteContent();
				this.addContent();
			}.bind(this)
		);
	},

    filterXimlinks: function(term) {
    	term = term || '';
    	if (term.length <= 2) {
    		return;
    	}

    	this._getXimLinkData(term);
    },

    save: function() {

    	var item = $('select.ximlink-list option:selected', this.element);
    	var text = $('div.descriptions-list-options input:radio:checked', this.element);
		if( item.length >= 1) {
			var data = $(item[0]).data('data');
			this.tool.selNode.ximLink.name = data.name;
			this.tool.selNode.ximLink.url = data.url;

			if (item.length == 0 || text.length == 0) {
				this.tool.selNode.ximLink.text = this.tool.term_main;
			}else {
				this.tool.selNode.ximLink.text = $(text).val();
			}
		}else {
				this.tool.selNode.ximLink.text = $(text).val();
		}

		var toolbox = this.tool.toolboxes['attributestoolbox'];
    	toolbox.updateButtonHandler();

    	this.close();
    },

    close: function() {
    	this.data = null;

    	$('select.ximlink-list', this.element).unbind().empty();
    	$('input.ximlink-search', this.element).unbind();
    	$('button.save-button', this.element).unbind();
    	$('button.close-button', this.element).unbind();
    	var dt = this.tool.editor.getTool('ximdocdrawertool');
    	dt.closeDrawer();
    }

});


/**
 * Controls the buttons that will be added to the toolbar and the states
 */
function ToolbarButtonsToolBox(buttonGroupClass) {

    	this.selectedNode = null;
    	this.buttonGroupClass = buttonGroupClass;

    	this.initialize = function(tool, editor) {
    		this.tool = tool;
        	this.editor = editor;
        	this._initializeToolbar();
        	this.editor.logMessage(_('ToolbarButtonsToolBox tool initialized'));
    	};

    	this._initializeToolbar = function() {

		var commonGroup = document.createElement('span');
		commonGroup.setAttribute('class', this.buttonGroupClass);

		var buttonGroup = document.createElement('span');
		buttonGroup.setAttribute('class', this.buttonGroupClass);

		$([commonGroup, buttonGroup]).css({
			'border-left': '2px solid #bbbbbb',
			'padding-left': '8px'
		});

		var tbar = getFromSelector('kupu-tb-rngbuttons');
		tbar.appendChild(commonGroup);
		tbar.appendChild(buttonGroup);

		var rngElements = this.editor.config.rng_elements;
		if (rngElements) {
			var model = this.editor.getRngDocument().getModel();
			var default_icon_class = this.editor.config.default_button_class;

			for (var rngElementName in model) {

				rngElementName = rngElementName.replace(":", "_");
				var rngTagName = 'rng_element_' + rngElementName;

				if (rngElementName != "docxap") {

					var buttonId = 'kupu-' + rngElementName + '-button';
					var commonElement = rngElements[rngTagName];
					if (commonElement) {
						var icon_class = rngElements[rngTagName].classname;
					} else {
						var icon_class = default_icon_class;
					}

					var button = document.createElement('button');
					$(button).addClass(icon_class);
					button.setAttribute('type', 'button');
					button.setAttribute('id', buttonId);
					button.setAttribute('title', rngElementName);
					button.setAttribute('i18n:attributes', 'title');

					if (commonElement) {
						commonGroup.appendChild(button);
					} else {
						buttonGroup.appendChild(button);
					}

					var rngbutton = new XimdocRngElementButton(buttonId, model[rngElementName]);
					this.editor.registerTool(rngElementName + '_button', rngbutton);
					KupuButtonDisable(button);
				}
			}
		}
    	};

    	this.updateState = function(options) {

		if (!options.selNode || !options.event || options.event.type != 'mouseup') return;

		if (this.editor.ximElement && this.editor.ximParent) {
			var rngElement = this.editor.ximElement.schemaNode;
			var rngParent = this.editor.ximParent.schemaNode;

			this.tool.disableAllButtons();

			// Disable 'remove' button if element is not removable
			var button = getFromSelector('kupu-remove-button');
			if(this.editor.ximElement.isRemovable()) {
				KupuButtonEnable(button);
			} else {
				KupuButtonDisable(button);
			}

			if (!rngElement.type.contains('ximlet') && this.editor.selectedTextLength > 0) {
				// Enables 'Apply' type buttons.
				for (var i in rngElement.childNodes) {
					var childElement = rngElement.childNodes[i];
					if(!childElement.tagName)
						continue;
					if(childElement.type.contains('apply')) {
						var button = getFromSelector('kupu-' + childElement.tagName.replace(":", "_") + '-button');
						KupuButtonEnable(button);
					}
				}
			} else {
				// Enables allowed 'Add Sibling' buttons.
				for (var i in rngParent.childNodes) {
					var childElement = rngParent.childNodes[i];
					if(!childElement.tagName)
						continue;
					var button = getFromSelector('kupu-' + childElement.tagName.replace(":", "_") + '-button');
					KupuButtonEnable(button);
				}

				// Enables 'Edit Ximlet' button, if proceed.
				var button = getFromSelector('kupu-ximletdrawer-button');
				KupuButtonDisable(button);
				if(rngElement.type.contains('ximlet') && !this.editor.ximElement.isSectionXimlet()) {
					KupuButtonEnable(button);
				}
			}
		}
    	}
};

ToolbarButtonsToolBox.prototype = new XimdocToolBox();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



/**
 * This class highlights the selected elements
 */
function HighlightToolBox() {

	this._lastParent = null;
	this._lastElement = null;
	this._lastElements = null;
	this._lastHighlight = null;

	this.initialize = function(tool, editor) {
    	this.tool = tool;
        this.editor = editor;
        this.editor.logMessage(_('HighlightToolBox tool initialized'));
	};

	this.beforeUpdateContent = function(options) {
		// clean all selections
		if (options.selNode) this.highlightElement(null);
	};

	/**
	 * Do the highlight on the selected element
	 */
	this.updateState = function(options) {
		if (!options.selNode || (options.event && !['click', 'keyup'].contains(options.event.type)))
			return;
		this.highlightElement(options.selNode);
	};

	this.highlightElement = function(element) {

		// If element is null all the previuos elements will be unselected

		var parent = null;
		var selectedNodes = [];
		if (element) {
			parent = this.editor.getParentWithUID(element);
			selectedNodes = $('[uid="'+element.getAttribute('uid')+'"]', this.editor.getBody());
		}

		/*if (!selectedNodes.contains(element)) {
			selectedNodes = [element];
		}*/

		$((this._lastElements || [])).each(
			function(index, elem) {
				$(elem).removeClass('rng-element-selected');
				$(elem).attr("contentEditable",false);
				if(element && $(elem).attr('uid') == element.getAttribute('uid'))
					return;
			}
		);
		if (this._lastParent) {
			$(this._lastParent).removeClass('rng-parent-selected');
		}

		$(selectedNodes).each(
			function(index, elem) {
				$(elem).addClass('rng-element-selected');
				$(elem).attr("contentEditable",true);
				var parentElem = $(elem).parent();
				while (parentElem[0] && parentElem[0].tagName != "HTML"){
				    parentElem.attr("contentEditable",false);
				    parentElem = parentElem.parent();
				}
			}
		);
		if (parent && parent !== element) {
			$(parent).addClass('rng-parent-selected');
		}

		this._lastElement = element;
		this._lastElements = selectedNodes;
		this._lastParent = parent;
	};

	this.onMouseOver = function(options) {
		if (this._lastHighlight) {
			this.onMouseOut({selNode: this._lastHighlight});
		}
		if(!options.selNode.ximElement.isSelectable(this.editor.nodeId)) {
			options.selNode = options.selNode.ximElement.getFirstSelectableParent(this.editor.nodeId);
		}
		options.selNode.__background = $(options.selNode).css('background-color');
		options.selNode.__cursor = $(options.selNode).css('cursor');
		if(options.event.shiftKey)
			$(options.selNode).css({'background-color': '#000', 'cursor': 'move'});
		else
			$(options.selNode).css('background-color', '#DEDEDE');
		this._lastHighlight = options.selNode;
	};

	this.onMouseOut = function(options) {
		$(options.selNode).css('background-color', options.selNode.__background);
		$(options.selNode).css('cursor', options.selNode.__cursor);
	};

};

HighlightToolBox.prototype = new XimdocToolBox();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


/**
 * This class allows elements to be dragged/droped
 */
function DraggablesToolBox() {

	this._body = null;
	this._dragHandler = null;
	this._dragHandlerParent = null;
	this._dragging = false;
	this.lastDrag = { uid: null, time: null};
	this.lastDragParent =  { uid: null, time: null};

	this.initialize = function(tool, editor) {
    		this.tool = tool;
        	this.editor = editor;
        	this._body = editor.getBody();
		this.afterUpdateContent(null);
        	this.editor.logMessage(_('DraggablesToolBox tool initialized'));
	};

	this._elementIsallowed = function(element) {
		if (!element['rngElement']) return false;
		var rngElement = element.rngElement;
		var allowed = (!rngElement.type.contains('apply')) && (rngElement.tagName != 'docxap');
		//allowed = allowed && element.getAttribute('editable') != 'no';
		allowed = allowed && element.ximElement.isDroppable(this.editor.nodeId);
		return allowed;
	};

	/**
	 * Doing the highlight on the selected element
	 */
	this.updateState = function(options) {
		if (!options.selNode || (options.event && !['click', 'keyup','mouseenter'].contains(options.event.type)))
			return;
		this.onMouseOver(options);
		this.onMouseOver({selNode: this.editor.getParentWithUID(options.selNode)}, true);
	};

	this.onMouseOver = function(options, is_parent) {
		if (this._dragging) return;

		var handler = (is_parent) ? this._dragHandlerParent : this._dragHandler;

		var description = options.selNode.ximElement.schemaNode.description;
		var uid = options.selNode.getAttribute('uid');
		var pos = $(options.selNode).offset();
		var top = pos.top - $(handler).height();
		$(handler).text(description);
		var left = pos.left - $(handler).width();
		top = (top >= 0) ? top : 0;
		left = (left >= 0) ? left : 0;

		if(uid != this.lastDrag.uid && uid != this.lastDragParent.uid) {
			if(is_parent) {
				clearInterval(this.lastDragParent.time);
			}else {
				clearInterval(this.lastDrag.time);
			}

			handler.css({
				top: top + 'px',
				left: left + 'px'
			}).show();
		}else {
			return ;
		}

		handler[0].setAttribute('id', options.selNode.getAttribute('uid'));
		handler[0].draggableElement = options.selNode;


		if(is_parent) {
			this.lastDragParent.uid = uid;
			this.lastDragParent.time = setTimeout(function() {
				this.hide();
			}.bind(handler), 3*1000 /* 3 seconds */ );

			var tolerance = 20;
			var dist = Math.abs($(this._dragHandler).position().top - $(this._dragHandlerParent).position().top);
			var direction = (($(this._dragHandler).position().top - $(this._dragHandlerParent).position().top) <= 0) ? -1 : 1;
			var correction = (tolerance - dist) * direction;
			if(dist < tolerance)
				$(this._dragHandler).css({top: $(this._dragHandler).position().top + correction});
			return;
		}else {
			this.lastDrag.uid = uid;
			this.lastDrag.time = setTimeout(function() {
				this.hide();
			}.bind(handler), 3*1000 /* 3 seconds */ );
		}


		// deleting droppable and draggable elements
		this.beforeUpdateContent();
		// defining droppable elements
		this.editor.elements.each(function(index, elem) {
			if (/*this._elementIsallowed(elem) && */options.selNode.ximElement.schemaNode.isAllowedNearBy(elem.ximElement.schemaNode)) {
				$(elem).droppable({
					accept: '.kupu-draggable-handler',
					tolerance: 'touch',
					greedy: true,	// TODO: Test this option with other browsers than Firefox 3
					drop: function(event, ui) {
						this.onDrop(event, ui);
					}.bind(this)
				});
			}
		}.bind(this));
	};

	this.onMouseOut = function(options) {

		return;

		if (!this._elementIsallowed(options.selNode)) return;

		if (this._dragging) return;
		var uid = options.selNode.getAttribute('uid');

		var hide = true;
		try {
			var related = options.event.relatedTarget;
			hide = !$(related).hasClass('ui-draggable');
		} catch (e) {
			//console.error(e);
		}
		if (hide) {
			this._dragHandler[0].setAttribute('id', '');
			this._dragHandler[0].draggableElement = null;
			this._dragHandler.hide();
		}
	};

	this.beforeUpdateContent = function(options) {
		// Destroying draggable and droppable elements
//		var selector = '.ui-draggable:not(.ui-dialog), .ui-droppable:not(.ui-dialog)';
		var selector = '.xedit-rngelement';
		$(selector, this._body).each(function(index, elem) {
			if ($(elem).data("draggable"))
				$(elem).draggable('destroy');
			if ($(elem).data("droppable"))
				$(elem).droppable('destroy');
		});
	};

	this.afterUpdateContent = function(options) {

		// Important!
		this._body = this.editor.getBody();

		// Creating the draggable handler
		var draggable = $('<div id="" class="kupu-draggable-handler"></div>', this._body);
		var draggable_parent = $('<div id="" class="kupu-draggable-parent-handler kupu-draggable-handler"></div>', this._body);

		draggable[0].draggableElement = null;
		draggable_parent[0].draggableElement = null;
		$(this._body).append(draggable);
		$(this._body).append(draggable_parent);

       	$(draggable).draggable({
       		//iframeFix: true,
       		addClasses: false,
       		zIndex: 1000,
       		cursor: 'pointer',
       		opacity: 0.7,
       		scroll: true, // Not working inside an iframe
       		helper: 'clone',
       		document: this.editor.getInnerDocument(),
       		start: function(event, ui) {
       			this.onStart(event, ui);
       		}.bind(this),
       		/*drag: function(event, ui) {
       			this.onDrag(event, ui);
       		}.bind(this),*/
       		stop: function(event, ui) {
       			this.onStop(event, ui);
       		}.bind(this)
       	});

       	$(draggable_parent).draggable({
       		//iframeFix: true,
       		addClasses: false,
       		zIndex: 1000,
       		cursor: 'pointer',
       		opacity: 0.7,
       		scroll: true, // Not working inside an iframe
       		helper: 'clone',
       		document: this.editor.getInnerDocument(),
       		start: function(event, ui) {
       			this.onStart(event, ui);
       		}.bind(this),
       		/*drag: function(event, ui) {
       			this.onDrag(event, ui);
       		}.bind(this),*/
       		stop: function(event, ui) {
       			this.onStop(event, ui);
       		}.bind(this)
       	});

       	this._dragHandler = draggable;
       	this._dragHandlerParent = draggable_parent;

	};

	this.onStart = function(event, ui) {
		//console.log(event, ui, this);
		this._dragging = true;
		var uid = ui.helper[0].id;
		$('.xedit-rngelement[uid!='+uid+']', this._body).each(function(index, elem) {
			elem._beforeDragBorder = $(elem).css('border') || '';

			if (this.editor.getXimDocument().getElement(uid).schemaNode.isAllowedNearBy(elem.ximElement.schemaNode)) {
				$(elem).css({
					border: '1px dashed #006600'
				});
			}
		}.bind(this));
	};

	this.onDrag = function(event, ui) {
		//console.log(event, ui, this);
		this._dragging = true;
	};

	this.onStop = function(event, ui) {
		this._dragging = false;
		$('.xedit-rngelement', this._body).each(
			function(index, elem) {
				$(elem).css({
					border: (elem._beforeDragBorder || '')
				});
			}
		);
	};

	this.onDrop = function(event, ui) {

		this._dragging = false;

		// TODO: Fix tables here, this method is fired three times, once per table tag.

		var droppable = event.target;
		var draggable = ui.helper[0];

		var droppableUID = droppable.getAttribute('uid');
		var draggableUID = draggable.getAttribute('id');

		// Don't drop under the same element
		if (droppableUID == draggableUID) return;

		if ($('[uid="%s"] [uid="%s"]'.printf(draggableUID, droppableUID), this._body).length > 0) {
			// Parent dropped on a child, we don't want evil circular references
			return;
		}

		var ximElementDrag = this.editor.getXimDocument().getElement(draggableUID);
		var ximElementDrop = this.editor.getXimDocument().getElement(droppableUID);

		// You can't drag the root element
		if (Object.isEmpty(ximElementDrag.parentNode)) return;

		var elements = {
			droppable: droppable,
			draggable: draggable,
			ximElementDrag: ximElementDrag,
			ximElementOldParent: ximElementDrag.parentNode,
			ximElementOldPreviousSibling: ximElementDrag.previousSibling,
			ximElementOldNextSibling: ximElementDrag.nextSibling,
			ximElementDrop: ximElementDrop,
			ximElementNewParent: ximElementDrop.parentNode
		};

		var isCopy = event.shiftKey;
		if (!isCopy) {
			this._moveElement(elements);
		} else {
			this._copyElement(elements);
		}

		this.editor.getXimDocument().validateXML(function(valid, msg) {
	    	var blinkColor = '#43A1A2';//'#339900';
	    	var numOfBlinks = null;
	    	var blinkDuration = null;
	    	if (!valid) {
				this.editor.alert(msg);
				if (!isCopy) {
					this._undoMove(elements);
				} else {
					this._undoCopy(elements);
				}
				blinkColor = '#AA0000';
		    	numOfBlinks = 3;
		    	blinkDuration = 1000;
	    	}
	    	this.setActionDescription(_('Drag and drop'));
			this.editor.selNode = elements.clonedXimElement;
			this.editor.updateEditor({caller: this, callback: function () {this._blinkElement(elements.clonedXimElement.uid, blinkColor, numOfBlinks, blinkDuration, function () {});}.bind(this)});

	    }.bind(this));
	};

	this._blinkElement = function(elementUid, blinkColor, numOfBlinks, blinkDuration, callback) {

		if(!elementUid) return;
		if(!numOfBlinks) numOfBlinks = 1;
		if(!blinkDuration) blinkDuration = 1000;
		var blinkCount = numOfBlinks * 2;
		var duration = blinkCount * blinkDuration;

		$('[uid="' + elementUid + '"]', this._body).each(
			function(index, elem) {
				var oldBG = $(elem).css('background-color');
				console.log(oldBG);
				$(elem).animate({backgroundColor: blinkColor},blinkDuration, 
				function(){
					$(elem).animate({backgroundColor: oldBG},blinkDuration,
						function(){					 					
							$(elem).css({'background-color':oldBG});
						});
					}
				);
				/*var counter = blinkCount;
				var oldBG = $(elem).css('background-color');
				var oldBorder = $(elem).css('border');

				$(elem).css({
					'background-color': blinkColor,
					'border': '1px solid black'
				});
				do {
					$(elem)['fade' + (counter % 2 == 0 ? 'Out' : 'In')](blinkDuration);
					counter --;
				} while (counter > 0);
				setTimeout(function() {
						$(elem).css({
							'background-color': oldBG,
							'border': oldBorder
						});
						callback();
					},
					duration
				);*/
			}
		);
	}

	this._restoreChanges = function(ximElementDrag, ximElementOldParent, ximElementOldPreviousSibling, ximElementOldNextSibling) {
	};

	this._moveElement = function(e) {

		var ximdoc = this.editor.getXimDocument();

		// Modifying the ximdoc model
		ximdoc.removeChild(e.ximElementDrag);
		ximdoc.insertAfter(e.ximElementDrag, e.ximElementNewParent, e.ximElementDrop);
		//ximdoc.appendChild(e.ximElementDrag, e.ximElementNewParent);
		e.clonedXimElement = e.ximElementDrag;

		// Using copy/paste tools reduce the performance
		//this.tool.cutElement(e.ximElementDrag);
		//e.clonedXimElement = this.tool.pasteElement(e.ximElementNewParent, e.ximElementDrop);
	};

	this._undoMove = function(e) {
		//console.log(ximElementDrag, ximElementRoot, ximElementDrop);
		this.editor.getXimDocument().removeChild(e.clonedXimElement);
		if (e.ximElementOldPreviousSibling) {
			this.editor.getXimDocument().insertAfter(e.clonedXimElement, e.ximElementOldParent, e.ximElementOldPreviousSibling);
		} else if (e.ximElementOldNextSibling) {
			this.editor.getXimDocument().insertBefore(e.clonedXimElement, e.ximElementOldParent, e.ximElementOldNextSibling);
		} else {
			this.editor.getXimDocument().appendChild(e.clonedXimElement, e.ximElementOldParent);
		}
	};

	this._copyElement = function(e) {

		var ximdoc = this.editor.getXimDocument();
   		var ximElement = ximdoc.cloneElement(e.ximElementDrag, e.ximElementDrag.parentNode);

		// Modifying the ximdoc model
		ximdoc.removeChild(ximElement);
		ximdoc.insertAfter(ximElement, e.ximElementNewParent, e.ximElementDrop);
		e.clonedXimElement = ximElement;

		// Using copy/paste tools reduce the performance
		//this.tool.copyElement(e.ximElementDrag);
		//e.clonedXimElement = this.tool.pasteElement(e.ximElementNewParent, e.ximElementDrop);
	};

	this._undoCopy = function(e) {
		//console.warn(e.clonedXimElement);
		this.editor.getXimDocument().removeChild(e.clonedXimElement);
	};

};

DraggablesToolBox.prototype = new XimdocToolBox();



// Extends jQuery "draggable ui" to allow drag&drop inside the iframe.
// See "this.options.document"...
(function($) {

	$.extend($.ui.draggable.prototype, {
		_mouseDown: function(e) {
			// we may have missed mouseup (out of window)
			(this._mouseStarted && this._mouseUp(e));

			this._mouseDownEvent = e;

			var self = this,
				btnIsLeft = (e.which == 1),
				elIsCancel = (typeof this.options.cancel == "string" ? $(e.target).parents().add(e.target).filter(this.options.cancel).length : false);
			if (!btnIsLeft || elIsCancel || !this._mouseCapture(e)) {
				return true;
			}

			this.mouseDelayMet = !this.options.delay;
			if (!this.mouseDelayMet) {
				this._mouseDelayTimer = setTimeout(function() {
					self.mouseDelayMet = true;
				}, this.options.delay);
			}

			if (this._mouseDistanceMet(e) && this._mouseDelayMet(e)) {
				this._mouseStarted = (this._mouseStart(e) !== false);
				if (!this._mouseStarted) {
					e.preventDefault();
					return true;
				}
			}

			// these delegates are required to keep context
			this._mouseMoveDelegate = function(e) {
				return self._mouseMove(e);
			};
			this._mouseUpDelegate = function(e) {
				return self._mouseUp(e);
			};
			$(this.options.document)
				.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
				.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

			return false;
		},

		_mouseUp: function(e) {
			$(this.options.document)
				.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
				.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

			if (this._mouseStarted) {
				this._mouseStarted = false;
				this._mouseStop(e);
			}

			return false;
		},

		createHelper: function() {
			var o = this.options;
			var helper = null;

			// Fix a crash in IE when this.element.clone() is called
			// TODO: Try jQuery 1.3 ...
			try {
				helper = $.isFunction(o.helper)
					? $(o.helper.apply(this.element[0], [e]))
					: (
						o.helper == 'clone'
						? this.element.clone()
						: this.element
					);
			} catch(e) {
				helper = this.element;
			}

			if (!helper.parents('body').length)
				helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));
			if (helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
				helper.css("position","absolute");

			return helper;
		}

	});

	$.extend($.ui.draggable.defaults, {
		document: document
	});

})(jQuery);
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




var ToolContainerToolBox = Object.xo_create(new XimdocToolBox(), {

	_init: function(options) {

		this.container = $('.kupu-toolboxes-container')[0];
		this.collapser = $('.kupu-toolboxes-collapser')[0];
		this.element = $('.kupu-toolboxes-container-container')[0];
		
		$(this.element).droppable({
			accept: 'div',
			tolerance: 'pointer',
			drop: function(ev, ui) {
				this._onDrop($(ui.draggable[0]));
			}.bind(this)
		})/*.sortable()*/;
		
		$(this.collapser).click(function() {
			$(this.element).toggle();
			$(this.collapser).toggleClass('kupu-collapsed');
			$(this.container).toggleClass('kupu-toolboxes-container-collapsed');
			//$('.kupu-editor-iframe').toggleClass('kupu-editor-iframe-extended');
			$('.iwrapper').toggleClass('iwrapper-extended');
		}.bind(this));
	},
	
	_onDrop: function ($item) {
	    
	    var toolId = $('.ui-dialog-title', $item).attr('id');
	    if(!toolId) return this;
	    toolId = toolId.replace('ui-dialog-title-', '');
	    var title = $('.ui-dialog-title', $item).text();
    	var toolObj = this.editor.maintoolboxes[toolId];

	    if(toolObj !== null) {
    		toolObj.setElement({mode: toolObj.MODE_PANEL});
	    	$item.remove();
	    }

		return this;
	}

});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




var FloatingToolBox = Object.xo_create(new XimdocToolBox(), {

	MODE_DIALOG: 'dialog',
	MODE_PANEL: 'panel',

	_init: function(options) {

		this.toolboxId = options.toolboxId || null;
		this.ctrlButtonId = options.ctrlButtonId || null;
		this.buttonActiveClass = options.buttonActiveClass || '';
		this.buttonInactiveClass = options.buttonInactiveClass || '';
		this.visible = Object.isBoolean(options.visible) ? options.visible.valueOf() : true;
		this.mode = options.mode || this.MODE_PANEL;
		this.buttons = options.buttons || {};
	},
	initialize: function(tool, editor) {

		this.setElement();
		this.tool = tool;
		this.editor = editor;
		this.ctrlButton = null;

//		if ($('#'+this.ctrlButtonId).length > 0) {
//			this.ctrlButton = new ToggleButton({
//				buttonid: this.ctrlButtonId,
//				commandfunc: this.toggle.bind(this),
//				tool: this.tool,
//				activeClass: this.buttonActiveClass,
//				inactiveClass: this.buttonInactiveClass
//			});
//			editor.registerTool(this.ctrlButtonId, this.ctrlButton);
//			this.ctrlButton.setActive(this.visible);
//		}

		if(this.mode != this.MODE_DIALOG) return this;

		if (this.visible) this.show();
	},
	_createAttributeInput: function(label, value) {
		$(value).addClass('kupu-attribute-value');
		$(this.element).append(
			$('<div></div>')
				.addClass('xedit-element-attribute')
				.append($('<div></div>').addClass('kupu-toolbox-label').html('%s:'.printf(label)))
				.append($('<div></div>').addClass('kupu-toolbox-attribute-value').append(value)/*.change(this.updateButtonHandler.bind(this))*/)
				.show()
		);
	},

	_addHtml: function(html) {
		$(this.element).append(html);
	},

	_insertHtml: function(html) {
		$(this.element).html(html);
	},

	_createTreeSelector: function(input_id) {
		if($('#tree_selector' + input_id).length)
			$('#tree_selector' + input_id).toggle();
		else {
			var ds = new DataSource({
				url: url_root + '/inc/widgets/treeview/helpers/treeselectordata.php',
			});
			var tm = new TreeModel({colModel: {
				selector: 'tree tree',
				columns: [
					{name: 'text', label: 'Name', visible: true, width: ''},
					{name: 'nodeid', label: 'NodeId', visible: true, width: ''},
					{name: 'icon', label: 'Icon', visible: false, width: ''},
					{name: 'openIcon', label: 'OpenIcon', visible: false, width: ''},
					{name: 'children', label: 'Children', visible: false, width: ''},
					{name: 'isdir', label: 'IsDir', visible: false, width: ''},
					{name: 'tipofiltro', label: 'filter', visible: false, width: ''},
				]
			}, ds: ds});
			$('#' + input_id).parent().parent().after(
				$('<div></div>').addClass('xedit-element-attribute').append(
					$('<div></div>').addClass('kupu-toolbox-attribute-value').append(
						$('<div></div>').attr('id', 'tree_selector' + input_id)
					)
				)
			);
		}
		$('#tree_selector' + input_id).treeview({rowModel: tm})
			.bind('expand', function(event, params) {})
			.bind('collapse', function(event, params) {})
			.bind('select', function(event, params) {if(arguments[1].data.isdir != 1) {$('#' + input_id).val(arguments[1].data.nodeid); this.updateButtonHandler(event);}}.bind(this));
	},
	setElement: function(options) {

		this.mode = options ? this.mode = options.mode : this.mode;

		if (options === null && this.toolboxId !== null && $('#'+this.toolboxId).length > 0) {
			this.element = $('#'+this.toolboxId)[0];
			return this;
		}

		this.element = this.element ? this.element : $('<div></div>')[0];

		if (this.toolboxId !== null) {
			$(this.element).attr('id', this.toolboxId);
		}

		this._setElementView();
		this.setTitle();
	},
	_setElementView: function() {

		if(this.mode != this.MODE_DIALOG) {

			var createButton = function(value, callback) {
				var $btn = $('<button class="ui-state-default ui-corner-all" type="button">%s</button>'.printf(value));
				$btn.click(callback);
				return $btn;
			};

			var container = $('<div class="kupu-toolbox-container"></div>');
			$(this.element).appendTo(container);
			$(container).insertAfter('.kupu-toolboxes-container-container .kupu-toolbox-container:first'); 	

			$(this.element).addClass('ui-dialog-content ui-dialog-widget ui-widget-content');

//			$(this.element).wrap($('<div class="kupu-toolbox-scrollpanel"></div>'));

			var buttons = [];
			for (var o in this.buttons) {
				buttons.push(createButton(o, this.buttons[o]));
			}

			if (buttons.length > 0) {
				var $buttonBar = $('<div class="kupu-toolbox-buttonbar"></div>').appendTo(container);
				buttons.each(function(index, item) {
					$buttonBar.append(item);
				});
			}

			if (this.visible) {
				$(this.element).show();
			} else {
				$(this.element).hide();
			}
			return this;
		}

		var container = $(this.element).closest('div.kupu-toolbox-container');
		$('div.kupu-toolbox-buttonbar', container).unbind().remove();


		var check = $(this.element).data("dialog");

		if(check) {
			$(this.element).dialog("destroy");
		}


		$(this.element).appendTo('body');
		$(this.element).dialog({
			autoOpen: false,
			dialogClass: 'xedit-toolbox '+(this.toolboxId || ''),
			width: 400,
			resizable: true,
			closeOnEscape: false,
			modal: false,
			stack: true,
			position: 'center',
			buttons: this.buttons,
			close: function() {
				this.setElement({mode: this.MODE_PANEL});
				if (this.ctrlButton !== null) {
					this.ctrlButton.setActive(false);
				}
				$(this).dialog('destroy');
			}.bind(this)
		});
		this.dialog = $(this.element).closest('.ui-dialog').get(0);
		this.titlebar = $('.ui-dialog-titlebar', this.dialog)
			.click(this.collapse.bind(this))
			.get(0);
	},
	setOption: function(name, value) {
		if(this.mode != this.MODE_DIALOG) return this;
		if (Object.isString(name)) {
			$(this.element).dialog('option', name, value);
		} else if (Object.isObject(name)) {
			for (var o in name) {
				this.setOption(o, name[o]);
			};
		}
		return this;
	},
	setTitle: function(title) {

		if (Object.isString(title) && this.title != title) {
			this.title = title.trim();
		}

		if (Object.isEmpty(this.title)) {
			return;
		}

		if (this.mode != this.MODE_DIALOG) {

			var $title = $('<h3>' + this.title + '</h3>');
			$($title).addClass('kupu-toolbox-heading kupu-toolbox-heading-opened');
			$($title).prepend($('#' + this.ctrlButtonId));
			$(this.element).before($title);

			var container = $(this.element).closest('div.kupu-toolbox-container');

			if ($(this.element).is(':hidden')) {
				$('div.kupu-toolbox-buttonbar', container).hide();
				$($title).toggleClass('kupu-toolbox-heading-closed');
				$($title).toggleClass('kupu-toolbox-heading-opened');
			}

			$($title).click(function() {
				$('div.ui-dialog-content, div.kupu-toolbox-buttonbar', container).toggle();
				$(this).toggleClass('kupu-toolbox-heading-closed');
				$(this).toggleClass('kupu-toolbox-heading-opened');
				return false;
			});

			this._makeDraggable($title);
			return this;

		} else {

			$('div.ui-dialog-titlebar', this.dialog).prepend($('#' + this.ctrlButtonId));
		}

		this.setOption('title', _(this.title));
		return this;
	},
	show: function() {
		$(this.element).dialog('open');
		return this;
	},
	hide: function() {
		$(this.element).dialog('close');
		return this;
	},
	toggle: function() {
		if($(this.element).closest('.ui-dialog')[0]) {
			if (['', 'none'].contains($(this.element).closest('.ui-dialog').css('display'))) {
				this.show();
			} else {
				this.hide();
			}
		} else {
			var title = $(this.element).prev().text();
			// Don't show buttons in toolbar
//			$('#toolbar > span').children('.kupu-tb-buttongroup:last').append($('#' + this.ctrlButtonId));
			$(this.element).prev().remove();
			this.setElement({mode: this.MODE_DIALOG});
    		this.setTitle(title);
	    	this.show();
		}
		return this;
	},
	_clean: function() {
		$(this.element).unbind().empty();
		return this;
	},
	collapse: function() {
		if(this.mode != this.MODE_DIALOG) return this;
		if ($(this.dialog).hasClass('xedit-collapsed')) {
			$(this.dialog).animate({height: '150px'}, 400);
			$(this.element).show();
			$('.ui-dialog-buttonpane', this.dialog).show();
//			$(this.element).slideDown('fast');
//			$('.ui-dialog-buttonpane', this.dialog).slideDown('fast');
		} else {
			$(this.element).hide();
			$('.ui-dialog-buttonpane', this.dialog).hide();
			$(this.dialog).animate({height: '20px'}, 400);
//			$(this.element).slideUp('fast');
//			$('.ui-dialog-buttonpane', this.dialog).slideUp('fast');
		}
		$(this.dialog).toggleClass('xedit-collapsed');
	},
	beforeUpdateContent: function(options) {

	},
	updateState: function(options) {

	},
	updateButtonHandler: function(event) {

	},

	_makeDraggable: function(title) {

        $(title).draggable({
        	containment: $('.kupu-editorframe'),
			helper: 'clone',
        	appendTo: 'body',
        	iframeFix: false,
        	start: function(event, ui) {

        		var helper = $(ui.helper[0])
        			.clone()
					.addClass('ui-cloned-helper')
        			.css({
        				position: 'absolute',
        				width: '300px',
        				/*height: '26px',*/
        				/*background: 'url("../../gfx/fnd-tab.png") repeat scroll 0 0 transparent',
						border: '1px solid #ccc',
						'background-repeat': 'no-repeat'*/
        			})
        			.show()
        			.appendTo(this.editor.getBody());

        	}.bind(this),
        	drag: function(event, ui) {

				var view = this.editor.getBody().ownerDocument.defaultView;
				var p = {
//					top: ui.position.top - $('.kupu-editorframe').position().top + view.scrollY,
					top: ui.absolutePosition.top - $('.kupu-editorframe').position().top + view.scrollY,
//					left: ui.position.left
					left: ui.absolutePosition.left
				};
				$('.ui-cloned-helper', this.editor.getBody()).css({
					top: p.top,
					left: p.left
				});
        	}.bind(this),
        	stop: function(event, ui) {

        		// TODO: elementFromPoin will not work in all browsers
        		// See http://www.quirksmode.org/dom/w3c_cssom.html
        		// Parameters can be diferent in distinct browsers

        		$('.ui-cloned-helper', this.editor.getBody()).remove();
        		var p = {
//        			x: ui.position.top,
        			x: event.clientX,
//        			x: event.pageX,
//        			y: ui.position.left - $('.kupu-editorframe').position().top
        			y: event.clientY - $('.kupu-editorframe').position().top
//        			y: event.pageY - $('.kupu-editorframe').position().top
        		};

        		var element = this.editor.getBody().ownerDocument.elementFromPoint(p.x, p.y);
        		element = element && element.ximElement ? element.ximElement : null;

        		if (element != null) {
        			// helper has been dropped into the iframe
        			this.toggle();
        		}
        	}.bind(this)
        });
	}
});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */

var XimdexLogger = Object.xo_create(FloatingToolBox, {
	/* writes messages to a debug tool and throws errors */

	_init: function(options) {

		XimdexLogger._construct(this, options);

		this.maxlength = options.maxlength;
		this.active = true;	// TODO: parametrize kupu_config.xml
		this.activateButton = null;

        	$('#kupu-toolbox-debug').unbind().remove();
        	$(this.element).attr('id', 'kupu-toolbox-debuglog');

        	this.initialize(options.tool, options.editor);
	},

	initialize: function(tool, editor) {

		this.buttons = {
			Desactivar: this.setActive.bind(this),
			Limpiar: this.updateButtonHandler.bind(this)
		};

		AttributesToolBox._super(this, 'initialize', tool, editor);

		this.setTitle(_('Debug log'));
		this.setOption({
			title: _('Debug log'),
			width: 480,
			height: 300
		});
	},

	setActive: function(active) {

		if (!this.activateButton) {
			this.activateButton = $(this.element).parent().find('button').filter(function() {
	    			var text = $(this).html();
	    			return text == 'Desactivar' || text == 'Activar';
	    		})
//	    		.html(this.active ? 'Desactivar' : 'Activar')
	    		.get(0);
		}

		this.active = Object.isBoolean(active) ? active.valueOf() : !this.active;
		$(this.activateButton).html(this.active ? 'Desactivar' : 'Activar');
	},

	updateButtonHandler: function(event) {
		$(this.element).empty();
	},

	log: function(message, severity) {

		if (!this.active || Object.isEmpty(this.element)) return;

		/* log a message */
		if (this.maxlength) {
		    if (this.element.childNodes.length > this.maxlength - 1) {
	        	this.element.removeChild(this.element.childNodes[0]);
		    }
		}
		var now = new Date();
		var time = this.formatTime(now);

		var div = document.createElement('div');
		var span = document.createElement('span');
		var subtext = document.createTextNode (time);
		//var text = document.createTextNode(window.i18n_message_catalog.acents(message));

		span.appendChild(subtext);
		//div.appendChild(text);
		div.innerHTML = window.i18n_message_catalog.acents(message);
		div.appendChild(span);

		var firstChild = $('div', this.element)[0];
		if (!firstChild) {
			this.element.appendChild(div);
		} else {
			this.element.insertBefore(div, firstChild);
		}
	},

	formatTime: function(time) {
		var hours = (time.getHours() < 10) ? '0' + time.getHours() : time.getHours();
		var minutes = (time.getMinutes() < 10) ? '0' + time.getMinutes() : time.getMinutes();
		var seconds = (time.getSeconds() < 10) ? '0' + time.getSeconds() : time.getSeconds();
		return hours + ':' + minutes + ':' + seconds;
	}

});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision: 7876 $
 */

var InfoToolBox = Object.xo_create(FloatingToolBox, {

	initialize: function(tool, editor) {
		InfoToolBox._super(this, 'initialize', tool, editor);
		this.setTitle(_('Information'));
		this.getInfo();
		setInterval(function() {
			this.getInfo();
		}.bind(this), 60000);
	},

	_setInformation: function(_label, _value)  {
		this._addHtml( "<div><strong>"+_label+"</strong>: "+_value+"</div>");
	},

	getInfo: function() {
		this._insertHtml(_("Updating data")+"...");

		var url = this.editor._baseURL+"&method=getInfo";

		new AjaxRequest(url, {
			method: 'GET',
			onComplete: function(req, json) {
				if(null != json) {
					this.setInfo(json);
				}
			}.bind(this),

			onError: function(req) {

			}.bind(this)
		});
	},

	setInfo: function(data) {
		this._insertHtml("");
		this._setInformation(_("NodeId"), this.editor.nodeId);
		this._setInformation(_("Name"), data.name);
		this._setInformation(_("Path"),data.path) ;
		this._setInformation(_("Last version"),data.version+"."+data.subversion);
		/** Last modified date" */
		var info_date = new Date(data.date*1000)
		this._setInformation(_("Last modified"),info_date);
		this._setInformation(_("Last modified by"),data.lastusername);
		var state = _("Published");
		if(0 == data.published) {
			state = _("Not published");
		}
		if(2 == data.published){
			state = _("Published (*)");
		}
		this._setInformation(_("State"),state);

	}
});
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */

var that2;
var inputUrl2;


var AttributesToolBox = Object.xo_create(FloatingToolBox, {

	initialize: function(tool, editor) {

		var label = _('Update');

		eval("this.buttons = { "+label+": this.updateButtonHandler.bind(this) };");

		AttributesToolBox._super(this, 'initialize', tool, editor);

		this.setTitle(_('Attributes'));
		this.currentInput = null;
		this.imgObserver = null;
		this.imgDim = {w: -1, h: -1};
	},

	startStopTimer: function(ximElement) {

		var t = XimTimer.getInstance();

		var htmlDoc = this.editor.getBody().parentNode;
		var domElement = $('[uid="%s"]'.printf(ximElement.uid), htmlDoc).get(0);

		t.removeAllObservers();

		if (domElement.tagName.toUpperCase() != 'IMG') {
			t.stop();
			this.imgDim = {w: -1, h: -1};
			return;
		}

		this.imgObserver = t.addObserver(this.updateImageSize.bind(this, domElement), 500);
		t.start();
	},

	updateImageSize: function(domElement) {

		var w = $(domElement).width();
		var h = $(domElement).height();

		if (w == this.imgDim.w && h == this.imgDim.h) {
			return;
		}

		this.imgDim.w = w;
		this.imgDim.h = h;

		$('input#kupu-attributes-width', this.element).val(w);
		$('input#kupu-attributes-height', this.element).val(h);
	},

	beforeUpdateContent: function(options) {
		this._clean();
	},

	updateState: function(options) {

		if (!this.tool.selNode || (options.event && options.event.type != 'click')) return;

		this._clean();

		var input = null;
		$('<div></div>')
			.addClass('xedit-element-name')
			.html(this.tool.selNode.tagName)
			.appendTo(this.element);
		for (var attrName in this.tool.attributes) {

			var attr = this.tool.attributes[attrName];

			if (typeof attr.value == "object"){
				input = document.createElement('select');

				for (var i=0,l=attr.value.length; i<l; i++) {

					var value = attr.value[i];

					var option = document.createElement('option');
					option.setAttribute('value', value);
					text = document.createTextNode(value);
					option.appendChild(text);
					input.appendChild(option);

					if (value == attr.selectedValue) {
						option.setAttribute('selected', 'selected');
					}
				}

			} else {

				input = document.createElement('input');
				input.setAttribute('type', 'text');
			    input.value = attr.value || '';
			}

			$(input).data('attribute-name', attrName);
			input.setAttribute('class', 'wide');
			input.setAttribute('id', 'kupu-attributes-' + attrName);

			if (attrName == 'uid') {
				input.setAttribute('type', 'hidden');
			}

			if (!this.tool.PROTECTED_ATTRIBUTES.contains(attrName)) {

				if (attr.type === null) {

					this._createAttributeInput(attrName, input);
				} else {

					var method = '_createInputFor_' + attr.type;
					if (Object.isFunction(this[method])) {
						this[method](attrName, input);
					}else{
						this._createInputFor_genericSelector(attrName, input,[]);
					}
					
//					$(input).click(function (e) {this._createTreeSelector($(e.currentTarget).attr('id'));}.bind(this));
				}
			}

		}

		this.startStopTimer(this.tool.selNode);
	},

	updateButtonHandler: function(event) {

		var t = XimTimer.getInstance();
		t.removeObserver(this.imgObserver);

		var attributes = {};

		$('.kupu-attribute-value', this.element).each(function(index, elem) {
			var attrName = $(elem).data('attribute-name');
			var attrValue = $(elem).val();
			attributes[attrName] = attrValue;
		});

		this.tool.saveAttributes(attributes);

		this.editor.logMessage(_('Attributes updated!'));

		// NOTE:
		// Updating Editor Content, because actually we don't edit html attributes but xml.
		this.setActionDescription(_('Update attributes'));

		// When update button is clicked, selected element losts its focus,
		// so we clean the attributes panel to prevent errors.
		// UpdateEditor will populate panel again.
		this._clean();

		this.editor.updateEditor({caller: this});
	},

	_createInputFor_ximlink: function(label, inputUrl) {

		var ximElement = this.tool.selNode;

		var $inputUrl = $(inputUrl)
			.addClass('kupu-attribute-value')
			.val(ximElement.ximLink.url);

		var inputUrlId = $inputUrl.attr('id');

		var $inputText = document.createElement('input');
		$inputText.setAttribute('type', 'text');
		$inputText = $($inputText)
			.attr('id', inputUrlId + '-text')
			.addClass('wide kupu-attribute-ximlink-value')
			.val(ximElement.ximLink.text);

		var $inputName = document.createElement('input');
		$inputName.setAttribute('type', 'text');
		$inputName = $($inputName)
			.attr('id', inputUrlId + '-name')
			.addClass('wide kupu-attribute-ximlink-value')
			.val(ximElement.ximLink.name);

		var that = this;
		$inputName.change(function(event){that._save_attribute_ximlink(event, $inputUrl,$inputText, $inputName)});
		$inputText.change(function(event){that._save_attribute_ximlink(event, $inputUrl,$inputText, $inputName)});
		$inputUrl.change(function(event){that._save_attribute_ximlink(event, $inputUrl,$inputText, $inputName)});

		var $label = $('<div></div>').addClass('kupu-toolbox-label').html('%s:'.printf(label));
		var $fieldLabel = $('<label></label>');
		var $wrap = $('<div></div>').addClass('kupu-toolbox-attribute-value');
		var $button = $('<button></button>')
			.addClass('ximlink-search')
			.attr('type', 'button')
			.html(_('Search'))
			.click(function(event){ that._openXimlinkSelector(event, $inputUrl, $inputText, $inputName)});

		var $labelName = $fieldLabel.clone().attr('for', $inputName.attr('id')).html(_('Name:'));
		var $labelUrl = $fieldLabel.clone().attr('for', $inputUrl.attr('id')).html('Url:');
		var $labelText = $fieldLabel.clone().attr('for', $inputText.attr('id')).html(_('Text:'));


		var d = $('<div></div>')
			.addClass('xedit-element-attribute')
			.append($label)
			.append($labelName)
			.append($inputName.wrap($wrap.clone()))
			.append($labelUrl)
			.append($inputUrl.wrap($wrap.clone()));

		if (ximElement.tagName != 'image') {
			d.append($labelText).append($inputText.wrap($wrap.clone()));
		} else {
			$labelText.remove();
			$inputText.unbind().remove()
		}

		d.append($button);

		$(this.element).append(d);
	},

	_openXimlinkSelector: function(event, $inputUrl, $inputText, $inputName) {
		var drawerId = 'ximlinkdrawer';

		if($inputText) {
			var term = $inputText.val();
		}else {
			var term = "";
		}

		var dt = this.editor.getTool('ximdocdrawertool');
		if (dt.isOpen(drawerId)) return;

		var $button = $('button.ximlink-search', this.element).unbind('click');

		$.getJSON(
			X.restUrl + '?action=xmleditor2&method=getAvailableXimlinks&term='+term,
			{docid: this.editor.nodeId},
			function(data, textStatus) {

				dt.drawers[drawerId].setData(data);
				dt.drawers[drawerId].setMainTerm(term);
				dt.openDrawer(drawerId);
				$button.click(this._openXimlinkSelector.bind(this, $inputUrl, $inputText, $inputName));

			}.bind(this)
		);
	},



	_createInputFor_genericSelector : function(label, inputUrl, specificSearchOptions){

		var searchOptions = [{comparation: 'equal',
                                                content: this.editor.nodeId,
                                                field: 'nodeid',
                                                from: '',
                                                to: ''
					}];
		
		var $inputUrl = $(inputUrl).addClass('kupu-attribute-value');

		searchOptions = searchOptions.concat(specificSearchOptions);
		var getImageSelector = function($inputUrl){
			this.imageSelector = null;
			if (Object.isEmpty(this.imageSelector)){
				this.imageSelector = $("<div></div>").appendTo(this.element);
				this.imageSelector.searchpanel({
                                        url_base: X.baseUrl,
                                        use_cache: false,
                                        queryHandler: "SQLTREE",
                                        masterFilter: [{
                                                comparation: 'equal',
                                                content: '5040',
                                                field: 'nodetype',
                                                from: '',
                                                to: ''
                                        }, {
                                                comparation: 'equal',
                                                content: this.editor.nodeId,
                                                field: 'nodeid',
                                                from: '',
                                                to: ''
                                        }
                                        ],
                                        showFilters: false,
                                        view: 'treeview',
                                        showSelectButton: true
                                });

			}

			that2 = this;
                        inputUrl2 = $inputUrl;
                        $(this.imageSelector)
                                .unbind('nodesSelected')
                                .bind('nodesSelected', 
					this._imageSelector_onNodesSelected);

                        return this.imageSelector;

		}.bind(this);

		
		var $sp = getImageSelector($inputUrl);

		var $label = $('<div></div>')
			.addClass('kupu-toolbox-label')
			.html('%s:'.printf(label));		
		var $wrap = $('<div></div>')
			.addClass('kupu-toolbox-attribute-value');
		 
		var $button = $('<button></button>')
			.addClass('imageSelector-search')
			.attr('type', 'button')
			.html(_('Search'));


		var that = this;
		$button.click(function(){
			//Updating current input at open the imageSelector
			that.currentInput = $inputUrl;
			$sp.searchpanel("option","masterFilter",searchOptions);
			$sp.searchpanel("open");

			if ($inputUrl.val() && $inputUrl.val() != ""){
	                        var value = $inputUrl.val();
                                if (value.indexOf(",") != -1)
         	                       value = value.substring(0,value.indexOf(","));
				$sp.searchpanel("setSelectedElement, value");
                    	        $(".xim-treeview-container").treeview("navigate_to_idnode_from_project", value);
			}

		}.bind(this));
		
		var d = $('<div></div>')
			.addClass('xedit-element-attribute')
			.append($label)
			.append(
				$wrap.append($inputUrl).append($button)
			);

		$(this.element).append(d);

	},
	_createInputFor_ximdocSelector: function(label, inputUrl) {

		var searchOptions = [{
					comparation: 'equal',
                                        content: '5032',
                                        field: 'nodetype',
                                        from: '',
                                        to: ''                          
                                    }];

		this._createInputFor_genericSelector(label, inputUrl, searchOptions);
	},
	_createInputFor_imageSelector: function(label, inputUrl) {

		var searchOptions = [{
					comparation: 'equal',
                                        content: '5040',
                                        field: 'nodetype',
                                        from: '',
                                        to: ''                          
                                    }];

		this._createInputFor_genericSelector(label, inputUrl, searchOptions);
	},

	_createInputFor_ximletSelector: function(label, inputUrl){
		var searchOptions = [{
					comparation: 'equal',
                                        content: '5057',
                                        field: 'nodetype',
                                        from: '',
                                        to: ''				
              				}]; 
		this._createInputFor_genericSelector(label, inputUrl, searchOptions);
	},

	_createInputFor_ximcludeSelector: function(label, inputUrl){

		var searchOptions = [{
					comparation: 'equal',
                                        content: '5076',
                                        field: 'nodetype',
                                        from: '',
                                        to: ''
				}];
		this._createInputFor_genericSelector(label, inputUrl, searchOptions);
	},

	_imageSelector_onNodesSelected: function(event, params) {

		$(that2.imageSelector).unbind('nodesSelected');
		var image = params.selection.length > 0 ? params.selection[0] : false;
		if (!image) return;
		if (!that2.currentInput) return;
			that2.currentInput.val(image.nodeid.value);
	},

	_save_attribute_ximlink: function(event, $inputUrl, $inputText, $inputName) {

		this.tool.selNode.ximLink.name = $inputName.val();
		this.tool.selNode.ximLink.url = $inputUrl.val();
		this.tool.selNode.ximLink.text = $inputText.val();
		this.updateButtonHandler();
	}

});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




var ChannelsToolBox = Object.xo_create(FloatingToolBox, {

	initialize: function(tool, editor) {
		AttributesToolBox._super(this, 'initialize', tool, editor);
		this.setTitle(_('Channels'));
		this.select = $('<select></select>')
			.addClass('wide')
			.attr('id', 'kupu-channels');
		$(this.editor.channels).each(function(index, elem) {
			this.select.append(
				$('<option></option>')
					.val(elem.channelId)
					.html(elem.channel)
			);
		}.bind(this));
		this.select = this.select[0];
		this.getChannelId();
		this._createAttributeInput(_('Select a channel'), this.select);
		$('#kupu-toolbox-channels').unbind().remove();
	},
	updateState: function(options) {
		// None at this moment
	},
	updateButtonHandler: function(event) {

		loadingImage.showLoadingImage();
		var newChannel = this.select.options[this.select.selectedIndex].text;
		var channelId = this.select.options[this.select.selectedIndex].value;
		this.editor.getXimDocument()._channelId = channelId;
		var docxap = this.editor.getXimDocument().getRootElement();
		docxap.attributes['channel'] = newChannel;

		this.setActionDescription(_('Channel changed to') + ' ' + newChannel);
		this.editor.logMessage(_('Channel changed to') + ' ' + newChannel);
		this.editor.updateEditor({caller: this, updateContent: false});
		loadingImage.hideLoadingImage();
	},
	getChannelId: function(){
                var channelId = this.select.options[this.select.selectedIndex].value;
                this.editor.getXimDocument()._channelId = channelId;
	}
});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */


var ChangesetToolBox = Object.xo_create(FloatingToolBox, {

	_init: function(options) {

		ChangesetToolBox._construct(this, options);

		this._maxlength = options.maxlength;
		this._nChangeset = 0;

		this._isRestoring = false;
		this.stack = null;
		this.p = null;

		this._content = null;
		this._struct = null;
		this._element = null;
	},

	initialize: function(tool, editor) {
	    	this.tool = tool;
	        this.editor = editor;

		ChangesetToolBox._super(this, 'initialize', tool, editor);
		this.setTitle(_('Change history'));
		this.setOption('buttons', null);

	        $('#kupu-toolbox-undo').unbind().remove();
	        $(this.element).attr('id', 'kupu-toolbox-undolog');

		var undobutton = new KupuButton('kupu-undo-button', function() {
			this.undo();
		}.bind(this));
		editor.registerTool('undobutton', undobutton);

		var redobutton = new KupuButton('kupu-redo-button', function() {
			this.redo();
		}.bind(this));
		editor.registerTool('redobutton', redobutton);

	        this.editor.logMessage(_('UndoToolBox tool initialized'));
	},

	updateState: function(options) {

		// Content changes
		if (this._isRestoring) return;

		var saveState = false;

		if (this._element != options.selNode) {
			if (this._content != $(this._element).text()) {
				var ximdoc = this.editor.getXimDocument();
				saveState = true;
				//this.editor.updateEditorContent();
				if (this._element && this._element.isEditable) {
					var ximElement = ximdoc.importHtmlElement(this._element);
					ximdoc.updateElement(ximElement.uid, ximElement);
				}
			}
			this._content = $(options.selNode).text();
			this._element = options.selNode;
		}

		if (options.caller) {
			options.caller.setActionDescription('');
		}

		description = _('Content updated');
		if (saveState) this.saveState(description);

	},

	afterUpdateContent: function(options) {

		if (this._element) {
			// NOTE: Be sure to keep updated this object reference always!
			// NOTE: Corrects a bug on the "Enter functionality"!
			// When user press enter key, the selected element breaks into two pieces and the
			// editor is refreshed to correct that "break".
			// In this case, this._element reference is outdated and the content will be lost.
			this._element = $('[uid="'+this._element.getAttribute('uid')+'"]', this.editor.getInnerDocument())[0];
		}

		// XML structure changes
		if (this._isRestoring) return;

		var saveState = false;
		var struct = this.editor.getXimDocument().saveXML({
			asString: true,
			hideXimlets: true
		});

		if (struct != this._struct) {
			this._struct = struct;
			saveState = true;
		}

		description = '';
		if (options.caller) {
			description = options.caller.getActionDescription() || "";
			if( (null == description || '' == description) && null != this.editor) {
				description = this.editor.getActionDescription();
			}
			options.caller.setActionDescription('');
		}else if( null != this.editor) {
			description = this.editor.getActionDescription();
		}

		if(''==description || '' ==description) {
				description = _("Create ")+_("element");
		}

		if (saveState) this.saveState(description);
	},

	saveState: function(label) {

		if (this._isRestoring) return;

		// Linear, multiuser undo
		// It doesn't manage branches, when a new state is saved
		// it removes all states after the "pointer" position.
		var xml = this.editor.getXimDocument().saveXML({
			asString: true,
			hideXimlets: false
		});
		if (!this.stack) {
			this.p = -1;
			this.stack = [];
		}

		var previousXML = this.stack[this.p];

		if (this.p == (this.stack.length - 1)) {
			if (xml != previousXML) this.stack.push(xml);
		} else {
			var ndelete = this.stack.length - this.p;
			this.stack.splice(this.p, ndelete, xml);
			// Updating the history panel, we have just removed some changesets...
			$('div.changeset-item', this.element).each(function(index, elem) {
				if (!this.stack[index] || index == this.p) {
					$(elem).remove();
				}
			}.bind(this));
		}

		// keeping always the specified number of changes
		while (this.stack.length > this._maxlength) {
			this.stack.shift();
		}

		this.p = this.stack.length - 1;
		if(this.p==0){
			$("#kupu-undo-button").addClass("disabled");
		}
		else{
			$("#kupu-undo-button").removeClass("disabled");
		}

		if(this.p == this.stack.length-1){
			$("#kupu-redo-button").addClass("disabled");
		}
		else{
			$("#kupu-redo-button").removeClass("disabled");
		}
		this.log(label);

		// Updating the pointer to the change stack
		$('div.changeset-item', this.element).each(function(index, elem) {
			elem._changesetId = index;
		});

	},

	setState: function(event) {

		var changesetId = (event.currentTarget || event.target)._changesetId;
		var state = this.stack[changesetId];
		if (!state) {
			this.editor.logMessage(_('Changeset not found!'));
			return;
		}
		this.p = changesetId;
		this.restoreChangeset(state);
	},

	restoreChangeset: function(state) {
		loadingImage.showLoadingImage();
		this._isRestoring = true;
		var doc = this.editor.createDomDocument(state);
		this.editor.getXimDocument().loadXML(doc, this.editor.getRngDocument());
		// Don't update the editor content or we could lost some changes!
		this.editor.updateEditor({updateContent: false});
		this.editor.logMessage(_('Restoring changeset') + ' ' + this.p);
		this._isRestoring = false;
		loadingImage.hideLoadingImage();
	},

    	undo: function() {
    		if (this.p <= 0) {
    			this.p = 0;
			$("#kupu-undo-button").addClass("disabled");
    			return;
    		}
		var state = this.stack[--this.p];
    		if (this.p <= 0) {
			$("#kupu-undo-button").addClass("disabled");
		}
		$("#kupu-redo-button").removeClass("disabled");
		this.restoreChangeset(state);
    	},

    	redo: function() {
    		if (this.p >= this.stack.length - 1) {
    			this.p = this.stack.length - 1;
			$("#kupu-redo-button").addClass("disabled");
    			return;
    		}
		var state = this.stack[++this.p];
    		if (this.p >= this.stack.length - 1) {
			$("#kupu-redo-button").addClass("disabled");
		}
    			this.p = this.stack.length - 1;
		$("#kupu-undo-button").removeClass("disabled");
		this.restoreChangeset(state);
    	},

	log: function(label) {
		/* log a message */
		if (this._maxlength) {
		    if (this.element.childNodes.length > this._maxlength) {
	        	//this.element.removeChild(this.element.childNodes[0]);
	        	var elem = $('div.changeset-item', this.element)[0];
	        	$(elem).remove();
		    }
		}
		var now = new Date();
		var time = this.formatTime(now);

		var div = document.createElement('div');
		$(div).addClass('changeset-item');
		// ... expert mode ...
		if (!this.editor.schemaValidatorIsActive()) $(div).addClass('invalid-changeset');
		++this._nChangeset;
		var span = document.createElement('span');
		var subtext = document.createTextNode(time);
		span.appendChild(subtext);
		var text = document.createTextNode(label);
		div.appendChild(text);
		div.appendChild(span);
		div._changesetId = this.p;
		$([div, text]).click(this.setState.bind(this));
		this.element.appendChild(div);
	},

	formatTime: function(time) {
		var hours = (time.getHours() < 10) ? '0' + time.getHours() : time.getHours();
		var minutes = (time.getMinutes() < 10) ? '0' + time.getMinutes() : time.getMinutes();
		var seconds = (time.getSeconds() < 10) ? '0' + time.getSeconds() : time.getSeconds();
		return hours + ':' + minutes + ':' + seconds;
	}

});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */



/**
*<p>Toolbox to manage tags about the current node</p>
*/
var AnnotationsToolBox = Object.xo_create(FloatingToolBox, {

	currentSelection:false,

	/**
	* <p>Init method</p>
	*/
	initialize: function(tool, editor) {

		AnnotationsToolBox._super(this, 'initialize', tool, editor);
		this.setTitle(_('External references'));

		var children = $('#kupu-toolbox-annotation').children().clone(true);
		$(this.element).append(children);
		$('#kupu-toolbox-annotationbox').unbind().remove();


		/**
		*<p>Click method on every tag category</p>
		*<p>This action will toggle the panel with the results for every category.</p>
		*/
		$('.anottationtoolbox-section-header', this.element).click(function(event) {

			this.currentSelection = "#"+event.currentTarget.id;
			$('.anottationtoolbox-section-header', this.element).removeClass('button-pressed');
			$('.anottationtoolbox-section', this.element).hide();
			$(event.currentTarget)
				.addClass('button-pressed')
				.next('.anottationtoolbox-section')
				.slideToggle('fast');

		}.bind(this));
		//End of click event
	
    $('.anottationtoolbox-section', this.element).hide();
    this.editor.logMessage(_('AnnotationToolBox tool initialized'));
	},


	/**
	*<p>Update the annotation info.</p>	
	*<p>This method is called from XimdocAnnotationTool.class.js</p>
	*/
	refreshInfo: function(annotationDoc) {
		//update class for selection
		$('.anottationtoolbox-section-header', this.element).removeClass('button-pressed');
		if(annotationDoc !== null) {

			if (this.currentSelection){
				$(this.currentSelection, this.element).addClass('button-pressed');
			}
			else{
				$('#anottationtoolbox-section-header-image', this.element).addClass('button-pressed');
			}


			//Load each category with its results
			this.populateImageSection(annotationDoc.content.images);
			this.populateLinkSection(annotationDoc.content.links);
			this.populateArticleSection(annotationDoc.content.articles);

			this.populatePeopleSection(annotationDoc.semantic.people);
			this.populatePlacesSection(annotationDoc.semantic.places);
			this.populateOrganisationsSection(annotationDoc.semantic.orgs);

			$('#anottationtoolbox-section-link, #anottationtoolbox-section-image, #anottationtoolbox-section-article, #anottationtoolbox-section-people, #anottationtoolbox-section-places, #anottationtoolbox-section-organisations').slideUp('fast');

			//restart styles for every category
			if(this.currentSelection){		
				$(this.currentSelection.replace("-header","")).slideDown('fast');
				$(this.currentSelection,this.element).addClass("button-pressed");
			}else if (annotationDoc.content.images.length > 0) {
				$('#anottationtoolbox-section-header-image').addClass("button-pressed");
				$('#anottationtoolbox-section-image').slideDown('fast');
			} else if (annotationDoc.content.links.length > 0) {
				$('#anottationtoolbox-section-link').slideDown('fast');
				$('#anottationtoolbox-section-header-link').addClass("button-pressed");
			} else if (annotationDoc.content.articles.length > 0){
				$('#anottationtoolbox-section-article').slideDown('fast');
				$('#anottationtoolbox-section-header-article').addClass("button-pressed");
			}
			else if(annotationDoc.semantic.people.length > 0){
				$('#anottationtoolbox-section-people').slideDown('fast');
				$('#anottationtoolbox-section-header.people').addClass("button-pressed");
			} else if (annotationDoc.semantic.places.length > 0){
				$('#anottationtoolbox-section-places').slideDown('fast');
				$('#anottationtoolbox-section-header-places').addClass("button-pressed");
			} else if (annotationDoc.semantic.orgs.length > 0){
				$('#anottationtoolbox-section-organisations').slideDown('fast');
				$('#anottationtoolbox-section-header-organisations').addClass("button-pressed");
			}


			//$('.xim-tagsinput-container').tagsinput('addTagslist', annotationDoc["semantic"] );
		}
	},


	/**
	* <p>Load link category in a specific way</p>
	* @param info. Object with a structure like:
	* "Link anchor": {confidence:[0-1], type:"zLink", isSemantic:0, others:{...}}
	*/
	populateLinkSection: function(info) {


		var div = $('#anottationtoolbox-link-template', this.element).clone(true);
		$(".removable", div).remove();
		$(div).appendTo('#anottationtoolbox-section-link');
		$(div).attr('id', 'anottationtoolbox-link-container');
		$('#anottationtoolbox-link-template', this.element).hide();
		
		var countLinks=0;
		var length = info.length;
		var k = 0;

		//For every link. i is the name for the link.
		for(var i in info) {
			var divHeader = $('#anottationtoolbox-linkheader-template', div).clone(true);
			divHeader.show();			
			divHeader.addClass("removable");
			$(divHeader).attr('id', '');
			$(divHeader).click(function(event) {this.toggleItem(event);}.bind(this));
			$(divHeader).html(i);
			$(divHeader).appendTo(div);

			var anchor = $('#anottationtoolbox-linkitem-template', div).clone(true);
			$(anchor).attr('id', 'anottationtoolbox-linkitem' + k);
			$(anchor).appendTo(div);
			$(anchor).empty();

			targetLength = info[i].others.target.length;
			for(var l = 0; l < targetLength; l ++) {
				var typeText = document.createTextNode(info[i].others.target[l].type + ' ');
				$(anchor).append(typeText);

				var linkgo = $('#anottationtoolbox-linkitem-template_template_visit', div).clone(true);
				$(linkgo).attr('href', info[i].others.target[l].url);
				$(linkgo).attr('id', 'anottationtoolbox-linkitem' + k + '_' + l + '_visit');
				$(anchor).append($(linkgo));

				var linkadd = $('#anottationtoolbox-linkitem-template_template', div).clone(true);
				$(linkadd).click(function(event) {this.addLinkToDocument(event);}.bind(this));
				$(linkadd).attr('id', 'anottationtoolbox-linkitem' + k + '_' + l);
				$(linkadd).attr('anchorname', info[i].others.anchor);
				$(anchor).append($(linkadd));

				$(anchor).append('<br/>');
			}

			$(divHeader, anchor).show();
			countLinks++;
			k++;
		}

		//Update the number of results		
		if(countLinks==0){
                        $('#anottationtoolbox-section-header-link').click(function (event) {
                                var NoRefs = document.createTextNode("References not found.");
                                $('#anottationtoolbox-section-link').empty();
                                $('#anottationtoolbox-section-link').append(NoRefs);
                        }.bind(this));
                }
		$('#anottationtoolbox-section-header-link span.hits').remove();
                $('#anottationtoolbox-section-header-link span').append('<span class="hits">'+countLinks+'</span>');


		//Hide the header elements
		$('#anottationtoolbox-linkheader-template', div).hide();
		$('#anottationtoolbox-linkitem-template', div).hide();
	},

/**
	* <p>Load image category in a specific way</p>
	* @param info. Object with a structure like:
	* "Image anchor": {confidence:[0-1], type:"zImage", isSemantic:0, others:{...}}
	*/
	populateImageSection: function(info) {
		var infoContainerImageDiv = $('#infoContainer-image', this.element);
		var sliderContainerImageDiv = $('#sliderContainer-image', this.element);
		$(".removable", infoContainerImageDiv).remove();
		$(".removable", sliderContainerImageDiv).remove();

		var length = info.length;
		var countImages = 0;
		var k = 0;
		//For each image, where i is the image name
		for (var i in info){		
			var infoImageDiv = $('#infoImage-template', this.element).clone(true);
			infoImageDiv.show();
			infoImageDiv.addClass("removable");
			$(infoImageDiv).attr('id', 'infoImageDiv' + k);
			var descriptionText = document.createTextNode(i);
			var licenseText = document.createTextNode(info[i].others.license);
			$('#description-image', infoImageDiv).empty().append(descriptionText);
			$('#license-image', infoImageDiv).empty().append(licenseText);
			$(infoContainerImageDiv).append($(infoImageDiv));

			var img = $('#anottationtoolbox-imageitem-template', this.element).clone(true);
			$(img).attr('src', info[i].others.url_m);
			$(img).attr('id', 'anottationtoolbox-imageitem' + k);
			if(countImages > 0) {
				$(img).hide();
				$(infoImageDiv).hide();
			}
			$(img).click(function (event) {this.addImageToDocument(event);}.bind(this));
			$(sliderContainerImageDiv).append($(img));
			countImages ++;
			k++;
		}

		//Update the number of results
		if(countImages==0){
                        $('#anottationtoolbox-section-header-image').click(function (event) {
                                var NoRefs = document.createTextNode("References not found.");
                                $('#anottationtoolbox-section-image').empty();
                                $('#anottationtoolbox-section-image').append(NoRefs);
                        }.bind(this));
                }
		$('#anottationtoolbox-section-header-image span.hits').remove();
                $('#anottationtoolbox-section-header-image span').append('<span class="hits">'+countImages+'</span>');


		//Set image navigation tools.
		var prevImageButton = $('#prevButton-image', this.element);
		var nextImageButton = $('#nextButton-image', this.element);
		$(prevImageButton).click(function (event) {this.slideSwitch('backward');}.bind(this));
		$(nextImageButton).click(function (event) {this.slideSwitch('forward');}.bind(this));


		//Hide the headers
		$('#infoImage-template', this.element).hide();
		$('#anottationtoolbox-imageitem-template', this.element).hide();
		$('#anottationtoolbox-section-image', this.element).show();
	},

	/**
	* <p>Load article category in a specific way</p>
	* @param info. Object with a structure like:
	* "Article anchor": {confidence:[0-1], type:"zLink", isSemantic:0, others:{...}}
	*/
	populateArticleSection: function(info) {
		var articleContainerDiv = $('#articleContainer-article');
		$(".removable", articleContainerDiv).remove();

		var targetLength = info.length;
		var countArticles=0;
		var k = 0;
		for(var i in info){
			var articleDiv = $('#anottationtoolbox-articleitem-template', this.element).clone(true);
			articleDiv.show();
			articleDiv.addClass("removable");
			$(articleDiv).attr('id', '');
			var articleDivText = document.createTextNode(i);

			var link = $('#anottationtoolbox-articleitem-template_template_visit', this.element).clone(true);
			$(link).attr('href', info[i].others.url);
			$(link).attr('id', 'anottationtoolbox-articleitem' + k + '_visit');

			var linkAdd = $('#anottationtoolbox-articleitem-template_template', this.element).clone(true);
			$(linkAdd).attr('id', 'anottationtoolbox-articleitem' + k);
			$(linkAdd).attr('anchorname', i);

			var container = $('.anottationtoolbox-actions', articleDiv).clone(true).empty();
			articleDiv.empty().append(articleDivText).append(container);
			container.append($(link));
			container.append($(linkAdd));

			$(linkAdd).click(function (event) {this.addArticleToDocument(event);}.bind(this));
			$(articleContainerDiv).append($(articleDiv));
			k++;
			countArticles++;
		}

		if(countArticles==0){
                        $('#anottationtoolbox-section-header-article').click(function (event) {
                                var NoRefs = document.createTextNode("References not found.");
                                $('#anottationtoolbox-section-article').empty();
                                $('#anottationtoolbox-section-article').append(NoRefs);
                        }.bind(this));
                }
		$('#anottationtoolbox-section-header-article span.hits').remove();
                $('#anottationtoolbox-section-header-article span').append('<span class="hits">'+countArticles+'</span>');

		$('#anottationtoolbox-articleitem-template', this.element).hide();
		$('#anottationtoolbox-section-article').show();
	},

	/**
	* <p>Load people category in a specific way</p>
	* @param info. Object with a structure like:
	* "People anchor": {confidence:confidence, type:"dPerson", isSemantic:1, others:{...}}
	*/
	populatePeopleSection: function(info) {
		var peopleContainerDiv = $('#peopleContainer');
		$(".removable", peopleContainerDiv).remove();
		
		
		var length = info.length;
    var countPeople = 0;
		var k = 0;
		for (var i in info){
			var articleDiv = $('#anottationtoolbox-personitem-template', this.element).clone(true);
			articleDiv.show();
			articleDiv.addClass("removable");
			$(articleDiv).attr('id', '');
			var articleDivText = document.createTextNode(i);

			var link = $('#anottationtoolbox-personitem-template_template_visit', this.element).clone(true);
			$(link).attr('href', i);
			$(link).attr('id', 'anottationtoolbox-personitem_' + k + '_visit');

			var linkAdd = $('#anottationtoolbox-personitem-template_template', this.element).clone(true);
			$(linkAdd).attr('id', 'anottationtoolbox-personitem_' + k);
			$(linkAdd).attr('anchorname', i);

			var container = $('.anottationtoolbox-actions', articleDiv).clone(true).empty();
			articleDiv.empty().append(articleDivText).append(container);
			if(info[i].length>0){
				container.append($(link));
			}
			container.append($(linkAdd));

			$(linkAdd).click(function (event) {this.addTag(event, 'people');}.bind(this));
			$(peopleContainerDiv).append($(articleDiv));
			countPeople++;
			k++;
		}

		if(countPeople==0){
			$('#anottationtoolbox-section-header-people').click(function (event) {
				var NoRefs = document.createTextNode("References not found.");
				$('#anottationtoolbox-section-people').empty();
				$('#anottationtoolbox-section-people').append(NoRefs);
			}.bind(this));
		}
		$('#anottationtoolbox-section-header-people span.hits').remove();
		$('#anottationtoolbox-section-header-people span').append('<span class="hits">'+countPeople+'</span>');
	
		$('#anottationtoolbox-personitem-template', this.element).hide();
		$('#anottationtoolbox-section-people').show();
	},

	/**
	* <p>Load link category in a specific way</p>
	* @param info. Object with a structure like:
	* "Place anchor": {confidence:confidence, type:"dPlace", isSemantic:1, others:{...}}
	*/
	populatePlacesSection: function(info) {
		var placesContainerDiv = $('#placesContainer');
		$(".removable", placesContainerDiv).remove();

		var length = info.length;
    var countPlaces = 0;
		var k = 0;
    for(var i in info) {
			var articleDiv = $('#anottationtoolbox-placeitem-template', this.element).clone(true);
			articleDiv.show();
			articleDiv.addClass("removable");
			$(articleDiv).attr('id', '');
			var articleDivText = document.createTextNode(i);

			var link = $('#anottationtoolbox-placeitem-template_template_visit', this.element).clone(true);
			$(link).attr('href', i);
			$(link).attr('id', 'anottationtoolbox-placeitem' + k + '_visit');

			var linkAdd = $('#anottationtoolbox-placeitem-template_template', this.element).clone(true);
			$(linkAdd).attr('id', 'anottationtoolbox-placeitem' + k);
			$(linkAdd).attr('anchorname', i);

			var container = $('.anottationtoolbox-actions', articleDiv).clone(true).empty();
			articleDiv.empty().append(articleDivText).append(container);
			if(info[i].length>0){
				container.append($(link));
			}
			container.append($(linkAdd));

			$(linkAdd).click(function (event) {this.addTag(event,'places');}.bind(this));
			$(placesContainerDiv).append($(articleDiv));
			countPlaces++;
			k++;
		}

		if(countPlaces==0){
			$('#anottationtoolbox-section-header-places').click(function (event) {
				var NoRefs = document.createTextNode("References not found.");
				$('#anottationtoolbox-section-places').empty();
				$('#anottationtoolbox-section-places').append(NoRefs);
			}.bind(this));
		}
		$('#anottationtoolbox-section-header-places span.hits').remove();
		$('#anottationtoolbox-section-header-places span').append('<span class="hits">'+countPlaces+'</span>');

		$('#anottationtoolbox-placeitem-template', this.element).hide();
		$('#anottationtoolbox-section-places').show();
	},

	/**
	* <p>Load organisation category in a specific way</p>
	* @param info. Object with a structure like:
	* "Organizacion anchor": {confidence:confidence, type:"dOrganization", isSemantic:1, others:{...}}
	*/	
	populateOrganisationsSection: function(info) {
		var organisationsContainerDiv = $('#organisationsContainer');
		$(".removable", organisationsContainerDiv).remove();
		
		var length = info.length;
    var countOrgs = 0;
		var k = 0;
		for (var i in info){
			var articleDiv = $('#anottationtoolbox-organisationitem-template', this.element).clone(true);
			articleDiv.show();
			articleDiv.addClass("removable");
			$(articleDiv).attr('id', '');
			var articleDivText = document.createTextNode(i);

			var link = $('#anottationtoolbox-organisationitem-template_template_visit', this.element).clone(true);
			$(link).attr('href', i);
			$(link).attr('id', 'anottationtoolbox-organisationitem' + k + '_visit');

			var linkAdd = $('#anottationtoolbox-organisationitem-template_template', this.element).clone(true);
			$(linkAdd).attr('id', 'anottationtoolbox-organisationitem' + k);
			$(linkAdd).attr('anchorname', i);

			var container = $('.anottationtoolbox-actions', articleDiv).clone(true).empty();
			articleDiv.empty().append(articleDivText).append(container);
			if(info[i].length>0){
				container.append($(link));
			}
			container.append($(linkAdd));

			$(linkAdd).click(function (event) {this.addTag(event,'organisations');}.bind(this));
			$(organisationsContainerDiv).append($(articleDiv));
			countOrgs++;
			k++;
		}

		if(countOrgs==0){
			$('#anottationtoolbox-section-header-organisations').click(function (event) {
				var NoRefs = document.createTextNode("References not found.");
				$('#anottationtoolbox-section-organisations').empty();
				$('#anottationtoolbox-section-organisations').append(NoRefs);
			}.bind(this));
		}
		$('#anottationtoolbox-section-header-organisations span.hits').remove();
		$('#anottationtoolbox-section-header-organisations span').append('<span class="hits">'+countOrgs+'</span>');

		$('#anottationtoolbox-organisationitem-template', this.element).hide();
		$('#anottationtoolbox-section-organisations').show();
	},

	toggleItem: function(event) {
		var id = $(event.target.nextSibling, this.element).attr('id');
		$('#' + id, this.element).each(function(index,elem) {
			$(elem).slideToggle("fast");
		}.bind(this));
	},

	/**
	 * Function which adds a tag to document
	 *
	 * @param clickEvent
	 * @param type
	 *
	 */
	addTag: function(clickEvent, type) {
		var rngElementNames = this.editor.getRngDocument().getRngElementNameByType('annotation_tag');

		if(rngElementNames.length == 0) {
			this.editor.alert(_('No `annotation_tag` RngElement type found'));
			return;
		}

		var rngElementName = rngElementNames[0];
		var parent = $(clickEvent.target).closest('.anottationtoolbox-articleitem');
		var word = $('.anottationtoolbox-linkadd', parent).attr('anchorName');
		var link = $('.anottationtoolbox-linkgo', parent).attr('href');

		//temporal measure
		$('.xim-tagsinput-container').tagsinput('createTag',{text: word, typeTag: type, url: link, description:''});
		$('.xim-tagsinput-container').show();

		// Locating all words in document
		var elementsToParse = this.editor.getRngDocument().getAllowedParents(rngElementName);

		elementsToParse.each(function(index, elementToParse) {
			this.editor.setActionDescription(_('Applied `annotation tag`'));
			$(elementToParse + ":contains('" + word + "')", this.editor._xmlDom).each(function(index,elem) {

				var rngElement = this.editor.getRngDocument().getElement(rngElementName);
				var parentElement = this.editor._ximdoc.getElement($(elem).attr('uid'));

				selNode = $('[uid="' + $(elem).attr('uid') + '"]', this.editor.getInnerDocument());

				$($(selNode).contents().get().reverse()).each(function(index, el) {
					if(el.nodeType == 3 && el.nodeValue.indexOf(word) >= 0) {
						var size = $(selNode).contents().length;
						var ptdIndex = Math.floor(((size-index-1) / 2));
						var brotherElement = parentElement.childNodes[ptdIndex];
						var selectedTextNode = el;
						var pieces = selectedTextNode.nodeValue.split(word);
						for(var it = pieces.length -1; it > 0; it--) {
							var prevText = pieces[it - 1];
							var postText = pieces[it];
							var pre = this.editor.getInnerDocument().createTextNode(prevText);
							var post = this.editor.getInnerDocument().createTextNode(postText);

							if(it == 1){
								$(selectedTextNode).before(pre);
							}
							$(selectedTextNode).after(post);

							//New elemente to append (tag)
							var newElement = new XimElement(rngElement, false);
							newElement.attributes['type'] = type;
							if(link!=undefined){
								newElement.attributes['url'] = link;
							}
							else{
								newElement.attributes['url'] = '';
							}
							newElement.value = word;

							if(brotherElement)
								this.editor.getXimDocument().insertBefore(newElement, parentElement, brotherElement);
							else
								this.editor.getXimDocument().appendChild(newElement, parentElement);

							this.editor.setActionDescription(_('Applied `annotation tag`'));
							ptdIndex ++;
							brotherElement = parentElement.childNodes[ptdIndex];
						}
						$(selectedTextNode).remove();
					}
				}.bind(this));
			}.bind(this));
		}.bind(this));

		this.editor.updateEditor({caller: this});

	},

	addImageToDocument: function(clickEvent) {

		var rngElementNames = this.editor.getRngDocument().getRngElementNameByType('annotation_image');
		if(rngElementNames.length == 0) {
			alert(_('No annotation_image RngElement type found'));
			return;
		}

		var rngElementName = rngElementNames[0];
		var target = clickEvent.target;

		if(target) {

			if(this.editor.ximParent) {
				var ximElement = this.editor.tools['ximdoctool'].createElement(rngElementName, this.editor.ximParent, this.editor.ximElement);
			} else if (this.editor.ximElement.isRoot) {
				var ximElement = this.editor.tools['ximdoctool'].createElement(rngElementName, this.editor.ximElement, null);
			}

			if(ximElement) {
				ximElement.attributes['url'] = $(target).attr('src');
				ximElement.attributes['height'] = $(target).attr('height');
				ximElement.attributes['width'] = $(target).attr('width');
				this.editor.updateEditor({caller: this});
			}
		}
	},

	addLinkToDocument: function(clickEvent) {

		this.editor.setActionDescription(_('Applied annotation link'));

		var rngElementNames = this.editor.getRngDocument().getRngElementNameByType('annotation_link');

		if(rngElementNames.length == 0) {
			this.editor.alert(_('No annotation_link RngElement type found'));
			return;
		}


		var rngElementName = rngElementNames[0];
                //This way is valid just for one result
		var idLink = $(clickEvent.target).attr("id")+"_visit";
		var parent = $(clickEvent.target).closest('.anottationtoolbox-linkitem');
		var word = $('.anottationtoolbox-linkadd', parent).attr('anchorName');
		var link = $('#'+idLink,parent).attr('href');

		// Locating all words in document
		var elementsToParse = this.editor.getRngDocument().getAllowedParents(rngElementName);

		elementsToParse.each(function(index, elementToParse) {
			$(elementToParse + ":contains('" + word + "')", this.editor._xmlDom).each(function(index,elem) {

				var rngElement = this.editor.getRngDocument().getElement(rngElementName);
				/*var newElement = new XimElement(rngElement, true);
				newElement.attributes['a_enlaceid_url'] = link;
				newElement.value = word;*/
				var parentElement = this.editor._ximdoc.getElement($(elem).attr('uid'));

				selNode = $('[uid="' + $(elem).attr('uid') + '"]', this.editor.getInnerDocument());
				$($(selNode).contents().get().reverse()).each(function(index, el) {
					if(el.nodeType == 3 && el.nodeValue.indexOf(word) >= 0) {
						var size = $(selNode).contents().length;
						var ptdIndex = Math.floor(((size-index-1) / 2));
						var brotherElement = parentElement.childNodes[ptdIndex];
						var selectedTextNode = el;
						var pieces = selectedTextNode.nodeValue.split(word);
						for(var it = pieces.length -1; it > 0; it--) {
							var prevText = pieces[it-1];
							var postText = pieces[it];
							var pre = this.editor.getInnerDocument().createTextNode(prevText);
							var post = this.editor.getInnerDocument().createTextNode(postText);

							if(it == 1)
								$(selectedTextNode).before(pre);
							$(selectedTextNode).after(post);

							var newElement = new XimElement(rngElement, true);
							newElement.attributes['a_enlaceid_url'] = link;
							newElement.value = word;

							if(brotherElement)
								this.editor.getXimDocument().insertBefore(newElement, parentElement, brotherElement);
							else
								this.editor.getXimDocument().appendChild(newElement, parentElement);

							this.editor.setActionDescription(_('Applied annotation link'));
							ptdIndex ++;
							brotherElement = parentElement.childNodes[ptdIndex];
						}
						$(selectedTextNode).remove();
					}
				}.bind(this));
			}.bind(this));
		}.bind(this));

		this.editor.updateEditor({caller: this});
	},

	addArticleToDocument: function (clickEvent) {

		var rngElementRelatedContainerNames = this.editor.getRngDocument().getRngElementNameByType('related_info_container');
		var rngElementContainerNames = this.editor.getRngDocument().getRngElementNameByType('annotation_related_info');
		var rngElementElementNames = this.editor.getRngDocument().getRngElementNameByType('annotation_related_info_element');

		if(rngElementContainerNames.length == 0) {
			this.editor.alert(_('No annotation_related_info RngElement type found'));
			return;
		}

		if(rngElementElementNames.length == 0) {
			this.editor.alert(_('No annotation_related_info_element RngElement type found'));
			return;
		}

		var rngElementRelatedContainerName = (rngElementRelatedContainerNames.length > 0) ? rngElementRelatedContainerNames[0] : null;
		var rngElementContainerName = rngElementContainerNames[0];
		var rngElementElementName = rngElementElementNames[0];

		var uid = $(rngElementContainerName + '[identificador="annotator"]', this.editor._xmlDom).attr('uid');
		if(!uid) {
			var parentUid = (rngElementRelatedContainerName) ? $(rngElementRelatedContainerName, this.editor._xmlDom).attr('uid') : null;
			var relatedInfoContainer = $(rngElementContainerName + '[identificador="annotator"]', this.editor._xmlDom);

			var rngElement = this.editor.getRngDocument().getElement(rngElementContainerName);
			var newElement = new XimElement(rngElement, false);
			var parentElement = (parentUid) ? this.editor.getXimDocument().getElement(parentUid) : this.editor.getXimDocument().getRootElement();
			newElement.attributes['identificador'] = 'annotator';

			var ximElement = this.editor.getXimDocument().appendChild(newElement, parentElement);
		}

		var parent = $(clickEvent.target).closest('.anottationtoolbox-articleitem');
		var word = $('.anottationtoolbox-linkadd', parent).attr('anchorName');
		var link = $('.anottationtoolbox-linkgo', parent).attr('href');

		if (parent) {
			var rngElement = this.editor.getRngDocument().getElement(rngElementElementName);
			var newElement = new XimElement(rngElement, false);
			var parentElement = ximElement || this.editor.getXimDocument().getElement(uid);
			newElement.attributes['identificador'] = 'annotator';

			var ximElement = this.editor.getXimDocument().appendChild(newElement, parentElement);

			rngElement = this.editor.getRngDocument().getRngElementNameByType('annotation_link');
			if (Object.isEmpty(rngElement)) {
				this.editor.logMessage(_("An article cannot be inserted in this document. Check for annotation_link element."));
				return;
			}

			rngElement = this.editor.getRngDocument().getElement(rngElement[0]);
			newElement = new XimElement(rngElement, false);
			parentElement = ximElement;
//			parentElement.value = '';
			newElement.attributes['a_enlaceid_url'] = link;
			newElement.value = word;

			var ximElement = this.editor.getXimDocument().appendChild(newElement, parentElement);

			var tagName = ximElement.tagname || _("element");
			this.editor.setActionDescription(_('Create ')+tagName);
			this.editor.updateEditor({caller: this});
		}
	},

	slideSwitch: function (to) {
	    var visibleImages = $('#sliderContainer-image IMG:visible');

	    if(visibleImages.length == 0) {
	    	visibleImages = (to == 'forward') ? $('#sliderContainer-image IMG:last') : $('#sliderContainer-image IMG:first');
		}

	    if(to == 'forward') {
		    var nextImage =  visibleImages.next().length ? visibleImages.next()
		        : $('#sliderContainer-image IMG:first');
	    } else {
		    var nextImage =  visibleImages.prev().length ? visibleImages.prev()
		        : $('#sliderContainer-image IMG:last');
	    }

	    var visibleId = $(visibleImages).attr('id');
	    var nextId = $(nextImage).attr('id');
		visibleId = visibleId.replace('anottationtoolbox-imageitem', 'infoImageDiv');
		nextId = nextId.replace('anottationtoolbox-imageitem', 'infoImageDiv');

	    visibleImages.toggle();
		$('#' + visibleId).toggle();
	    nextImage.toggle();
	    $('#' + nextId).toggle();
	}

/*

	// Unused?

	updateState: function(options) {
		return;
	},

	afterUpdateContent: function(options) {
		return;
	},

	removeSection: function() {
		return;
	},

	removeAllSections: function() {
		$('div.anottationtoolbox-section', this.element).each(function(index, elem) {
			$(elem).remove();
		}.bind(this));
		$('.anottationtoolbox-section-header', this.element).each(function(index, elem) {
			$(elem).remove();
		}.bind(this));
	}

*/
});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




var AnnotationsRdfaToolBox = Object.xo_create(FloatingToolBox, {
	
	initialize: function(tool, editor) {
		AnnotationsRdfaToolBox._super(this, 'initialize', tool, editor);
		this.setTitle(_('Rdfa annotations'));

		var children = $('#kupu-toolbox-annotationrdfa').children().clone(true);
		$(this.element).append(children);
		$('#kupu-toolbox-annotationrdfa').unbind().remove();
	
		$('.anottationrdfatoolbox-section-header', this.element).click(function(event) {
			$('.anottationrdfatoolbox-section', this.element).hide();
			$(event.target).next('.anottationrdfatoolbox-section').slideToggle('fast');
		}.bind(this));
        
        $('.anottationrdfatoolbox-section', this.element).hide();
        this.loadAnnotations();
        this.editor.logMessage(_('AnnotationRdfaToolBox tool initialized'));
        
	},
	
	loadAnnotations: function() {
		 $.getJSON(X.baseUrl + "/extensions/rdfapi-php/geosparql.php", function(json){
			 this.printClass("http://xmlns.com/foaf/0.1/", 
					 json["http://xmlns.com/foaf/0.1/"], 
					 $('.anottationrdfatoolbox-section-foaf'));
			 this.printClass("http://www.geonames.org/ontology", 
					 json["http://www.geonames.org/ontology"], 
					 $('.anottationrdfatoolbox-section-geo'));
		 }.bind(this));
	},
	printClass: function(key, classInfo, container) {
		var ul = $('<ul></ul>');
		container.append(ul);
		
		for (k in classInfo) {
			var value = classInfo[k];
			var link = $('<a></a>')
				.attr('href', '#')
				.attr('title', value['info']['comment'])
				.html(value['info']['label'])
				.click(function() { return false;});
			
			var li = $('<li></li>');
			li.append(link);
			ul.append(li);
			
			if(Object.isObject(value['properties'])) {
				this.printProperty(value['properties'], li);
			}
		}
	},
	
	printProperty: function (info, container) {
		var ul = $('<ul></ul>');
		
		for (k in info) {
			var value = info[k];
			var link = $('<a></a>')
			.attr('href', '#')
			.attr('title', value['info']['comment'])
			.html(value['info']['label'])
			.click(function() { return false;});
//			var box = $('<input type="text"></input>');
			
		    $(link).click(function(event) {this.addRdfaInContainer(event);}.bind(this));
//		    $(link).attr('id', 'anottationtoolbox-linkitem' + k + '_' + l);
//		    $(link).attr('anchorname', info[k].anchor);
		
			var li = $('<li></li>');
			li.append(link);
			ul.append(li);
		};
		container.append(ul);
	},
	addRdfaInContainer: function(clickEvent) {
		console.log(clickEvent);
    	var selection = this.editor.getSelection().parentElement();
    	console.log(selection);
	}
	

});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */




var RNGElementsToolBox = Object.xo_create(FloatingToolBox, {

	_init: function(options) {
		RNGElementsToolBox._construct(this, options);
	},
	initialize: function(tool, editor) {
		RNGElementsToolBox._super(this, 'initialize', tool, editor);
		this.setTitle(_('Available elements'));
        this._initializeToolbar();
        this.editor.logMessage(_('ToolbarButtonsToolBox tool initialized'));
	},
	_initializeToolbar: function() {

		var commonGroup = $('<div/>');
		var buttonGroup = $('<span/>');

		$([commonGroup, buttonGroup]).css({
			'border-left': '2px solid #bbbbbb',
			'padding-left': '8px'
		});

		$(this.element)
			.attr('id', 'kupu-tb-rngbuttons')
			.addClass('kupu-tb-buttons')
			.addClass('kupu-tb-buttons-tool')
			.append(commonGroup)
			.append(buttonGroup);

		var rngElements = this.editor.config.rng_elements;
		if (rngElements) {
			var model = this.editor.getRngDocument().getModel();
			var default_icon_class = this.editor.config.default_button_class;

			for (var rngElementName in model) {

				rngElementName = rngElementName.replace(":", "_");
				var rngTagName = 'rng_element_%s'.printf(rngElementName);

				if (rngElementName != "docxap") {

					var buttonId = 'kupu-%s-button'.printf(rngElementName);
					var commonElement = rngElements[rngTagName];
					if (commonElement) {
						var icon_class = rngElements[rngTagName].classname;
					} else {
						var icon_class = default_icon_class;
					}

					var button = $('<div/>')
						.addClass(icon_class)
						.addClass('kupu-button')
						.attr('id', buttonId)
						.attr('title', _('Add') + ' ' + model[rngElementName].description + ' ' + _('under the currently selected element'))
						.attr('i18n:attributes', 'title');
						var description = $('<div>' +window.i18n_message_catalog.acents(window.i18n_message_catalog.translate('Add')) + ' ' + model[rngElementName].description + '</div>');

					$(button).append(description);
					$(commonGroup).append(button);

					var rngbutton = new XimdocRngElementButton(buttonId, model[rngElementName], this.tool);
					this.editor.registerTool(rngElementName + '_rngbutton', rngbutton);
					rngbutton.disable();
				}
			}
		}
	},
	updateState: function(options) {

		if (!options.selNode || !options.event ||
			(options.event.type != 'click' && options.event.type != 'click' &&
			!(options.event && options.event.type == 'keyup' && options.event.keyCode >= 37 && options.event.keyCode <= 40)))
			return;

		if (this.editor.ximElement && this.editor.ximParent) {
			var rngElement = this.editor.ximElement.schemaNode;
			var rngParent = this.editor.ximParent.schemaNode;

			this.tool.disableAllButtons();

			// This code could be implemented on RNGButton::updateState() method ...

			if (!rngElement.type.contains('ximlet') && this.editor.selectedTextLength > 0) {
				// Enables 'Apply' type buttons.
				for (var i in rngElement.childNodes) {
					var childElement = rngElement.childNodes[i];
					if(!childElement.tagName)
						continue;
					if(childElement.type.contains('apply')) {
						var button = this.editor.getTool('%s_rngbutton'.printf(childElement.tagName));
						button.enable();
					}
				}
			} else {
				// Enables allowed 'Add Sibling' buttons.
				for (var i in rngParent.childNodes) {
					var childElement = rngParent.childNodes[i];
					if(!childElement.tagName)
						continue;
					var button = this.editor.getTool('%s_rngbutton'.printf(childElement.tagName));
					button.enable();
				}

				// Enables 'Edit Ximlet' button, if proceed.
				var button = this.editor.getTool('ximletdrawerbutton');
				button.disable();
				if(rngElement.type.contains('ximlet') && !this.editor.ximElement.isSectionXimlet()) {
					button.enable();
				}
			}
		}
	},
	updateButtonHandler: function(event) {

		return;
		//if (this.tool.selectedNode == null) return;
		var selNode = this.editor.getSelectedNode();

		$('.kupu-attribute-value', this.element).each(function(index, elem) {
			var attrName = $(elem).data('attribute-name');
			var attrValue = $(elem).val();
//			console.log('%s = %s'.printf(attrName, attrValue));
			if (attrName != 'uid') {
				selNode.ximElement.attributes[attrName] = attrValue;
			}
		});

		this.editor.logMessage(_('Attributes updated!'));

		// NOTE:
		// Updates Editor Content, because actually we don't edit html attributes but xml.
		this.setActionDescription(_('Update attributes'));

		// When update button is clicked, selected element losts his focus,
		// so we clean the attributes panel to prevent errors.
		// UpdateEditor will populate panel again.
		this._clean();

		this.editor.updateEditor({caller: this});

	}
});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision: 8360 $
 */


/*
 *Toolbox for use the element navigation bar.
 **/
function NavBarToolBox (){

	this._element; //Dom navbar element
        this._body = null; //String, html document after xslt transformation
	this.buttons; //Array, with buttos for each element in tree way as far as selector node

        this.initialize = function(tool, editor) {
                //Get navbar element
		this._element = $(".kupu-tb-navbar");
		this.editor = editor;
        };

        this.beforeUpdateContent = function(options) {

	};

	/**
	 * Updates the events handlers after update the editor content
	 */
	this.afterUpdateContent = function(options) {
        };


        /*
         *After every change in doc
         **/
	this.updateState = function(options){
                //Initializing editor attribute just once.
		if (!this.editor)
                    this.editor=options.caller;

                //Get current selector element.
		var ximElement = this.editor.ximElement;

                //Initializing vars
		this._element.empty();
		this.nav = []
		this.buttons = [];

                //Appending all ancestor of ximElement in this.nav property
		this._buildPath(ximElement);
                //Start in 1 to avoid docxap element
		for (var i = 1; i < this.nav.length;i++){

			var newTag = $("<span>").text(this.nav[i].tagName).attr("id","tag_"+this.nav[i].uid);

			if (i == this.nav.length -1){
				newTag.addClass("current-tag");
			}else{
				newTag.addClass("selector-tagggg");

			}

			var that = this;
                        newTag.bind('contextmenu', function(e) {
                                        e.preventDefault();
                                        /* Force click to update the clicked node before showing the context menu */
                                        var id = $(this).attr("id");
                                        uid = id.replace("tag_","");
                                        var elements = $('[uid="'+uid+'"]', that.editor.getBody());
                                        if (elements[0]){
                                         	       $(elements[0]).click();
					}
                                        var innerDocument = that.editor.getInnerDocument();
                                        var clonedEvent = innerDocument.createEvent('MouseEvents');
                                        clonedEvent.initMouseEvent(e.type, false, false, window, e.detail, e.screenX, e.screenY, e.clientX, 0, e.ctrlKey, e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
                                        innerDocument.dispatchEvent(clonedEvent);
                                });
                        this._element.append(newTag);

                        //Creating button for newTag
                        var button = new NavBarButton("tag_"+this.nav[i].uid, this);

                        button.initialize(this.editor);
                        this.buttons.push(button);


                }
	};

        /*
         *Construct the elements way to params element.
         *Recursive method.
         **/
	this._buildPath = function(ximElement){
             $(".kupu-tb-navbar").removeClass('not-empty');
            $(".kupu-tb-navbar").addClass('empty');
		if (ximElement.parentNode){
			this._buildPath(ximElement.parentNode);
           $(".kupu-tb-navbar").removeClass('empty');
            $(".kupu-tb-navbar").addClass('not-empty');
		}
		this.nav.push(ximElement);
	};


}
NavBarToolBox.prototype = new XimdocToolBox();

var NavBarButton = Object.xo_create(XimdocButton, {

	_init: function(buttonid, tool) {
		NavBarButton._construct(this, buttonid, this.commandfunc, tool);
	},

	commandfunc: function(event) {
		var newUid = event.buttonid.substring(4);
		var elements = $('[uid="'+newUid+'"]', this.editor.getBody());
		if (elements[0])
			$(elements[0]).click();
    }
});
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision: 7842 $
 */

/**
 * Turn expert mode on/off
 */
var SchemaValidatorButton = Object.xo_create(XimdocButton, {

	commandfunc: function(button, editor) {
		editor.toggleSchemaValidator();
		$('button#kupu-schemavalidator-button').toggleClass('kupu-schemavalidator-pressed').toggleClass('kupu-schemavalidator');
		this.editor.getXimDocument().validateXML(function(valid, msg) {
			if (!valid) editor.alert(msg);
		});
	},

	setSchemaValidator: function(validate) {
		this.editor.setSchemaValidator(validate);
		if (!this.editor.schemaValidatorIsActive()) {
			$('button#kupu-schemavalidator-button')
			.removeClass('kupu-schemavalidator-pressed')
			.addClass('kupu-schemavalidator');
		} else {
			$('button#kupu-schemavalidator-button')
			.removeClass('kupu-schemavalidator')
			.addClass('kupu-schemavalidator-pressed');
		}
	}
});/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision: 7842 $
 */



/**
 * Two states button, changes icon automatically
 */
var ToggleButton = Object.xo_create(XimdocButton, {

	_init: function(options) {
		ToggleButton._construct(this, options.buttonid, options.commandfunc, options.tool);
		this.activeClass = options.activeClass;
		this.inactiveClass = options.inactiveClass;
		this.active = false;
	},

	execCommand: function() {
		this.setActive(!this.active);
		ToggleButton._super(this, 'execCommand');
	},

	getActive: function() {
		return this.active;
	},

	setActive: function(active) {
		this.active = active;
		if (this.active) {
			$(this.button).addClass(this.activeClass);
			$(this.button).removeClass(this.inactiveClass);
		} else {
			$(this.button).addClass(this.inactiveClass);
			$(this.button).removeClass(this.activeClass);
		}
	}
});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision: 7842 $
 */


/**
 * Removes the selected ximElement from the XML document
 */
var XimdocRemoveElementButton = Object.xo_create(XimdocButton, {

	_init: function(buttonid, commandfunc, tool) {
		/* A button specialized in removing elements in the current node
		 *    context. Typical usages include removing links, images, etc. */
		XimdocRemoveElementButton._construct(this, buttonid, null, tool);
		this.onclass = 'invisible';
		this.offclass = 'visible';
		this.pressed = false;
		this.disable();
	},

	commandfunc: function(button, editor) {
		if (this.isEnable()) {
			this.removeElement(this.editor.ximElement);
			this.disable();
		}
	},

	updateState: function(options) {
		this.disable();
		if (options.selNode.ximElement.isRemovable()) {
			this.enable();
		}
	}
});
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision: 7842 $
 */




/**
 * A button specialized in adding new ximelements in the current node context.
 */
var XimdocRngElementButton = Object.xo_create(XimdocButton, {

	_init: function(buttonid, rngElement, tool) {
		XimdocRngElementButton._construct(this, buttonid, null, tool);
		this.rngElement = rngElement;
    },

    initialize: function(editor) {

        XimdocRngElementButton._super(this, 'initialize', editor);

        var body = this.editor.getBody();
        $(this.button).draggable({
        	containment: $('.kupu-editorframe'),
			helper: 'clone',
        	appendTo: 'body',
        	iframeFix: true,
        	start: function(event, ui) {

        		var helper = $(ui.helper[0])
        			.clone()
					.addClass('ui-cloned-helper')
        			.css({
        				position: 'absolute',
        				width: '26px',
        				height: '26px',
        				backgroundColor: '#FFFFFF',
						border: '1px solid #ccc',
						'background-repeat': 'no-repeat'
        			})
        			.show()
        			.appendTo(this.editor.getBody());

    			try {
    				var dtb = this.editor.tools['hovertool'].toolboxes['draggabletoolbox'];
    				dtb.onStart(event, ui);
    			} catch(e) {
    				console.error(e.message);
    			}

        	}.bind(this),
        	drag: function(event, ui) {

				var view = this.editor.getBody().ownerDocument.defaultView;
				var p = {
//					top: ui.position.top - $('.kupu-editorframe').position().top + view.scrollY,
					top: ui.absolutePosition.top - $('.kupu-editorframe').position().top + view.scrollY,
//					left: ui.position.left
					left: ui.absolutePosition.left
				};
				$('.ui-cloned-helper', this.editor.getBody()).css({
					top: p.top,
					left: p.left
				});
        	}.bind(this),
        	stop: function(event, ui) {

        		// TODO: elementFromPoin will not work in all browsers
        		// See http://www.quirksmode.org/dom/w3c_cssom.html
        		// Parameters can be diferent in distinct browsers

        		$('.ui-cloned-helper', this.editor.getBody()).remove();
        		var p = {
//        			x: ui.position.top,
        			x: event.clientX,
//        			x: event.pageX,
//        			y: ui.position.left - $('.kupu-editorframe').position().top
        			y: event.clientY - $('.kupu-editorframe').position().top
//        			y: event.pageY - $('.kupu-editorframe').position().top
        		};

        		var element = this.editor.getBody().ownerDocument.elementFromPoint(p.x, p.y);
        		element = element && element.ximElement ? element.ximElement : null;
        		var parent = element ? element.parentNode : null;
        		this.commandfunc(this, this.editor, this.tool, parent, element);

    			try {
    				var dtb = this.editor.tools['hovertool'].toolboxes['draggabletoolbox'];
    				dtb.onStop(event, ui);
    			} catch(e) {
    				console.error(e);
    			}
        	}.bind(this)
        });

		//this.disableDraggable();
    },

    enable: function() {
    	XimdocRngElementButton._super(this, 'enable');
    	this.enableDraggable();
    },

    enableDraggable: function() {
    	$(this.button).draggable('enable');
    },

    disable: function() {
    	XimdocRngElementButton._super(this, 'disable');
    	this.disableDraggable();
    },

    disableDraggable: function() {
    	$(this.button).draggable('disable');
    },

    commandfunc: function(button, editor, tool, ximParent, ximElement, addChild) {

		ximParent = ximParent || this.editor.ximParent;
		ximElement = ximElement || this.editor.ximElement;

		if (ximElement /*&& ximParent*/) {

			if (ximParent && ximParent == ximElement) {
				this.createElement(this.rngElement.tagName, ximElement, null);
			} else if (!this.rngElement['wizard']) {

				if (this.rngElement.type.contains('apply') || this.editor.selectedTextLength > 0) {
					this.createElement(this.rngElement.tagName, ximElement, null);
				} else if(ximParent && !addChild) {
					this.createElement(this.rngElement.tagName, ximParent, ximElement);
				} else if (ximElement.isRoot || addChild === true) {
					this.createElement(this.rngElement.tagName, ximElement, null);
				}
			} else {

				// TODO: Make this section with a different structure...

				var wizard = this.rngElement.wizard.toLowerCase() + 'managertool';
				var tool = this.editor.getTool(wizard);
		    	var ximdocdrawertool = this.editor.getTool('ximdocdrawertool');

				if (!ximdocdrawertool.drawers[wizard]) {
					if (wizard == 'tablemanagertool') {
						var tablewizarddrawer = new TableWizardDrawer(tool, this.rngElement, ximElement);
					    ximdocdrawertool.registerDrawer(wizard, tablewizarddrawer);
					    //console.log(tablewizarddrawer);
					} else if(wizard == 'listmanagertool') {
						// nothing at this moment...
				    }
				}

			    ximdocdrawertool.openDrawer(wizard);
			}

		} else {
			this.editor.logMessage(_('Error adding new element when clicking ')+this.buttonid);
		}
    },

    addchildfunc: function() {
    	this.commandfunc(null, null, null, null, null, true);
    },

    updateState: function(options) {
    	// see RNGElementsToolBox::updateState()
    }
});

/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */

if (typeof(Function.prototype['bind']) != 'function') {
	Function.prototype.bind = function() {
		var args = arguments;
		var caller = args[0];
		var __method = this;
		delete(args[0]);
		return function() {
			return __method.apply(caller, arguments);
		}
	}
}

var DataSource = function(options) {

	this.options = null;

	this.init = function(options) {
		this.options = $.extend({
			url: null,
			cb_fetched: function(data, textStatus) {/*console.info(arguments);*/},
			type: 'xml'
		}, options);
	};

	this.fetch = function(params, callback) {
		callback = typeof(callback) == 'function'
			? callback
			: this.options.cb_fetched;

		$.get(
			this.options.url,
			params,
			callback,
			this.options.type
		);
	};

	this.init(options);
};

var Iter = function(path) {

	this.path = null;
	this.indexes = null;

	this.init = function(path) {
		if (path === null) path = 'root';
		this.path = path;
		this.indexes = this.path.split(':');
		if (this.indexes[0] != 'root') {
			this.path = 'root:' + path;
			this.indexes = this.path.split(':');
		}
	};

	this.get_row = function(model) {
		//console.log(this.path, model, model[this.path]);
		return model[this.path] || null;
	};

	this.init(path);
};

var RowModel = function(options) {

	this.colModel = null;
	this.queries = null;
	this.rows = null;
	this.index = null;
	this.ds = null;

	this.init = function(options) {
		options = $.extend({queries: null, ds: null}, options);
		this.colModel = options.colModel || {selector: '', columns: []};
		this.queries = options.queries;
		this.index = {root: {data: {}, children: this.rows}};
		this.rows = [this.index.root];
		this.ds = options.ds;
	};

	this.get_path = function(iter) {
		var it = this.get_iter(iter);
		var path = it.indexes.slice(1);
		return path;
	};

	this.get_iter = function(path) {
		var it = null;
		if (path === null || typeof(path) == 'string') {
			it = new Iter(path);
		} else if (typeof(path) == 'object' && path['path']) {
			it = new Iter(path.path);
		}
		return it;
	};

	this.iter_first = function() {
		return new Iter('root:0');
	};

	this.iter_next = function(iter) {
		if (iter == null) return null;
		var indexes = iter.indexes;
		indexes[indexes.length-1]++;
		var it = new Iter(indexes.join(':'));
		if (!it.get_row(this.index)) {
			it = null;
		}
		return it;
	};

	this.iter_previous = function(iter) {
		if (iter == null) return null;
		var indexes = iter.indexes;
		indexes[indexes.length-1]--;
		var it = new Iter(indexes.join(':'));
		if (!it.get_row(this.index)) {
			it = null;
		}
		return it;
	};

	this.iter_parent = function(iter) {
		if (iter == null) return null;
		var indexes = iter.indexes.slice(0, iter.indexes.length-1);
		if (indexes.length == 0) return null;
		//indexes.push('0');
		var it = new Iter(indexes.join(':'));
		if (!it.get_row(this.index)) {
			it = null;
		}
		return it;

	};

	this.iter_children = function(iter, options) {
	};

	this.has_children = function(iter) {
		var it = this.get_iter(iter);
		var row = it.get_row(this.index);
		return row === null ? false : true;
	};

	this.append = function(parent, data) {
		if (parent == null) {
			this.index.root = {
				data: data,
				children: []
			};
			return new Iter('root');
		}
		var it = this.get_iter(parent);
		var row = it.get_row(this.index);
		if (row) {
			var item = {
				data: data,
				children: []
			};
			row.children.push(item);
			var path = it.path + ':' + (row.children.length - 1);
			it = this.get_iter(path);
			this.index[path] = item;
			return it;
		}
		return null;
	};

	this.prepend = function(parent, data) {
		// Implement me!
	};

	this.insert = function(parent, position, data) {
		// Implement me!
	};

	this.insert_before = function(parent, sibling, data) {
		// Implement me!
	};

	this.insert_after = function(parent, sibling, data) {
		// Implement me!
	};

	this.remove = function(iter) {
		var it = this.get_iter(iter);
		var pit = this.iter_parent(it);
		delete this.index[pit.path].children[it.indexes[it.indexes.length-1]];
		delete this.index[it.path];
	};

	this.remove_children = function(iter) {
		var it = this.get_iter(iter);

		var indexes = it.indexes;
		indexes.push('0');
		var cit = new Iter(indexes.join(':'));
		while (cit) {
			this.remove(cit);
			cit = this.iter_next(cit);
		}

		this.index[it.path].children = [];
	};

	this.clear = function() {
		this.rows = [];
		this.index = {root: {data: {}, children: this.rows}};
		this.rows = [this.index.root];
	};

	this.get_value = function(iter, column) {
		var it = this.get_iter(iter);
		var row = it.get_row(this.index);
		if (row) {
			row = row.data;
			if (column != undefined) row = row[column];
			return row;
		}
		return null;
	};

	this.set_value = function(iter, value, column) {
		var it = this.get_iter(iter);
		var row = it.get_row(this.index);
		if (row) {
			if (column != undefined) {
				row.data[column] = value;
			} else if (value != null && typeof(value) == 'object' && value['push']) {
				row.data = value;
			}
			return row;
		}
		return null;
	};

	this._create_dsNode = function(options) {
		var node = options.node;
		var columns = options.columns;
		var newNode = {};
		var c = 0;
		for (var i=0; i<columns.length; i++) {
			var col = columns[i];
			var oCol = {};
			for (var o in col) {
				oCol[o] = col[o];
			}
			oCol.value = $(node).attr(oCol.name);
			oCol._index = c;
			newNode[col.name] = oCol;
			newNode[c++] = oCol;
		}
		return newNode;
	};

	this.init(options);
};

var TreeModel = function(options) {

	this.iter_children = function(iter, options) {
		if (iter == null) return null;
		var indexes = iter.indexes;
		indexes.push('0');
		var it = new Iter(indexes.join(':'));

		options = $.extend({params: {}, cache: false}, options);

		if (options.cache /*&& this.has_children(it)*/) {
			if (typeof(options.callback) == 'function') options.callback(it);
			return it;
		}

		this.ds.fetch(
			options.params,
			function(data, textStatus) {
				if (textStatus == 'success') {
					var nodes = $(this.colModel.selector, data);
					nodes.each(function(idx, node) {
						var fields = {};
						var f = 0;
						$(this.colModel.columns).each(function(idx, col) {
							fields[col.name] = $(node).attr(col.name);
							fields[f] = $(node).attr(col.name);
							f++;
						});
						this.append(iter, fields);
					}.bind(this));
					if (typeof(options.callback) == 'function') options.callback(it);
				} else {
					console.error(arguments);
				}
			}.bind(this)
		);

		return it;
	};

	this.init(options);
};
TreeModel.prototype = new RowModel();

var ButtonBarModel = function(options) {

	this.data = null;

	this.load_data = function(options) {
		this.ds.fetch(
			options.params,
			function(data, textStatus) {
				if (textStatus == 'success') {
					this.data = data;
					if (typeof(options.callback) == 'function') options.callback();
				} else {
					console.error(arguments);
				}
			}.bind(this)
		);
	};

	this.query = function(options) {
		if (this.data === null) return null;
		this.clear();
		var query = this.queries[options.query.query];
		var nodes = $(query.selector, this.data);
			console.log(nodes, this.data);
		for (var i=0; i<nodes.length; i++) {
			var node = nodes[i];
			var row = this._create_dsNode({
				node: node,
				columns: query.columns
			});
			this.append('root', row);
		}
		return this.iter_first();
	};

	this.init(options);
};
ButtonBarModel.prototype = new RowModel();

var MenuBarModel = function(options) {

	this.load_data = function(options) {
		this.ds.fetch(
			options.params,
			function(data, textStatus) {
				if (textStatus == 'success') {
					this.data = data;

					var data = this.query({
						selector: 'menubar > menu > menuitem',
						columns: [
							{name: 'id'},
							{name: 'text'},
							{name: 'accel'}
						]
					});
					this._createMenuItems('root', data);

					if (typeof(options.callback) == 'function') options.callback();
				} else {
					console.error(arguments);
				}
			}.bind(this)
		);
	};

	this._createMenuItems = function(parent, items) {
		parent = this.get_iter(parent);
		if (parent === null) return;
		for (var i=0; i<items.length; i++) {
			var it = this.append(parent, items[i]);
			var children = this.query({
				selector: 'menuitem[id="'+items[i].id+'"] > menu > menuitem',
				columns: [
					{name: 'id'},
					{name: 'text'},
					{name: 'accel'}
				]
			});
			this._createMenuItems(it, children);
		}
	};

	this.query = function(options) {
		if (this.data === null) return null;
		var data = [];
		var nodes = $(options.selector, this.data);
		for (var i=0; i<nodes.length; i++) {
			var node = nodes[i];
			var row = {};
			var f = 0;
			for (var c=0; c<options.columns.length; c++) {
				var alias = options.columns[c].name;
				var value = $(node).attr(alias);
				row[alias] = value;
				row[f] = value;
				f++;
			}
			data.push(row);
		}
		return data;
	};

	this.iter_children = function(iter, options) {
		iter = this.get_iter(iter);
		if (iter == null) return null;
		var indexes = iter.indexes;
		indexes.push('0');
		var it = new Iter(indexes.join(':'));
		return it;
	};

	this.init(options);
};
MenuBarModel.prototype = new RowModel();
/**
 *  \details &copy; 2011  Open Ximdex Evolution SL [http://www.ximdex.org]
 *
 *  Ximdex a Semantic Content Management System (CMS)
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as published
 *  by the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  See the Affero GNU General Public License for more details.
 *  You should have received a copy of the Affero GNU General Public License
 *  version 3 along with Ximdex (see LICENSE file).
 *
 *  If not, visit http://gnu.org/licenses/agpl-3.0.html.
 *
 *  @author Ximdex DevTeam <dev@ximdex.com>
 *  @version $Revision$
 */

(function($) {

	$.widget('ui.treeview', {
		root: null,
		selected: null,
		_init: function() {
			var $this = this.element;
			if (!this.options['rowModel']) this.options.rowModel = new TreeModel(['col1']);
			this.options.rowModel.append(null, {
				text: 'Proyectos',
				nodeid: 10000
			});

			$this.addClass('xim-treeview-container');
			this.setModel(this.options.rowModel);
		},
		_createRoot: function() {
			var $this = this.element;
			var branch = $('<ul></ul>').addClass('xim-treeview-branch');
			var root = this._createNode('root', this.options.rowModel.get_value('root'));
			branch.append(root);
			$this.append(branch);
			return branch;
		},
		_createBranch: function(parent) {
			var $this = this.element;
			var model = this.options.rowModel;
			var iter = model.get_iter($(parent).data('path'));

			var branch = $('<ul></ul>').addClass('xim-treeview-branch');
			model.iter_children(iter, {
				params: {
					method: 'treedata',
					nodeid: $(parent).data('nodeid'),
					nelementos: '50'
				},
				callback: function(it) {
					while (it) {
						var data = model.get_value(it);
						if (data) branch.append(this._createNode(it.path, data));
						it = model.iter_next(it);
					}
					$(parent).append(branch);
				}.bind(this)
			});
		},
		_createNode: function(path, data) {
			var node = $('<li></li>')
				.addClass('xim-treeview-node xim-treeview-collapsed')
				.append(this._createLabel(data));

			node.data('widget', this);
			node.data('path', path);
			node.data('nodeid', data.nodeid);
			node
				.click(function(event) {event.stopPropagation();$(this).data('widget').select(this);})
				.dblclick(function(event) {event.stopPropagation();$(this).data('widget').toggle(this);node.focus();});
			return node;
		},
		_createImage: function(data) {
			image = $('<img></img>').attr('src', this.options.url_base + '../' + data['icon']);
			return image;
		},
		_createLabel: function(data) {
			var $this = $(this);
			var labelClass = (data['isdir'] == 1) ? ('ui-icon ' + this.options.collapsed_icon) : ('ui-icon ui-icon-arrow-1-e');
			var lbl = $('<div></div>');
			lbl.append(
				$('<span></span>')
					.addClass(labelClass)
					.click(function(event) {
						event.stopPropagation();
						var parent = $(this).parents('.xim-treeview-node:first');
						parent.data('widget').toggle(parent);
					})
			);
			lbl.append(this._createImage(data));
			lbl.append($('<span></span>').addClass('xim-treeview-label').html(data.text));
			return lbl;
		},
		getModel: function() {
			return this.options.rowModel;
		},
		setModel: function(model) {
			if (this.root) $(this.root).unbind().remove();
			this.options.rowModel = model;
			this.root = this._createRoot();
			this.expand($('li.xim-treeview-node:first', this.root));
		},
		toggle: function(node) {
			var widget = $(node).data('widget');
			if ($(node).hasClass('xim-treeview-expanded')) {
				widget.collapse(node);
			} else {
				widget.expand(node);
			}
		},
		expand: function(node) {
			var widget = $(node).data('widget');
			if ($('ul.xim-treeview-branch:first', node).length == 0) {
				widget._createBranch(node);
			}
			$('ul.xim-treeview-branch:first', node).show();
			$(node)
				.removeClass('xim-treeview-collapsed')
				.addClass('xim-treeview-expanded');
			$('.ui-icon:first', node)
				.removeClass(widget.options.collapsed_icon)
				.addClass(widget.options.expanded_icon);
			var data = widget.options.rowModel.get_value($(node).data('path'));
			$(node).trigger('expand', [{ui: widget, element: node, data: data}]);
		},
		collapse: function(node) {
			var widget = $(node).data('widget');
			$('ul.xim-treeview-branch:first', node).hide();
			$(node)
				.removeClass('xim-treeview-expanded')
				.addClass('xim-treeview-collapsed');
			$('.ui-icon:first', node)
				.removeClass(widget.options.expanded_icon)
				.addClass(widget.options.collapsed_icon);
			var data = widget.options.rowModel.get_value($(node).data('path'));
			$(node).trigger('collapse', [{ui: widget, element: node, data: data}]);
		},
		select: function(node) {
			var widget = $(node).data('widget');
			if (widget.selected) {
				$('.xim-treeview-label:first', widget.selected).removeClass('xim-treeview-selected');
			}
			widget.selected = node;
			$('.xim-treeview-label:first', widget.selected).addClass('xim-treeview-selected');
			var data = widget.options.rowModel.get_value($(node).data('path'));
			$(node).trigger('select', [{ui: widget, element: node, data: data}]);
		},
		getSelected: function() {
			return this.selected;
		}
	});

	$.ui.treeview.defaults = {
		rowModel: null,
		colModel: null,
		rootLabel: 'ximdex',
		collapsed_icon: 'ui-icon-triangle-1-e',
		expanded_icon: 'ui-icon-triangle-1-se',
		url_base: '',
		/*collapsed_icon: 'ui-icon-carat-1-e',
		expanded_icon: 'ui-icon-carat-1-se'*/
	};
	$.ui.treeview.getter = ['getSelected', 'getModel'];

})(jQuery);
